{
  "categories": [
    {
      "name": "basic",
      "displayName": "Basic Web3 Concepts",
      "description": "Master the foundational concepts of blockchain and Web3 technology",
      "icon": "ðŸ“—",
      "order": 1
    },
    {
      "name": "intermediate",
      "displayName": "Intermediate Concepts",
      "description": "Deep dive into smart contracts, DeFi, and Web3 development",
      "icon": "ðŸ“˜",
      "order": 2
    },
    {
      "name": "advanced",
      "displayName": "Advanced Topics",
      "description": "Expert-level questions on Layer 2, MEV, security, and more",
      "icon": "ðŸ“•",
      "order": 3
    },
    {
      "name": "projects",
      "displayName": "Portfolio Projects",
      "description": "Build real-world Web3 applications to showcase your skills",
      "icon": "ðŸš€",
      "order": 4
    },
    {
      "name": "rust",
      "displayName": "Rust for Web3",
      "description": "Complete Rust tutorial for blockchain development with Substrate, Solana, NEAR & CosmWasm",
      "icon": "ðŸ¦€",
      "order": 5
    }
  ],
  "questions": {
    "basic": [
      {
        "title": "What is a blockchain?",
        "answer": "\n            <p>A blockchain is a distributed, immutable, and transparent digital ledger that records transactions in a secure and chronological order. It consists of a chain of blocks, where each block contains a list of transactions, a timestamp, and a reference (hash) to the previous block.</p>\n            <strong>Key characteristics:</strong>\n            <ul>\n                <li><strong>Decentralization:</strong> It's maintained by a network of computers (nodes) rather than a single central authority.</li>\n                <li><strong>Immutability:</strong> Once a transaction is recorded, it cannot be altered or deleted.</li>\n                <li><strong>Transparency:</strong> All participants on the network can see the recorded transactions.</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 0
      },
      {
        "title": "What is the difference between a centralized and a decentralized network?",
        "answer": "\n            <p>A <strong>centralized network</strong> relies on a single, central server or authority to manage data, traffic, and rules. If the central server fails, the entire network goes down. Examples include traditional banking systems and social media platforms.</p>\n            <p>A <strong>decentralized network</strong> distributes data and workload across multiple computers (nodes). There is no single point of failure, making the network more resilient and censorship-resistant. Blockchains like Bitcoin and Ethereum are examples of decentralized networks.</p>\n            <table>\n                <tr><th>Aspect</th><th>Centralized</th><th>Decentralized</th></tr>\n                <tr><td>Control</td><td>Single entity</td><td>Distributed among participants</td></tr>\n                <tr><td>Single point of failure</td><td>Yes</td><td>No</td></tr>\n                <tr><td>Censorship resistance</td><td>Low</td><td>High</td></tr>\n                <tr><td>Transparency</td><td>Limited</td><td>Full</td></tr>\n            </table>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 1
      },
      {
        "title": "What is a distributed ledger?",
        "answer": "\n            <p>A <strong>distributed ledger</strong> is a database that is consensually shared, replicated, and synchronized across multiple sites, institutions, or geographies. Unlike a traditional centralized database, there is no central administrator.</p>\n            <p>Each participant (node) in the network maintains an identical copy of the ledger. Changes to the ledger are reflected across all copies almost simultaneously, and the security and accuracy of the ledger is maintained through cryptographic keys and signatures.</p>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>No single point of failure</li>\n                <li>Increased transparency and trust</li>\n                <li>Reduced reconciliation costs</li>\n                <li>Improved security through cryptography</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 2
      },
      {
        "title": "What is a block in blockchain?",
        "answer": "\n            <p>A <strong>block</strong> is the fundamental unit of a blockchain. It's a data structure that contains a collection of transactions bundled together.</p>\n            <strong>Each block typically contains:</strong>\n            <ul>\n                <li><strong>Block Header:</strong> Contains metadata including previous block hash, timestamp, Merkle root, and nonce</li>\n                <li><strong>Block Body:</strong> Contains the list of transactions</li>\n                <li><strong>Block Hash:</strong> A unique identifier for the block</li>\n            </ul>\n            <p>Blocks are linked together through cryptographic hashes, forming a chain. Each block references the hash of the previous block, creating an immutable sequence.</p>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 3
      },
      {
        "title": "What is a hash and how is it used in blockchain?",
        "answer": "\n            <p>A <strong>hash</strong> is a fixed-size output produced by a cryptographic hash function from an input of any size. It's like a digital fingerprint of data.</p>\n            <strong>Properties of cryptographic hashes:</strong>\n            <ul>\n                <li><strong>Deterministic:</strong> Same input always produces same output</li>\n                <li><strong>One-way:</strong> Cannot reverse-engineer the input from the output</li>\n                <li><strong>Collision-resistant:</strong> Extremely difficult to find two inputs that produce the same hash</li>\n                <li><strong>Avalanche effect:</strong> Small change in input produces drastically different output</li>\n            </ul>\n            <strong>Uses in blockchain:</strong>\n            <ul>\n                <li>Linking blocks together</li>\n                <li>Creating transaction IDs</li>\n                <li>Verifying data integrity</li>\n                <li>Mining (Proof of Work)</li>\n            </ul>\n            <p>Common hash algorithms: SHA-256 (Bitcoin), Keccak-256 (Ethereum)</p>\n        ",
        "tags": [
          "fundamentals",
          "cryptography",
          "difficulty-basic"
        ],
        "order": 4
      },
      {
        "title": "What is the genesis block?",
        "answer": "\n            <p>The <strong>genesis block</strong> is the first block in a blockchain, also known as Block 0. It's the foundation upon which all subsequent blocks are built.</p>\n            <strong>Key characteristics:</strong>\n            <ul>\n                <li>It's hardcoded into the blockchain software</li>\n                <li>Has no reference to a previous block (previous hash is typically all zeros)</li>\n                <li>Often contains a special message or timestamp</li>\n                <li>Cannot be altered</li>\n            </ul>\n            <p><strong>Famous example:</strong> Bitcoin's genesis block was mined by Satoshi Nakamoto on January 3, 2009, and contains the text: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\"</p>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 5
      },
      {
        "title": "What is block height?",
        "answer": "\n            <p><strong>Block height</strong> refers to the number of blocks in the chain between the genesis block and the current block. It's essentially a sequential number assigned to each block.</p>\n            <ul>\n                <li>Genesis block has height 0 (or 1 in some blockchains)</li>\n                <li>Each new block increments the height by 1</li>\n                <li>Block height can be used to identify specific blocks</li>\n                <li>It indicates how many blocks have been confirmed on the network</li>\n            </ul>\n            <p>Block height is also used to schedule network upgrades (hard forks) that activate at a specific block height.</p>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 6
      },
      {
        "title": "What is block time?",
        "answer": "\n            <p><strong>Block time</strong> is the average time it takes to add a new block to the blockchain. Different blockchains have different target block times.</p>\n            <strong>Examples of block times:</strong>\n            <ul>\n                <li><strong>Bitcoin:</strong> ~10 minutes</li>\n                <li><strong>Ethereum:</strong> ~12 seconds (post-merge)</li>\n                <li><strong>Solana:</strong> ~400 milliseconds</li>\n                <li><strong>Polygon:</strong> ~2 seconds</li>\n            </ul>\n            <p>Shorter block times mean faster transaction confirmations but may lead to more orphaned blocks. Longer block times provide more security but slower transactions.</p>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 7
      },
      {
        "title": "What is a blockchain node?",
        "answer": "\n            <p>A <strong>node</strong> is any computer that connects to the blockchain network and helps maintain it. Nodes are essential for the decentralized nature of blockchain.</p>\n            <strong>Types of nodes:</strong>\n            <ul>\n                <li><strong>Full Node:</strong> Stores complete blockchain, validates all transactions</li>\n                <li><strong>Light Node (SPV):</strong> Stores only block headers, relies on full nodes</li>\n                <li><strong>Archive Node:</strong> Stores full history plus all historical states</li>\n                <li><strong>Mining/Validator Node:</strong> Participates in creating new blocks</li>\n            </ul>\n            <strong>Node responsibilities:</strong>\n            <ul>\n                <li>Validate transactions and blocks</li>\n                <li>Store blockchain data</li>\n                <li>Relay transactions to other nodes</li>\n                <li>Enforce network consensus rules</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 8
      },
      {
        "title": "What is the difference between a full node and a light node?",
        "answer": "\n            <p>Both full nodes and light nodes participate in the blockchain network, but they differ in capabilities and resource requirements.</p>\n            <strong>Full Node:</strong>\n            <ul>\n                <li>Downloads and stores the entire blockchain</li>\n                <li>Independently validates all transactions and blocks</li>\n                <li>Enforces all consensus rules</li>\n                <li>Provides maximum security and trustlessness</li>\n                <li>Requires significant storage (Bitcoin: ~500GB+, Ethereum: ~1TB+)</li>\n            </ul>\n            <strong>Light Node (SPV):</strong>\n            <ul>\n                <li>Only downloads block headers</li>\n                <li>Relies on full nodes for transaction data</li>\n                <li>Cannot fully validate transactions independently</li>\n                <li>Suitable for mobile wallets</li>\n                <li>Requires minimal storage (few MBs)</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 9
      },
      {
        "title": "What is blockchain immutability?",
        "answer": "\n            <p><strong>Immutability</strong> means that once data is recorded on the blockchain, it cannot be altered, deleted, or tampered with. This is one of the core properties that makes blockchain trustworthy.</p>\n            <strong>How immutability is achieved:</strong>\n            <ul>\n                <li><strong>Cryptographic hashing:</strong> Each block contains the hash of the previous block</li>\n                <li><strong>Distributed storage:</strong> The blockchain is stored across thousands of nodes</li>\n                <li><strong>Consensus mechanisms:</strong> Any changes must be agreed upon by the network majority</li>\n            </ul>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Creates a permanent, auditable record</li>\n                <li>Prevents fraud and tampering</li>\n                <li>Builds trust without intermediaries</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 10
      },
      {
        "title": "What is blockchain transparency?",
        "answer": "\n            <p><strong>Transparency</strong> in blockchain refers to the ability for anyone to view and verify all transactions and data stored on the blockchain.</p>\n            <strong>Types of transparency:</strong>\n            <ul>\n                <li><strong>Public blockchains:</strong> Anyone can view all transactions (Bitcoin, Ethereum)</li>\n                <li><strong>Private blockchains:</strong> Only authorized participants can view transactions</li>\n                <li><strong>Consortium blockchains:</strong> Limited transparency among consortium members</li>\n            </ul>\n            <p><strong>Note:</strong> While transactions are transparent, user identities are typically pseudonymous (represented by addresses rather than real names).</p>\n            <p>Blockchain explorers like Etherscan allow anyone to browse and analyze blockchain data.</p>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 11
      },
      {
        "title": "What is a Merkle tree?",
        "answer": "\n            <p>A <strong>Merkle tree</strong> (or hash tree) is a data structure used to efficiently verify the integrity of data in a blockchain.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Transaction data is hashed individually</li>\n                <li>Pairs of hashes are combined and hashed again</li>\n                <li>Process repeats until a single \"Merkle root\" is produced</li>\n                <li>The Merkle root is stored in the block header</li>\n            </ul>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Efficient verification of transaction inclusion</li>\n                <li>Light clients can verify without full blockchain</li>\n                <li>Quick detection of any data tampering</li>\n                <li>Space-efficient proofs</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "cryptography",
          "difficulty-basic"
        ],
        "order": 12
      },
      {
        "title": "What is a blockchain fork?",
        "answer": "\n            <p>A <strong>fork</strong> occurs when a blockchain diverges into two potential paths. This can happen naturally or be intentionally created.</p>\n            <strong>Types of forks:</strong>\n            <ul>\n                <li><strong>Temporary fork:</strong> Natural occurrence when two miners find blocks simultaneously; resolves itself</li>\n                <li><strong>Soft fork:</strong> Backward-compatible upgrade; old nodes still recognize new blocks</li>\n                <li><strong>Hard fork:</strong> Non-backward-compatible change; creates a permanent split</li>\n            </ul>\n            <strong>Famous hard forks:</strong>\n            <ul>\n                <li>Ethereum â†’ Ethereum Classic (2016, after DAO hack)</li>\n                <li>Bitcoin â†’ Bitcoin Cash (2017, block size debate)</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 13
      },
      {
        "title": "What is the difference between hard fork and soft fork?",
        "answer": "\n            <p><strong>Hard forks</strong> and <strong>soft forks</strong> are two types of protocol upgrades with different compatibility implications.</p>\n            <table>\n                <tr><th>Aspect</th><th>Hard Fork</th><th>Soft Fork</th></tr>\n                <tr><td>Compatibility</td><td>Not backward-compatible</td><td>Backward-compatible</td></tr>\n                <tr><td>Old nodes</td><td>Must upgrade or split off</td><td>Can still participate</td></tr>\n                <tr><td>Chain split</td><td>Creates two chains if not unanimous</td><td>Single chain maintained</td></tr>\n                <tr><td>Rule changes</td><td>Can add or remove rules</td><td>Can only tighten rules</td></tr>\n            </table>\n            <strong>Soft fork example:</strong> SegWit (Bitcoin) - tightened block structure rules\n            <strong>Hard fork example:</strong> London upgrade (Ethereum) - added EIP-1559 fee mechanism\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 14
      },
      {
        "title": "What is a blockchain explorer?",
        "answer": "\n            <p>A <strong>blockchain explorer</strong> is a web-based tool that allows users to search and browse blockchain data.</p>\n            <strong>What you can find:</strong>\n            <ul>\n                <li>Transaction details (sender, receiver, amount, status)</li>\n                <li>Block information (height, timestamp, transactions)</li>\n                <li>Address balances and history</li>\n                <li>Smart contract code and interactions</li>\n                <li>Network statistics (gas prices, TPS)</li>\n            </ul>\n            <strong>Popular explorers:</strong>\n            <ul>\n                <li><strong>Etherscan:</strong> Ethereum and EVM chains</li>\n                <li><strong>Blockchain.com:</strong> Bitcoin</li>\n                <li><strong>Solscan:</strong> Solana</li>\n                <li><strong>Polygonscan:</strong> Polygon</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "tools",
          "difficulty-basic"
        ],
        "order": 15
      },
      {
        "title": "What is a blockchain network?",
        "answer": "\n            <p>A <strong>blockchain network</strong> is the collection of nodes that maintain and operate a blockchain protocol together.</p>\n            <strong>Network types:</strong>\n            <ul>\n                <li><strong>Mainnet:</strong> The primary, production network with real value</li>\n                <li><strong>Testnet:</strong> Test networks with no real value (Sepolia, Goerli)</li>\n                <li><strong>Devnet:</strong> Local development networks</li>\n            </ul>\n            <strong>Network components:</strong>\n            <ul>\n                <li>Nodes (full, light, validator)</li>\n                <li>Consensus mechanism</li>\n                <li>Network protocol (gossip, peer discovery)</li>\n                <li>Native token for fees/staking</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 16
      },
      {
        "title": "What is peer-to-peer (P2P) networking?",
        "answer": "\n            <p><strong>Peer-to-peer (P2P)</strong> networking is a distributed architecture where participants (peers) share resources directly without a central server.</p>\n            <strong>In blockchain context:</strong>\n            <ul>\n                <li>Nodes communicate directly with each other</li>\n                <li>Transactions are broadcast to all peers</li>\n                <li>No central authority controls communication</li>\n                <li>Network remains functional if some nodes go offline</li>\n            </ul>\n            <strong>Key protocols:</strong>\n            <ul>\n                <li><strong>Gossip protocol:</strong> Nodes share information with random peers</li>\n                <li><strong>DHT (Distributed Hash Table):</strong> Distributed data storage</li>\n                <li><strong>libp2p:</strong> Modular P2P networking (used by Ethereum)</li>\n            </ul>\n        ",
        "tags": [
          "fundamentals",
          "difficulty-basic"
        ],
        "order": 17
      },
      {
        "title": "What is a consensus mechanism?",
        "answer": "\n            <p>A <strong>consensus mechanism</strong> is a method used by blockchain networks to achieve agreement among nodes on the current state of the blockchain.</p>\n            <strong>Why needed:</strong>\n            <ul>\n                <li>No central authority to validate</li>\n                <li>Nodes must agree on transaction order</li>\n                <li>Prevents double-spending</li>\n                <li>Ensures network security</li>\n            </ul>\n            <strong>Popular mechanisms:</strong>\n            <ul>\n                <li><strong>Proof of Work:</strong> Bitcoin, Litecoin</li>\n                <li><strong>Proof of Stake:</strong> Ethereum, Cardano</li>\n                <li><strong>Delegated PoS:</strong> EOS, TRON</li>\n                <li><strong>Proof of Authority:</strong> Private blockchains</li>\n            </ul>\n        ",
        "tags": [
          "consensus",
          "difficulty-basic"
        ],
        "order": 18
      },
      {
        "title": "What is Proof of Work (PoW)?",
        "answer": "\n            <p><strong>Proof of Work</strong> is a consensus mechanism where miners compete to solve complex mathematical puzzles.</p>\n            <strong>How it works:</strong>\n            <ol>\n                <li>Miners collect pending transactions</li>\n                <li>Repeatedly hash block data with different nonces</li>\n                <li>Find hash below target difficulty</li>\n                <li>First to succeed broadcasts the block</li>\n                <li>Receives block reward and fees</li>\n            </ol>\n            <strong>Advantages:</strong> Battle-tested security, highly decentralized\n            <strong>Disadvantages:</strong> High energy consumption, specialized hardware needed\n        ",
        "tags": [
          "consensus",
          "mining",
          "difficulty-basic"
        ],
        "order": 19
      },
      {
        "title": "What is Proof of Stake (PoS)?",
        "answer": "\n            <p><strong>Proof of Stake</strong> is a consensus mechanism where validators are chosen based on staked cryptocurrency.</p>\n            <strong>How it works:</strong>\n            <ol>\n                <li>Validators stake their coins</li>\n                <li>Algorithm selects validators based on stake</li>\n                <li>Selected validator proposes new block</li>\n                <li>Other validators attest to validity</li>\n                <li>Validators earn rewards</li>\n            </ol>\n            <strong>Advantages:</strong> Energy efficient (99.9% less than PoW), no specialized hardware\n            <strong>Disadvantages:</strong> Rich get richer concerns, less battle-tested\n        ",
        "tags": [
          "consensus",
          "staking",
          "difficulty-basic"
        ],
        "order": 20
      },
      {
        "title": "What is mining in blockchain?",
        "answer": "\n            <p><strong>Mining</strong> is the process of using computational power to validate transactions and add new blocks in PoW blockchains.</p>\n            <strong>Mining process:</strong>\n            <ol>\n                <li>Collect transactions from mempool</li>\n                <li>Create candidate block</li>\n                <li>Compute hashes with different nonces</li>\n                <li>Find valid hash meeting difficulty</li>\n                <li>Broadcast block, receive rewards</li>\n            </ol>\n            <strong>Requirements:</strong> Specialized hardware (ASICs/GPUs), electricity, mining software\n        ",
        "tags": [
          "consensus",
          "mining",
          "difficulty-basic"
        ],
        "order": 21
      },
      {
        "title": "What is staking?",
        "answer": "\n            <p><strong>Staking</strong> is locking up cryptocurrency to participate in network validation and earn rewards in PoS blockchains.</p>\n            <strong>How to stake:</strong>\n            <ul>\n                <li><strong>Solo staking:</strong> Run your own validator (requires 32 ETH for Ethereum)</li>\n                <li><strong>Pooled staking:</strong> Join a staking pool</li>\n                <li><strong>Liquid staking:</strong> Stake via protocols like Lido (receive stETH)</li>\n                <li><strong>Exchange staking:</strong> Stake on centralized exchanges</li>\n            </ul>\n            <strong>Rewards:</strong> Typically 4-15% APY depending on network\n        ",
        "tags": [
          "consensus",
          "staking",
          "difficulty-basic"
        ],
        "order": 22
      },
      {
        "title": "What is a validator?",
        "answer": "\n            <p>A <strong>validator</strong> is a node in a PoS network that validates transactions and proposes new blocks.</p>\n            <strong>Responsibilities:</strong>\n            <ul>\n                <li>Validate transactions</li>\n                <li>Propose new blocks (when selected)</li>\n                <li>Attest to other validators' blocks</li>\n                <li>Maintain network security</li>\n            </ul>\n            <strong>Requirements (Ethereum):</strong>\n            <ul>\n                <li>32 ETH stake</li>\n                <li>Validator software running 24/7</li>\n                <li>Reliable internet connection</li>\n            </ul>\n            <strong>Slashing:</strong> Validators can lose stake for malicious or negligent behavior\n        ",
        "tags": [
          "consensus",
          "staking",
          "difficulty-basic"
        ],
        "order": 23
      },
      {
        "title": "What is the 51% attack?",
        "answer": "\n            <p>A <strong>51% attack</strong> occurs when an entity controls more than half of the network's mining/validation power.</p>\n            <strong>Potential attacks:</strong>\n            <ul>\n                <li>Double-spending</li>\n                <li>Blocking transactions</li>\n                <li>Reversing recent transactions</li>\n                <li>Preventing other miners from finding blocks</li>\n            </ul>\n            <strong>What they CANNOT do:</strong>\n            <ul>\n                <li>Steal coins from wallets</li>\n                <li>Create new coins (beyond block rewards)</li>\n                <li>Change protocol rules</li>\n            </ul>\n            <strong>Protection:</strong> Higher network hashrate/stake makes attacks more expensive\n        ",
        "tags": [
          "consensus",
          "security",
          "difficulty-basic"
        ],
        "order": 24
      },
      {
        "title": "What is finality in blockchain?",
        "answer": "\n            <p><strong>Finality</strong> is the point at which a transaction becomes irreversible and cannot be undone.</p>\n            <strong>Types of finality:</strong>\n            <ul>\n                <li><strong>Probabilistic:</strong> Certainty increases with confirmations (Bitcoin, PoW)</li>\n                <li><strong>Absolute:</strong> Transaction final once confirmed (BFT-based systems)</li>\n                <li><strong>Economic:</strong> Reversal would cost more than it's worth (Ethereum PoS)</li>\n            </ul>\n            <strong>Examples:</strong>\n            <ul>\n                <li>Bitcoin: ~6 confirmations (~1 hour)</li>\n                <li>Ethereum PoS: ~15 minutes for finality</li>\n            </ul>\n        ",
        "tags": [
          "consensus",
          "difficulty-basic"
        ],
        "order": 25
      },
      {
        "title": "What is slashing in Proof of Stake?",
        "answer": "\n            <p><strong>Slashing</strong> is a penalty mechanism where validators lose a portion of their stake for malicious or negligent behavior.</p>\n            <strong>Slashable offenses:</strong>\n            <ul>\n                <li><strong>Double signing:</strong> Signing two different blocks at the same height</li>\n                <li><strong>Surround voting:</strong> Creating conflicting attestations</li>\n                <li><strong>Downtime:</strong> Being offline for too long (in some networks)</li>\n            </ul>\n            <strong>Purpose:</strong>\n            <ul>\n                <li>Discourages malicious behavior</li>\n                <li>Ensures validators stay online</li>\n                <li>Provides economic security</li>\n            </ul>\n        ",
        "tags": [
          "consensus",
          "staking",
          "difficulty-basic"
        ],
        "order": 26
      },
      {
        "title": "What is Delegated Proof of Stake (DPoS)?",
        "answer": "\n            <p><strong>Delegated Proof of Stake</strong> is a variant where token holders vote to elect a small number of delegates who validate blocks.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Token holders vote for delegates</li>\n                <li>Top N delegates become validators</li>\n                <li>Delegates take turns producing blocks</li>\n                <li>Delegates share rewards with voters</li>\n            </ul>\n            <strong>Examples:</strong> EOS, TRON, Lisk\n            <strong>Pros:</strong> Fast, scalable, energy efficient\n            <strong>Cons:</strong> More centralized, potential for cartels\n        ",
        "tags": [
          "consensus",
          "difficulty-basic"
        ],
        "order": 27
      },
      {
        "title": "What is Proof of Authority (PoA)?",
        "answer": "\n            <p><strong>Proof of Authority</strong> is a consensus mechanism where approved accounts (authorities) validate transactions.</p>\n            <strong>Characteristics:</strong>\n            <ul>\n                <li>Validators are known, pre-approved entities</li>\n                <li>Reputation at stake instead of money</li>\n                <li>Very fast and efficient</li>\n                <li>Used mainly for private/consortium chains</li>\n            </ul>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Enterprise blockchains</li>\n                <li>Testnets (Sepolia, Goerli)</li>\n                <li>Supply chain networks</li>\n            </ul>\n        ",
        "tags": [
          "consensus",
          "difficulty-basic"
        ],
        "order": 28
      },
      {
        "title": "What is difficulty adjustment?",
        "answer": "\n            <p><strong>Difficulty adjustment</strong> is a mechanism that adjusts mining difficulty to maintain consistent block times.</p>\n            <strong>Bitcoin's approach:</strong>\n            <ul>\n                <li>Adjusts every 2,016 blocks (~2 weeks)</li>\n                <li>Target: 10 minutes per block</li>\n                <li>Increases if blocks are too fast</li>\n                <li>Decreases if blocks are too slow</li>\n            </ul>\n            <strong>Purpose:</strong>\n            <ul>\n                <li>Consistent block production</li>\n                <li>Adapts to changing hash power</li>\n                <li>Maintains predictable issuance</li>\n            </ul>\n        ",
        "tags": [
          "consensus",
          "mining",
          "difficulty-basic"
        ],
        "order": 29
      },
      {
        "title": "What is a mining pool?",
        "answer": "\n            <p>A <strong>mining pool</strong> is a group of miners who combine their computational power to increase chances of finding blocks.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Miners contribute hash power to pool</li>\n                <li>Pool finds blocks more frequently</li>\n                <li>Rewards distributed based on contribution</li>\n                <li>More stable income for individual miners</li>\n            </ul>\n            <strong>Popular pools:</strong> Foundry, AntPool, F2Pool, Poolin\n            <strong>Concerns:</strong> Pool concentration can threaten decentralization\n        ",
        "tags": [
          "consensus",
          "mining",
          "difficulty-basic"
        ],
        "order": 30
      },
      {
        "title": "What is block reward?",
        "answer": "\n            <p><strong>Block reward</strong> is the cryptocurrency given to miners/validators for creating new blocks.</p>\n            <strong>Bitcoin block rewards:</strong>\n            <ul>\n                <li>Started at 50 BTC (2009)</li>\n                <li>Halves every 210,000 blocks (~4 years)</li>\n                <li>Currently 6.25 BTC (2020-2024)</li>\n                <li>Next halving: 3.125 BTC</li>\n            </ul>\n            <strong>Ethereum (PoS):</strong>\n            <ul>\n                <li>No fixed block reward</li>\n                <li>Rewards based on stake and attestations</li>\n                <li>Issuance reduced ~90% post-merge</li>\n            </ul>\n        ",
        "tags": [
          "consensus",
          "mining",
          "difficulty-basic"
        ],
        "order": 31
      },
      {
        "title": "What is the Bitcoin halving?",
        "answer": "\n            <p>The <strong>Bitcoin halving</strong> is an event that cuts block rewards in half, occurring every 210,000 blocks (~4 years).</p>\n            <strong>Halving history:</strong>\n            <ul>\n                <li>2009: 50 BTC</li>\n                <li>2012: 25 BTC</li>\n                <li>2016: 12.5 BTC</li>\n                <li>2020: 6.25 BTC</li>\n                <li>2024: 3.125 BTC</li>\n            </ul>\n            <strong>Significance:</strong>\n            <ul>\n                <li>Controls inflation/supply</li>\n                <li>Ensures 21 million max supply</li>\n                <li>Historically preceded price increases</li>\n            </ul>\n        ",
        "tags": [
          "consensus",
          "bitcoin",
          "difficulty-basic"
        ],
        "order": 32
      },
      {
        "title": "What is cryptocurrency?",
        "answer": "\n            <p>A <strong>cryptocurrency</strong> is a digital or virtual currency that uses cryptography for security and operates on a decentralized network, typically a blockchain.</p>\n            <strong>Key characteristics:</strong>\n            <ul>\n                <li><strong>Digital:</strong> Exists only in electronic form</li>\n                <li><strong>Decentralized:</strong> Not controlled by any government or central bank</li>\n                <li><strong>Cryptographically secured:</strong> Uses encryption to secure transactions</li>\n                <li><strong>Peer-to-peer:</strong> Transactions occur directly between users</li>\n                <li><strong>Limited supply:</strong> Many cryptocurrencies have a capped supply</li>\n            </ul>\n            <strong>Common use cases:</strong>\n            <ul>\n                <li>Digital payments and store of value</li>\n                <li>Powering decentralized applications</li>\n                <li>Cross-border transactions</li>\n                <li>DeFi (Decentralized Finance)</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "difficulty-basic"
        ],
        "order": 33
      },
      {
        "title": "What is Bitcoin?",
        "answer": "\n            <p><strong>Bitcoin (BTC)</strong> is the first and most well-known cryptocurrency, created in 2009 by an anonymous person or group using the pseudonym Satoshi Nakamoto.</p>\n            <strong>Key features:</strong>\n            <ul>\n                <li><strong>Limited supply:</strong> Maximum of 21 million BTC will ever exist</li>\n                <li><strong>Proof of Work:</strong> Uses mining to secure the network</li>\n                <li><strong>Halving:</strong> Block rewards are cut in half every ~4 years</li>\n                <li><strong>Decentralized:</strong> No central authority controls it</li>\n                <li><strong>Block time:</strong> ~10 minutes per block</li>\n            </ul>\n            <p>Bitcoin is often called \"digital gold\" due to its scarcity and store of value properties.</p>\n        ",
        "tags": [
          "cryptocurrency",
          "bitcoin",
          "difficulty-basic"
        ],
        "order": 34
      },
      {
        "title": "What is Ethereum?",
        "answer": "\n            <p><strong>Ethereum</strong> is a decentralized, open-source blockchain platform that enables the creation of smart contracts and decentralized applications (dApps). Its native cryptocurrency is Ether (ETH).</p>\n            <strong>Key features:</strong>\n            <ul>\n                <li><strong>Smart Contracts:</strong> Self-executing contracts with code that runs on the blockchain</li>\n                <li><strong>Ethereum Virtual Machine (EVM):</strong> Runtime environment for smart contracts</li>\n                <li><strong>Proof of Stake:</strong> Transitioned from PoW in \"The Merge\" (September 2022)</li>\n                <li><strong>Programmable blockchain:</strong> Developers can build applications on it</li>\n            </ul>\n            <strong>Ethereum enables:</strong>\n            <ul>\n                <li>DeFi, NFTs, DAOs, and token creation (ERC-20, ERC-721)</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "ethereum",
          "difficulty-basic"
        ],
        "order": 35
      },
      {
        "title": "What is the difference between Bitcoin and Ethereum?",
        "answer": "\n            <p>While both are popular cryptocurrencies, Bitcoin and Ethereum serve different purposes.</p>\n            <table>\n                <tr><th>Aspect</th><th>Bitcoin</th><th>Ethereum</th></tr>\n                <tr><td>Purpose</td><td>Digital currency / Store of value</td><td>Platform for dApps and smart contracts</td></tr>\n                <tr><td>Launched</td><td>2009</td><td>2015</td></tr>\n                <tr><td>Creator</td><td>Satoshi Nakamoto</td><td>Vitalik Buterin</td></tr>\n                <tr><td>Consensus</td><td>Proof of Work</td><td>Proof of Stake</td></tr>\n                <tr><td>Supply</td><td>21 million (capped)</td><td>No hard cap</td></tr>\n                <tr><td>Block time</td><td>~10 minutes</td><td>~12 seconds</td></tr>\n                <tr><td>Smart contracts</td><td>Limited</td><td>Fully programmable</td></tr>\n            </table>\n        ",
        "tags": [
          "cryptocurrency",
          "bitcoin",
          "ethereum",
          "difficulty-basic"
        ],
        "order": 36
      },
      {
        "title": "What is a satoshi?",
        "answer": "\n            <p>A <strong>satoshi</strong> (sat) is the smallest unit of Bitcoin, named after Bitcoin's creator Satoshi Nakamoto.</p>\n            <strong>Denomination:</strong>\n            <ul>\n                <li>1 Bitcoin (BTC) = 100,000,000 satoshis</li>\n                <li>1 satoshi = 0.00000001 BTC</li>\n            </ul>\n            <p>Satoshis are useful for expressing small amounts of Bitcoin, especially as Bitcoin's price increases. Many prefer to price things in sats rather than fractions of BTC.</p>\n        ",
        "tags": [
          "cryptocurrency",
          "bitcoin",
          "difficulty-basic"
        ],
        "order": 37
      },
      {
        "title": "What are wei and gwei in Ethereum?",
        "answer": "\n            <p><strong>Wei</strong> and <strong>Gwei</strong> are denominations of Ether (ETH).</p>\n            <strong>Ethereum denominations:</strong>\n            <ul>\n                <li><strong>Wei:</strong> The smallest unit (1 ETH = 10^18 wei)</li>\n                <li><strong>Gwei:</strong> 1 billion wei (1 ETH = 10^9 gwei)</li>\n            </ul>\n            <pre><code>1 ETH = 1,000,000,000 Gwei = 1,000,000,000,000,000,000 Wei</code></pre>\n            <strong>Common uses:</strong>\n            <ul>\n                <li><strong>Wei:</strong> Used in smart contract calculations for precision</li>\n                <li><strong>Gwei:</strong> Used to express gas prices (e.g., \"Gas price: 30 Gwei\")</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "ethereum",
          "gas",
          "difficulty-basic"
        ],
        "order": 38
      },
      {
        "title": "What is market capitalization in crypto?",
        "answer": "\n            <p><strong>Market capitalization</strong> (market cap) is the total value of a cryptocurrency.</p>\n            <strong>Formula:</strong>\n            <pre><code>Market Cap = Current Price Ã— Circulating Supply</code></pre>\n            <strong>Types:</strong>\n            <ul>\n                <li><strong>Circulating Market Cap:</strong> Price Ã— coins currently in circulation</li>\n                <li><strong>Fully Diluted Market Cap:</strong> Price Ã— maximum supply</li>\n            </ul>\n            <strong>Categories:</strong>\n            <ul>\n                <li><strong>Large cap:</strong> > $10 billion</li>\n                <li><strong>Mid cap:</strong> $1-10 billion</li>\n                <li><strong>Small cap:</strong> $100 million - $1 billion</li>\n                <li><strong>Micro cap:</strong> < $100 million</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "trading",
          "difficulty-basic"
        ],
        "order": 39
      },
      {
        "title": "What is a stablecoin?",
        "answer": "\n            <p>A <strong>stablecoin</strong> is a cryptocurrency designed to maintain a stable value, typically pegged to a fiat currency like USD (1:1).</p>\n            <strong>Types of stablecoins:</strong>\n            <ul>\n                <li><strong>Fiat-backed:</strong> Backed by reserves (USDC, USDT)</li>\n                <li><strong>Crypto-backed:</strong> Over-collateralized by crypto (DAI)</li>\n                <li><strong>Algorithmic:</strong> Uses algorithms to maintain peg (FRAX)</li>\n                <li><strong>Commodity-backed:</strong> Backed by gold, etc. (PAXG)</li>\n            </ul>\n            <strong>Use cases:</strong> Trading pairs, safe haven, cross-border payments, DeFi\n        ",
        "tags": [
          "cryptocurrency",
          "stablecoin",
          "defi",
          "difficulty-basic"
        ],
        "order": 40
      },
      {
        "title": "What are altcoins?",
        "answer": "\n            <p><strong>Altcoins</strong> (alternative coins) refer to all cryptocurrencies other than Bitcoin.</p>\n            <strong>Categories:</strong>\n            <ul>\n                <li><strong>Platform coins:</strong> ETH, SOL, ADA, AVAX</li>\n                <li><strong>Utility tokens:</strong> LINK, GRT</li>\n                <li><strong>Meme coins:</strong> DOGE, SHIB</li>\n                <li><strong>Privacy coins:</strong> XMR, ZEC</li>\n                <li><strong>Stablecoins:</strong> USDC, DAI</li>\n                <li><strong>Governance tokens:</strong> UNI, AAVE</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "difficulty-basic"
        ],
        "order": 41
      },
      {
        "title": "What is the difference between a token and a coin?",
        "answer": "\n            <p><strong>Coins</strong> and <strong>tokens</strong> have distinct technical meanings.</p>\n            <strong>Coins:</strong>\n            <ul>\n                <li>Native to their own blockchain</li>\n                <li>Used to pay transaction fees</li>\n                <li>Examples: BTC, ETH, SOL</li>\n            </ul>\n            <strong>Tokens:</strong>\n            <ul>\n                <li>Built on existing blockchains using smart contracts</li>\n                <li>Require native coin for gas fees</li>\n                <li>Examples: USDC, UNI, LINK (on Ethereum)</li>\n            </ul>\n            <table>\n                <tr><th>Aspect</th><th>Coin</th><th>Token</th></tr>\n                <tr><td>Blockchain</td><td>Has its own</td><td>Uses existing blockchain</td></tr>\n                <tr><td>Creation</td><td>From scratch</td><td>Smart contract deployment</td></tr>\n            </table>\n        ",
        "tags": [
          "cryptocurrency",
          "tokens",
          "difficulty-basic"
        ],
        "order": 42
      },
      {
        "title": "What is a token burn?",
        "answer": "\n            <p><strong>Token burning</strong> is the permanent removal of tokens from circulation, typically by sending them to an inaccessible address.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Tokens are sent to a \"burn address\" (no private key)</li>\n                <li>These tokens can never be recovered or used</li>\n                <li>Reduces total supply</li>\n            </ul>\n            <strong>Reasons for burning:</strong>\n            <ul>\n                <li>Create deflationary pressure</li>\n                <li>Increase scarcity and potential value</li>\n                <li>Part of tokenomics (EIP-1559 burns ETH)</li>\n                <li>Remove unsold ICO tokens</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "tokens",
          "difficulty-basic"
        ],
        "order": 43
      },
      {
        "title": "What is tokenomics?",
        "answer": "\n            <p><strong>Tokenomics</strong> (token economics) refers to the study of how a cryptocurrency token is designed, distributed, and managed.</p>\n            <strong>Key components:</strong>\n            <ul>\n                <li><strong>Supply:</strong> Total, circulating, max supply</li>\n                <li><strong>Distribution:</strong> How tokens are allocated (team, investors, community)</li>\n                <li><strong>Emission:</strong> How new tokens are created</li>\n                <li><strong>Utility:</strong> What the token is used for</li>\n                <li><strong>Incentives:</strong> Staking rewards, governance rights</li>\n                <li><strong>Vesting:</strong> Lock-up periods for team/investors</li>\n            </ul>\n            <p>Good tokenomics is essential for a project's long-term success.</p>\n        ",
        "tags": [
          "cryptocurrency",
          "tokens",
          "difficulty-basic"
        ],
        "order": 44
      },
      {
        "title": "What is a cryptocurrency exchange?",
        "answer": "\n            <p>A <strong>cryptocurrency exchange</strong> is a platform where users can buy, sell, and trade cryptocurrencies.</p>\n            <strong>Types of exchanges:</strong>\n            <ul>\n                <li><strong>Centralized (CEX):</strong> Coinbase, Binance, Kraken</li>\n                <li><strong>Decentralized (DEX):</strong> Uniswap, SushiSwap, dYdX</li>\n                <li><strong>Hybrid:</strong> Combines features of both</li>\n            </ul>\n            <strong>Exchange services:</strong>\n            <ul>\n                <li>Spot trading (buy/sell at current price)</li>\n                <li>Margin/futures trading</li>\n                <li>Staking services</li>\n                <li>Fiat on/off ramps</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "trading",
          "difficulty-basic"
        ],
        "order": 45
      },
      {
        "title": "What is the difference between CEX and DEX?",
        "answer": "\n            <p><strong>CEX</strong> (Centralized Exchange) and <strong>DEX</strong> (Decentralized Exchange) differ in their architecture and trust models.</p>\n            <table>\n                <tr><th>Aspect</th><th>CEX</th><th>DEX</th></tr>\n                <tr><td>Custody</td><td>Exchange holds funds</td><td>User controls funds</td></tr>\n                <tr><td>KYC</td><td>Usually required</td><td>Not required</td></tr>\n                <tr><td>Speed</td><td>Fast (off-chain)</td><td>Blockchain speed</td></tr>\n                <tr><td>Liquidity</td><td>Generally higher</td><td>Can be fragmented</td></tr>\n                <tr><td>Trust</td><td>Trust the company</td><td>Trust the code</td></tr>\n                <tr><td>Fiat support</td><td>Yes</td><td>No (usually)</td></tr>\n            </table>\n        ",
        "tags": [
          "cryptocurrency",
          "trading",
          "defi",
          "difficulty-basic"
        ],
        "order": 46
      },
      {
        "title": "What is a trading pair?",
        "answer": "\n            <p>A <strong>trading pair</strong> represents two cryptocurrencies that can be exchanged for each other.</p>\n            <strong>Examples:</strong>\n            <ul>\n                <li><strong>BTC/USDT:</strong> Trade Bitcoin for Tether</li>\n                <li><strong>ETH/BTC:</strong> Trade Ethereum for Bitcoin</li>\n                <li><strong>UNI/ETH:</strong> Trade Uniswap token for Ethereum</li>\n            </ul>\n            <strong>Terminology:</strong>\n            <ul>\n                <li><strong>Base currency:</strong> First in pair (what you're buying/selling)</li>\n                <li><strong>Quote currency:</strong> Second in pair (what you're paying with)</li>\n            </ul>\n            <p>BTC/USDT at 50,000 means 1 BTC = 50,000 USDT</p>\n        ",
        "tags": [
          "cryptocurrency",
          "trading",
          "difficulty-basic"
        ],
        "order": 47
      },
      {
        "title": "What is cryptocurrency volatility?",
        "answer": "\n            <p><strong>Volatility</strong> measures how much a cryptocurrency's price fluctuates over time.</p>\n            <strong>Causes of crypto volatility:</strong>\n            <ul>\n                <li>Smaller market cap compared to traditional assets</li>\n                <li>24/7 trading (no market close)</li>\n                <li>Speculative nature</li>\n                <li>Regulatory news and uncertainty</li>\n                <li>Market manipulation (whales)</li>\n                <li>Technological developments</li>\n            </ul>\n            <strong>Managing volatility:</strong>\n            <ul>\n                <li>Dollar-cost averaging (DCA)</li>\n                <li>Diversification</li>\n                <li>Stablecoins for stability</li>\n                <li>Long-term holding (HODLing)</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "trading",
          "difficulty-basic"
        ],
        "order": 48
      },
      {
        "title": "What is HODL?",
        "answer": "\n            <p><strong>HODL</strong> is crypto slang for \"hold\" - the strategy of holding cryptocurrency long-term despite price volatility.</p>\n            <strong>Origin:</strong>\n            <ul>\n                <li>Started as a typo in a 2013 Bitcoin forum post</li>\n                <li>Later backronymed to \"Hold On for Dear Life\"</li>\n            </ul>\n            <strong>HODL philosophy:</strong>\n            <ul>\n                <li>Don't panic sell during dips</li>\n                <li>Believe in long-term value</li>\n                <li>Avoid emotional trading</li>\n                <li>Time in market > timing the market</li>\n            </ul>\n        ",
        "tags": [
          "cryptocurrency",
          "culture",
          "difficulty-basic"
        ],
        "order": 49
      },
      {
        "title": "What is a whale in crypto?",
        "answer": "\n            <p>A <strong>whale</strong> is an individual or entity that holds a large amount of cryptocurrency, enough to potentially influence market prices.</p>\n            <strong>Whale characteristics:</strong>\n            <ul>\n                <li>Hold thousands of BTC or equivalent</li>\n                <li>Can move markets with large trades</li>\n                <li>Often watched by analysts for market signals</li>\n            </ul>\n            <strong>Whale watching:</strong>\n            <ul>\n                <li>Track large wallet movements</li>\n                <li>Monitor exchange deposits/withdrawals</li>\n                <li>Tools: Whale Alert, on-chain analytics</li>\n            </ul>\n            <strong>Impact:</strong> Large whale sales can cause price drops; large buys can cause pumps.\n        ",
        "tags": [
          "cryptocurrency",
          "trading",
          "difficulty-basic"
        ],
        "order": 50
      },
      {
        "title": "What is a blockchain transaction?",
        "answer": "\n            <p>A <strong>blockchain transaction</strong> is a cryptographically signed instruction that transfers value or data on a blockchain network.</p>\n            <strong>Components:</strong>\n            <ul>\n                <li><strong>Sender/Recipient:</strong> The addresses involved</li>\n                <li><strong>Value:</strong> Amount being transferred</li>\n                <li><strong>Data:</strong> Additional data for smart contract calls</li>\n                <li><strong>Gas:</strong> Fee for network processing</li>\n                <li><strong>Nonce:</strong> Transaction counter</li>\n                <li><strong>Signature:</strong> Cryptographic proof of authorization</li>\n            </ul>\n            <strong>Lifecycle:</strong> Created â†’ Broadcast â†’ Mempool â†’ Included in block â†’ Confirmed\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 51
      },
      {
        "title": "What is a transaction hash (txHash)?",
        "answer": "\n            <p>A <strong>transaction hash</strong> (txHash) is a unique identifier for a specific transaction on the blockchain.</p>\n            <strong>Characteristics:</strong>\n            <ul>\n                <li>64 hexadecimal characters (256 bits)</li>\n                <li>Generated by hashing the transaction data</li>\n                <li>Unique for every transaction</li>\n            </ul>\n            <strong>Uses:</strong>\n            <ul>\n                <li>Look up transaction details on block explorers</li>\n                <li>Verify transaction status</li>\n                <li>Provide proof of payment</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 52
      },
      {
        "title": "What is gas in Ethereum?",
        "answer": "\n            <p><strong>Gas</strong> is the unit measuring computational effort required on Ethereum. It's like fuel for the EVM.</p>\n            <strong>Why gas exists:</strong>\n            <ul>\n                <li>Prevents spam and infinite loops</li>\n                <li>Compensates validators</li>\n                <li>Allocates network resources fairly</li>\n            </ul>\n            <strong>Key concepts:</strong>\n            <ul>\n                <li><strong>Gas Units:</strong> Amount of computation</li>\n                <li><strong>Gas Price:</strong> Cost per unit (Gwei)</li>\n                <li><strong>Gas Limit:</strong> Maximum gas willing to use</li>\n                <li><strong>Fee = Gas Used Ã— Gas Price</strong></li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "ethereum",
          "gas",
          "difficulty-basic"
        ],
        "order": 53
      },
      {
        "title": "What is gas price?",
        "answer": "\n            <p><strong>Gas price</strong> is the amount of ETH per unit of gas, measured in Gwei.</p>\n            <strong>Post EIP-1559:</strong>\n            <ul>\n                <li><strong>Base Fee:</strong> Minimum price, burned</li>\n                <li><strong>Priority Fee (Tip):</strong> Optional extra to validators</li>\n                <li><strong>Max Fee:</strong> Maximum willing to pay</li>\n            </ul>\n            <strong>Typical prices:</strong>\n            <ul>\n                <li>Low: 10-20 Gwei</li>\n                <li>Normal: 20-50 Gwei</li>\n                <li>High demand: 50-200+ Gwei</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "ethereum",
          "gas",
          "difficulty-basic"
        ],
        "order": 54
      },
      {
        "title": "What is gas limit?",
        "answer": "\n            <p><strong>Gas limit</strong> is the maximum gas you're willing to spend on a transaction.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Sets maximum gas units for transaction</li>\n                <li>Unused gas is refunded</li>\n                <li>If too low, transaction fails (gas still consumed)</li>\n            </ul>\n            <strong>Common gas limits:</strong>\n            <ul>\n                <li>ETH transfer: 21,000</li>\n                <li>Token transfers: 65,000-100,000</li>\n                <li>Smart contract interactions: 100,000-500,000+</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "ethereum",
          "gas",
          "difficulty-basic"
        ],
        "order": 55
      },
      {
        "title": "What is a nonce in blockchain?",
        "answer": "\n            <p>In Ethereum, a <strong>nonce</strong> is a counter tracking the number of transactions sent from an account.</p>\n            <strong>Purposes:</strong>\n            <ul>\n                <li>Prevents replay attacks</li>\n                <li>Ensures transactions are processed in order</li>\n                <li>Allows replacing pending transactions</li>\n            </ul>\n            <strong>How it works:</strong>\n            <ul>\n                <li>First transaction has nonce 0</li>\n                <li>Each transaction increments by 1</li>\n                <li>Transactions must be mined in nonce order</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 56
      },
      {
        "title": "What is transaction confirmation?",
        "answer": "\n            <p><strong>Transaction confirmation</strong> occurs when a transaction is included in a block. More confirmations mean higher certainty.</p>\n            <strong>Recommended confirmations:</strong>\n            <ul>\n                <li><strong>Bitcoin:</strong> 6 confirmations (~1 hour)</li>\n                <li><strong>Ethereum:</strong> 12-20 confirmations (~3-5 minutes)</li>\n            </ul>\n            <strong>Why multiple confirmations matter:</strong>\n            <ul>\n                <li>Protects against chain reorganizations</li>\n                <li>Prevents double-spending attacks</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 57
      },
      {
        "title": "What is the mempool?",
        "answer": "\n            <p>The <strong>mempool</strong> (memory pool) is a waiting area for unconfirmed transactions before they're added to a block.</p>\n            <strong>How it works:</strong>\n            <ol>\n                <li>User broadcasts transaction</li>\n                <li>Transaction validated by nodes</li>\n                <li>Valid transactions enter mempool</li>\n                <li>Validators select transactions (usually highest fees first)</li>\n                <li>Selected transactions included in blocks</li>\n            </ol>\n            <strong>Key points:</strong>\n            <ul>\n                <li>Each node has its own mempool</li>\n                <li>Higher gas = higher priority</li>\n                <li>Front-running bots watch the mempool</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 58
      },
      {
        "title": "What are transaction fees?",
        "answer": "\n            <p><strong>Transaction fees</strong> are payments to validators/miners for processing transactions.</p>\n            <strong>Fee structures:</strong>\n            <ul>\n                <li><strong>Ethereum:</strong> Gas Ã— Gas Price</li>\n                <li><strong>Bitcoin:</strong> Based on transaction size</li>\n                <li><strong>Solana:</strong> Fixed base fee (very low)</li>\n            </ul>\n            <strong>Fee comparison (approximate):</strong>\n            <ul>\n                <li>Ethereum L1: $1-50+</li>\n                <li>Bitcoin: $1-20+</li>\n                <li>Arbitrum/Optimism: $0.10-1</li>\n                <li>Solana: $0.00025</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 59
      },
      {
        "title": "What is a failed/reverted transaction?",
        "answer": "\n            <p>A <strong>failed/reverted</strong> transaction was processed but didn't complete its intended action.</p>\n            <strong>Common reasons:</strong>\n            <ul>\n                <li><strong>Out of gas:</strong> Gas limit too low</li>\n                <li><strong>Reverted by contract:</strong> Condition not met</li>\n                <li><strong>Insufficient balance</strong></li>\n                <li><strong>Slippage too high</strong></li>\n            </ul>\n            <strong>Important:</strong> Gas fees are still charged for failed transactions!\n            <strong>Prevention:</strong> Use adequate gas, simulate transactions, check balances\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 60
      },
      {
        "title": "What is a pending transaction?",
        "answer": "\n            <p>A <strong>pending transaction</strong> has been broadcast to the network but not yet included in a block.</p>\n            <strong>Reasons for pending:</strong>\n            <ul>\n                <li>Low gas price (not attractive to validators)</li>\n                <li>Network congestion</li>\n                <li>Nonce gap (earlier transaction pending)</li>\n            </ul>\n            <strong>Solutions:</strong>\n            <ul>\n                <li><strong>Speed up:</strong> Resend with higher gas price, same nonce</li>\n                <li><strong>Cancel:</strong> Send 0 ETH to yourself with same nonce, higher gas</li>\n                <li><strong>Wait:</strong> Eventually will be processed or dropped</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 61
      },
      {
        "title": "What is EIP-1559?",
        "answer": "\n            <p><strong>EIP-1559</strong> is an Ethereum upgrade that changed how gas fees work (London upgrade, August 2021).</p>\n            <strong>Key changes:</strong>\n            <ul>\n                <li><strong>Base Fee:</strong> Algorithmically determined, gets burned</li>\n                <li><strong>Priority Fee:</strong> Tip to validators</li>\n                <li><strong>Dynamic block size:</strong> Blocks can be up to 2x normal size</li>\n            </ul>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>More predictable fees</li>\n                <li>ETH becomes deflationary (fees burned)</li>\n                <li>Better user experience</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "ethereum",
          "gas",
          "difficulty-basic"
        ],
        "order": 62
      },
      {
        "title": "What is transaction speed-up and cancellation?",
        "answer": "\n            <p>You can <strong>speed up</strong> or <strong>cancel</strong> pending transactions by resubmitting with the same nonce but higher gas.</p>\n            <strong>Speed up:</strong>\n            <ul>\n                <li>Resend exact same transaction</li>\n                <li>Use higher gas price</li>\n                <li>Miners prefer higher-paying transaction</li>\n            </ul>\n            <strong>Cancel:</strong>\n            <ul>\n                <li>Send 0 ETH to yourself</li>\n                <li>Use same nonce as pending transaction</li>\n                <li>Use higher gas price</li>\n                <li>This \"replaces\" the original transaction</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "difficulty-basic"
        ],
        "order": 63
      },
      {
        "title": "What is a block gas limit?",
        "answer": "\n            <p>The <strong>block gas limit</strong> is the maximum total gas that can be used by all transactions in a single block.</p>\n            <strong>Current Ethereum:</strong>\n            <ul>\n                <li>Target: 15 million gas</li>\n                <li>Max: 30 million gas (after EIP-1559)</li>\n            </ul>\n            <strong>Implications:</strong>\n            <ul>\n                <li>Limits number of transactions per block</li>\n                <li>Complex contracts may hit limits</li>\n                <li>Determines network throughput</li>\n            </ul>\n        ",
        "tags": [
          "transactions",
          "ethereum",
          "difficulty-basic"
        ],
        "order": 64
      },
      {
        "title": "What is a crypto wallet?",
        "answer": "\n            <p>A <strong>crypto wallet</strong> is a tool that allows you to interact with blockchain networks. It stores your private keys which prove ownership of your funds.</p>\n            <strong>Components:</strong>\n            <ul>\n                <li><strong>Private key:</strong> Secret key that proves ownership and signs transactions</li>\n                <li><strong>Public key:</strong> Derived from private key, used to generate addresses</li>\n                <li><strong>Address:</strong> Public identifier where you receive funds</li>\n            </ul>\n            <strong>Types:</strong> Hot wallets, cold wallets, paper wallets, multi-sig wallets\n            <p><strong>Key principle:</strong> \"Not your keys, not your crypto\"</p>\n        ",
        "tags": [
          "wallets",
          "difficulty-basic"
        ],
        "order": 65
      },
      {
        "title": "What is the difference between hot and cold wallets?",
        "answer": "\n            <p>Hot and cold wallets differ in internet connectivity and security.</p>\n            <strong>Hot Wallets:</strong>\n            <ul>\n                <li>Connected to the internet</li>\n                <li>Easy access, more vulnerable to hacks</li>\n                <li>Best for small amounts, frequent transactions</li>\n                <li>Examples: MetaMask, Trust Wallet</li>\n            </ul>\n            <strong>Cold Wallets:</strong>\n            <ul>\n                <li>Stored offline</li>\n                <li>More secure, less convenient</li>\n                <li>Best for long-term storage of large amounts</li>\n                <li>Examples: Ledger, Trezor</li>\n            </ul>\n        ",
        "tags": [
          "wallets",
          "security",
          "difficulty-basic"
        ],
        "order": 66
      },
      {
        "title": "What is a hardware wallet?",
        "answer": "\n            <p>A <strong>hardware wallet</strong> is a physical device that stores private keys offline, providing the highest level of security.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Private keys never leave the device</li>\n                <li>Transactions are signed on the device itself</li>\n                <li>Protected by PIN and optional passphrase</li>\n            </ul>\n            <strong>Popular hardware wallets:</strong> Ledger Nano S/X, Trezor Model One/T, GridPlus Lattice1\n            <strong>Best practices:</strong> Buy from manufacturer, store recovery phrase offline, keep firmware updated\n        ",
        "tags": [
          "wallets",
          "security",
          "difficulty-basic"
        ],
        "order": 67
      },
      {
        "title": "What is a software wallet?",
        "answer": "\n            <p>A <strong>software wallet</strong> is an application (mobile, desktop, or browser extension) that stores your private keys.</p>\n            <strong>Types:</strong>\n            <ul>\n                <li><strong>Browser extensions:</strong> MetaMask, Phantom, Rabby</li>\n                <li><strong>Mobile apps:</strong> Trust Wallet, Rainbow, Coinbase Wallet</li>\n                <li><strong>Desktop:</strong> Exodus, Electrum, Atomic Wallet</li>\n            </ul>\n            <strong>Advantages:</strong> Free, easy to set up, quick dApp access\n            <strong>Risks:</strong> Vulnerable to malware, phishing, device loss\n        ",
        "tags": [
          "wallets",
          "difficulty-basic"
        ],
        "order": 68
      },
      {
        "title": "What is a seed phrase (recovery phrase)?",
        "answer": "\n            <p>A <strong>seed phrase</strong> (recovery phrase, mnemonic) is a list of 12, 18, or 24 words that can recover your wallet and all its accounts.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Generated when creating a new wallet</li>\n                <li>Mathematically derives all your private keys</li>\n                <li>Uses BIP-39 standard (2048 possible words)</li>\n            </ul>\n            <strong>Security rules:</strong>\n            <ul>\n                <li>NEVER share with anyone</li>\n                <li>NEVER store digitally</li>\n                <li>Write on paper or metal backup</li>\n                <li>Store in multiple secure locations</li>\n            </ul>\n        ",
        "tags": [
          "wallets",
          "security",
          "difficulty-basic"
        ],
        "order": 69
      },
      {
        "title": "What is a private key?",
        "answer": "\n            <p>A <strong>private key</strong> is a secret, cryptographically-generated number that proves ownership of a blockchain address.</p>\n            <strong>Characteristics:</strong>\n            <ul>\n                <li>256-bit number (extremely large)</li>\n                <li>64 hexadecimal characters</li>\n                <li>Must be kept absolutely secret</li>\n                <li>Cannot be recovered if lost</li>\n            </ul>\n            <strong>What private keys do:</strong>\n            <ul>\n                <li>Sign transactions to prove authorization</li>\n                <li>Derive public key and address</li>\n                <li>Prove ownership of assets</li>\n            </ul>\n            <p><strong>Critical:</strong> Never share your private key. Anyone with it can steal all your funds.</p>\n        ",
        "tags": [
          "wallets",
          "cryptography",
          "difficulty-basic"
        ],
        "order": 70
      },
      {
        "title": "What is a public key?",
        "answer": "\n            <p>A <strong>public key</strong> is a cryptographic key derived from your private key that can be safely shared.</p>\n            <strong>Relationship:</strong>\n            <ul>\n                <li>Derived from private key using elliptic curve cryptography</li>\n                <li>One-way derivation (cannot get private key from public key)</li>\n                <li>Used to generate wallet addresses</li>\n            </ul>\n            <pre><code>Private Key â†’ (Elliptic Curve) â†’ Public Key â†’ (Hash) â†’ Address</code></pre>\n        ",
        "tags": [
          "wallets",
          "cryptography",
          "difficulty-basic"
        ],
        "order": 71
      },
      {
        "title": "What is a wallet address?",
        "answer": "\n            <p>A <strong>wallet address</strong> is a unique identifier where you can receive cryptocurrency.</p>\n            <strong>Address formats:</strong>\n            <ul>\n                <li><strong>Ethereum:</strong> 0x + 40 hex characters</li>\n                <li><strong>Bitcoin:</strong> 1..., 3..., or bc1...</li>\n                <li><strong>Solana:</strong> Base58, 32-44 characters</li>\n            </ul>\n            <strong>Best practices:</strong>\n            <ul>\n                <li>Double-check addresses before sending</li>\n                <li>Use copy-paste, never type manually</li>\n                <li>Send test transaction first for large amounts</li>\n            </ul>\n        ",
        "tags": [
          "wallets",
          "difficulty-basic"
        ],
        "order": 72
      },
      {
        "title": "What is the difference between custodial and non-custodial wallets?",
        "answer": "\n            <p>The key difference is who controls the private keys.</p>\n            <strong>Custodial Wallets:</strong>\n            <ul>\n                <li>Third party holds your private keys</li>\n                <li>Similar to a bank account</li>\n                <li>Examples: Coinbase, Binance accounts</li>\n            </ul>\n            <strong>Non-Custodial Wallets:</strong>\n            <ul>\n                <li>You control your own private keys</li>\n                <li>Full responsibility for security</li>\n                <li>Examples: MetaMask, Ledger, Trezor</li>\n            </ul>\n            <table>\n                <tr><th>Aspect</th><th>Custodial</th><th>Non-Custodial</th></tr>\n                <tr><td>Key control</td><td>Third party</td><td>You</td></tr>\n                <tr><td>Recovery</td><td>Customer support</td><td>Only with seed phrase</td></tr>\n                <tr><td>True ownership</td><td>No</td><td>Yes</td></tr>\n            </table>\n        ",
        "tags": [
          "wallets",
          "security",
          "difficulty-basic"
        ],
        "order": 73
      },
      {
        "title": "What is MetaMask?",
        "answer": "\n            <p><strong>MetaMask</strong> is the most popular non-custodial cryptocurrency wallet for Ethereum and EVM-compatible blockchains.</p>\n            <strong>Key features:</strong>\n            <ul>\n                <li>Browser extension and mobile app</li>\n                <li>Supports multiple EVM networks (Ethereum, Polygon, Arbitrum)</li>\n                <li>Built-in token swap functionality</li>\n                <li>NFT display and dApp browser</li>\n            </ul>\n            <strong>Security tips:</strong>\n            <ul>\n                <li>Only download from official sources</li>\n                <li>Never share your seed phrase</li>\n                <li>Be cautious of phishing sites</li>\n            </ul>\n        ",
        "tags": [
          "wallets",
          "ethereum",
          "difficulty-basic"
        ],
        "order": 74
      },
      {
        "title": "What is a paper wallet?",
        "answer": "\n            <p>A <strong>paper wallet</strong> is a physical document containing your private key and/or seed phrase.</p>\n            <strong>Pros:</strong>\n            <ul>\n                <li>Completely offline (air-gapped)</li>\n                <li>Immune to digital attacks</li>\n                <li>Simple to create</li>\n            </ul>\n            <strong>Cons:</strong>\n            <ul>\n                <li>Vulnerable to physical damage (fire, water)</li>\n                <li>Can be lost or stolen</li>\n                <li>Difficult to use for transactions</li>\n            </ul>\n            <strong>Best practice:</strong> Use metal backups like Cryptosteel for durability\n        ",
        "tags": [
          "wallets",
          "security",
          "difficulty-basic"
        ],
        "order": 75
      },
      {
        "title": "What is a multi-signature wallet?",
        "answer": "\n            <p>A <strong>multi-signature (multi-sig) wallet</strong> requires multiple private keys to authorize a transaction.</p>\n            <strong>Common configurations:</strong>\n            <ul>\n                <li><strong>2-of-3:</strong> 2 signatures needed from 3 possible signers</li>\n                <li><strong>3-of-5:</strong> 3 signatures needed from 5 possible signers</li>\n            </ul>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Corporate treasury management</li>\n                <li>DAO governance</li>\n                <li>Enhanced personal security</li>\n                <li>Escrow services</li>\n            </ul>\n            <strong>Popular multi-sig wallets:</strong> Gnosis Safe, Armory, Electrum\n        ",
        "tags": [
          "wallets",
          "security",
          "difficulty-basic"
        ],
        "order": 76
      },
      {
        "title": "What is wallet connect?",
        "answer": "\n            <p><strong>WalletConnect</strong> is an open protocol for connecting wallets to dApps securely.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Scan QR code or click deep link</li>\n                <li>Establishes encrypted connection</li>\n                <li>dApp can request transactions</li>\n                <li>User approves on their wallet</li>\n            </ul>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Works with many wallets</li>\n                <li>Connect mobile wallet to desktop dApp</li>\n                <li>End-to-end encryption</li>\n                <li>No browser extension needed</li>\n            </ul>\n        ",
        "tags": [
          "wallets",
          "dapps",
          "difficulty-basic"
        ],
        "order": 77
      },
      {
        "title": "What is address poisoning?",
        "answer": "\n            <p><strong>Address poisoning</strong> is a scam where attackers send small transactions from addresses that look similar to ones you've used.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Scammer generates address with similar start/end characters</li>\n                <li>Sends tiny transaction to appear in your history</li>\n                <li>Victim copies wrong address from history</li>\n                <li>Funds sent to scammer's address</li>\n            </ul>\n            <strong>Prevention:</strong>\n            <ul>\n                <li>Always verify FULL address</li>\n                <li>Use address book/contacts feature</li>\n                <li>Don't copy addresses from transaction history</li>\n            </ul>\n        ",
        "tags": [
          "wallets",
          "security",
          "difficulty-basic"
        ],
        "order": 78
      },
      {
        "title": "What is a vanity address?",
        "answer": "\n            <p>A <strong>vanity address</strong> is a cryptocurrency address customized to contain specific characters or words.</p>\n            <strong>Examples:</strong>\n            <ul>\n                <li>0xDEAD... (starts with \"DEAD\")</li>\n                <li>0x...1234 (ends with specific numbers)</li>\n                <li>vitalik.eth (ENS name)</li>\n            </ul>\n            <strong>How they're created:</strong>\n            <ul>\n                <li>Generate millions of addresses</li>\n                <li>Check each for desired pattern</li>\n                <li>Longer patterns take exponentially longer</li>\n            </ul>\n            <strong>Caution:</strong> Never use online vanity generators - they may steal your keys\n        ",
        "tags": [
          "wallets",
          "difficulty-basic"
        ],
        "order": 79
      },
      {
        "title": "What is a dApp (decentralized application)?",
        "answer": "\n            <p>A <strong>dApp</strong> (decentralized application) is an application that runs on a decentralized network using smart contracts.</p>\n            <strong>Characteristics:</strong>\n            <ul>\n                <li><strong>Open source:</strong> Code is publicly verifiable</li>\n                <li><strong>Decentralized:</strong> Runs on blockchain, not single server</li>\n                <li><strong>Censorship-resistant:</strong> No single point of control</li>\n                <li><strong>Token-incentivized:</strong> Often uses crypto tokens</li>\n            </ul>\n            <strong>Examples:</strong>\n            <ul>\n                <li><strong>DeFi:</strong> Uniswap, Aave, Compound</li>\n                <li><strong>NFT:</strong> OpenSea, Blur</li>\n                <li><strong>Gaming:</strong> Axie Infinity, Gods Unchained</li>\n            </ul>\n        ",
        "tags": [
          "dapps",
          "difficulty-basic"
        ],
        "order": 80
      },
      {
        "title": "What is Web3?",
        "answer": "\n            <p><strong>Web3</strong> refers to the next evolution of the internet, built on blockchain technology with emphasis on decentralization, ownership, and trustlessness.</p>\n            <strong>Key principles:</strong>\n            <ul>\n                <li><strong>Decentralization:</strong> No central authorities</li>\n                <li><strong>Ownership:</strong> Users own their data and assets</li>\n                <li><strong>Trustlessness:</strong> Trust code, not intermediaries</li>\n                <li><strong>Permissionless:</strong> Open access for all</li>\n                <li><strong>Native payments:</strong> Built-in cryptocurrency</li>\n            </ul>\n        ",
        "tags": [
          "web3",
          "difficulty-basic"
        ],
        "order": 81
      },
      {
        "title": "What is the difference between Web1, Web2, and Web3?",
        "answer": "\n            <p>The web has evolved through three major phases:</p>\n            <table>\n                <tr><th>Era</th><th>Description</th><th>Examples</th></tr>\n                <tr><td>Web1 (1990s-2000s)</td><td>Read-only, static pages</td><td>Yahoo, AOL, early websites</td></tr>\n                <tr><td>Web2 (2000s-now)</td><td>Read-write, interactive, centralized</td><td>Facebook, Google, Twitter</td></tr>\n                <tr><td>Web3 (emerging)</td><td>Read-write-own, decentralized</td><td>Ethereum, DeFi, NFTs</td></tr>\n            </table>\n            <strong>Key differences:</strong>\n            <ul>\n                <li><strong>Web1:</strong> Publishers create, users consume</li>\n                <li><strong>Web2:</strong> Users create content, platforms own it</li>\n                <li><strong>Web3:</strong> Users create and own their content</li>\n            </ul>\n        ",
        "tags": [
          "web3",
          "difficulty-basic"
        ],
        "order": 82
      },
      {
        "title": "What is the difference between Web2 and Web3?",
        "answer": "\n            <p>Web2 and Web3 represent different eras of internet evolution.</p>\n            <table>\n                <tr><th>Aspect</th><th>Web2</th><th>Web3</th></tr>\n                <tr><td>Control</td><td>Centralized companies</td><td>Decentralized networks</td></tr>\n                <tr><td>Data ownership</td><td>Platforms own user data</td><td>Users own their data</td></tr>\n                <tr><td>Identity</td><td>Email/password per site</td><td>Single wallet identity</td></tr>\n                <tr><td>Payments</td><td>Credit cards, banks</td><td>Native cryptocurrency</td></tr>\n                <tr><td>Trust</td><td>Trust the company</td><td>Trust the code</td></tr>\n                <tr><td>Censorship</td><td>Easy to censor</td><td>Censorship-resistant</td></tr>\n            </table>\n        ",
        "tags": [
          "web3",
          "difficulty-basic"
        ],
        "order": 83
      },
      {
        "title": "What is a smart contract (basic overview)?",
        "answer": "\n            <p>A <strong>smart contract</strong> is self-executing code stored on a blockchain that automatically enforces the terms of an agreement.</p>\n            <strong>Key properties:</strong>\n            <ul>\n                <li><strong>Automated:</strong> Executes when conditions are met</li>\n                <li><strong>Immutable:</strong> Cannot be changed once deployed</li>\n                <li><strong>Transparent:</strong> Code is publicly visible</li>\n                <li><strong>Trustless:</strong> No intermediaries needed</li>\n            </ul>\n            <strong>Examples:</strong>\n            <ul>\n                <li>Token transfers (ERC-20)</li>\n                <li>NFT ownership (ERC-721)</li>\n                <li>Decentralized exchanges</li>\n                <li>Lending protocols</li>\n            </ul>\n        ",
        "tags": [
          "smart-contracts",
          "difficulty-basic"
        ],
        "order": 84
      },
      {
        "title": "What is Ethereum Name Service (ENS)?",
        "answer": "\n            <p><strong>ENS</strong> (Ethereum Name Service) is a decentralized naming system that maps human-readable names to blockchain addresses.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Register a .eth domain (e.g., vitalik.eth)</li>\n                <li>Link it to your wallet address</li>\n                <li>Use the name instead of the long hex address</li>\n            </ul>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Easy to remember and share</li>\n                <li>Reduces errors in transactions</li>\n                <li>Can link to websites, social profiles, and more</li>\n                <li>NFT-based ownership</li>\n            </ul>\n            <strong>Example:</strong> Send ETH to \"vitalik.eth\" instead of \"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\"\n        ",
        "tags": [
          "ens",
          "ethereum",
          "difficulty-basic"
        ],
        "order": 85
      },
      {
        "title": "What is an NFT?",
        "answer": "\n            <p>An <strong>NFT</strong> (Non-Fungible Token) is a unique digital asset that represents ownership of a specific item on the blockchain.</p>\n            <strong>Key properties:</strong>\n            <ul>\n                <li><strong>Non-fungible:</strong> Each token is unique (unlike ETH or BTC)</li>\n                <li><strong>Verifiable ownership:</strong> Blockchain proves who owns it</li>\n                <li><strong>Transferable:</strong> Can be bought, sold, traded</li>\n                <li><strong>Programmable:</strong> Can include royalties, unlockables</li>\n            </ul>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Digital art and collectibles</li>\n                <li>Gaming items</li>\n                <li>Event tickets</li>\n                <li>Domain names</li>\n                <li>Music and media</li>\n            </ul>\n        ",
        "tags": [
          "nft",
          "tokens",
          "difficulty-basic"
        ],
        "order": 86
      },
      {
        "title": "What is DeFi?",
        "answer": "\n            <p><strong>DeFi</strong> (Decentralized Finance) refers to financial services built on blockchain without traditional intermediaries.</p>\n            <strong>DeFi services:</strong>\n            <ul>\n                <li><strong>Lending/Borrowing:</strong> Aave, Compound</li>\n                <li><strong>Trading:</strong> Uniswap, Curve</li>\n                <li><strong>Stablecoins:</strong> DAI, USDC</li>\n                <li><strong>Yield farming:</strong> Yearn Finance</li>\n                <li><strong>Insurance:</strong> Nexus Mutual</li>\n            </ul>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Accessible to anyone with internet</li>\n                <li>No credit checks or KYC</li>\n                <li>Transparent and auditable</li>\n                <li>Composable (\"money legos\")</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "difficulty-basic"
        ],
        "order": 87
      },
      {
        "title": "What is a DAO?",
        "answer": "\n            <p>A <strong>DAO</strong> (Decentralized Autonomous Organization) is an organization governed by smart contracts and token holder votes.</p>\n            <strong>How DAOs work:</strong>\n            <ul>\n                <li>Rules encoded in smart contracts</li>\n                <li>Token holders can vote on proposals</li>\n                <li>Treasury managed by the DAO</li>\n                <li>No central leadership</li>\n            </ul>\n            <strong>Examples:</strong>\n            <ul>\n                <li><strong>MakerDAO:</strong> Manages DAI stablecoin</li>\n                <li><strong>Uniswap:</strong> Protocol governance</li>\n                <li><strong>ENS DAO:</strong> Manages ENS protocol</li>\n            </ul>\n        ",
        "tags": [
          "dao",
          "governance",
          "difficulty-basic"
        ],
        "order": 88
      },
      {
        "title": "What is Layer 1 vs Layer 2?",
        "answer": "\n            <p><strong>Layer 1</strong> is the base blockchain, while <strong>Layer 2</strong> is a secondary framework built on top to improve scalability.</p>\n            <strong>Layer 1 examples:</strong>\n            <ul>\n                <li>Ethereum, Bitcoin, Solana, Avalanche</li>\n            </ul>\n            <strong>Layer 2 examples:</strong>\n            <ul>\n                <li><strong>Rollups:</strong> Arbitrum, Optimism, zkSync</li>\n                <li><strong>State channels:</strong> Lightning Network</li>\n                <li><strong>Sidechains:</strong> Polygon PoS</li>\n            </ul>\n            <strong>Benefits of L2:</strong>\n            <ul>\n                <li>Lower fees</li>\n                <li>Faster transactions</li>\n                <li>Inherits L1 security (rollups)</li>\n            </ul>\n        ",
        "tags": [
          "scaling",
          "layer2",
          "difficulty-basic"
        ],
        "order": 89
      },
      {
        "title": "What is gas optimization?",
        "answer": "\n            <p><strong>Gas optimization</strong> is the practice of writing efficient smart contract code to minimize transaction costs.</p>\n            <strong>Common techniques:</strong>\n            <ul>\n                <li>Use uint256 instead of smaller integers</li>\n                <li>Pack storage variables</li>\n                <li>Use events instead of storage for logs</li>\n                <li>Avoid unnecessary storage reads/writes</li>\n                <li>Use calldata instead of memory for function params</li>\n            </ul>\n            <strong>Why it matters:</strong>\n            <ul>\n                <li>Lower costs for users</li>\n                <li>Better user experience</li>\n                <li>More competitive protocols</li>\n            </ul>\n        ",
        "tags": [
          "development",
          "gas",
          "difficulty-basic"
        ],
        "order": 90
      },
      {
        "title": "What is a testnet?",
        "answer": "\n            <p>A <strong>testnet</strong> is a blockchain network for testing that uses tokens with no real value.</p>\n            <strong>Popular testnets:</strong>\n            <ul>\n                <li><strong>Ethereum:</strong> Sepolia, Goerli</li>\n                <li><strong>Polygon:</strong> Mumbai</li>\n                <li><strong>Arbitrum:</strong> Arbitrum Sepolia</li>\n            </ul>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Testing smart contracts before mainnet</li>\n                <li>Learning without risking real money</li>\n                <li>QA and debugging</li>\n            </ul>\n            <strong>Getting testnet tokens:</strong> Faucets (free) like Sepolia Faucet\n        ",
        "tags": [
          "development",
          "networks",
          "difficulty-basic"
        ],
        "order": 91
      },
      {
        "title": "What is mainnet?",
        "answer": "\n            <p><strong>Mainnet</strong> is the primary, production blockchain network where real value transactions occur.</p>\n            <strong>Mainnet vs Testnet:</strong>\n            <table>\n                <tr><th>Aspect</th><th>Mainnet</th><th>Testnet</th></tr>\n                <tr><td>Value</td><td>Real money</td><td>No value</td></tr>\n                <tr><td>Purpose</td><td>Production</td><td>Testing</td></tr>\n                <tr><td>Security</td><td>Maximum</td><td>Lower priority</td></tr>\n                <tr><td>Tokens</td><td>Must be purchased</td><td>Free from faucets</td></tr>\n            </table>\n        ",
        "tags": [
          "networks",
          "difficulty-basic"
        ],
        "order": 92
      },
      {
        "title": "What is a faucet in crypto?",
        "answer": "\n            <p>A <strong>faucet</strong> is a website or app that dispenses free cryptocurrency, typically for testing purposes.</p>\n            <strong>Types:</strong>\n            <ul>\n                <li><strong>Testnet faucets:</strong> Free testnet tokens for development</li>\n                <li><strong>Mainnet faucets:</strong> Small amounts of real crypto (rare)</li>\n            </ul>\n            <strong>Popular faucets:</strong>\n            <ul>\n                <li>Alchemy Sepolia Faucet</li>\n                <li>Chainlink Faucets</li>\n                <li>Paradigm Faucet</li>\n            </ul>\n            <strong>Note:</strong> Most require wallet connection or social verification to prevent abuse\n        ",
        "tags": [
          "development",
          "tools",
          "difficulty-basic"
        ],
        "order": 93
      },
      {
        "title": "What is a blockchain bridge?",
        "answer": "\n            <p>A <strong>bridge</strong> allows transferring assets between different blockchain networks.</p>\n            <strong>How bridges work:</strong>\n            <ol>\n                <li>Lock tokens on source chain</li>\n                <li>Mint wrapped tokens on destination chain</li>\n                <li>To return: burn wrapped tokens</li>\n                <li>Unlock original tokens</li>\n            </ol>\n            <strong>Examples:</strong>\n            <ul>\n                <li>Arbitrum Bridge</li>\n                <li>Polygon Bridge</li>\n                <li>Wormhole</li>\n                <li>Across Protocol</li>\n            </ul>\n            <strong>Risks:</strong> Bridge hacks have caused billions in losses - use trusted bridges carefully\n        ",
        "tags": [
          "crosschain",
          "difficulty-basic"
        ],
        "order": 94
      },
      {
        "title": "What is an oracle in blockchain?",
        "answer": "\n            <p>An <strong>oracle</strong> provides external data to smart contracts, which cannot access off-chain information directly.</p>\n            <strong>Types of data:</strong>\n            <ul>\n                <li>Price feeds (ETH/USD, BTC/USD)</li>\n                <li>Weather data</li>\n                <li>Sports scores</li>\n                <li>Random numbers</li>\n            </ul>\n            <strong>Popular oracles:</strong>\n            <ul>\n                <li><strong>Chainlink:</strong> Industry leader, decentralized</li>\n                <li><strong>Band Protocol</strong></li>\n                <li><strong>Pyth Network</strong></li>\n            </ul>\n            <strong>Oracle problem:</strong> Ensuring off-chain data is accurate and tamper-proof\n        ",
        "tags": [
          "oracles",
          "difficulty-basic"
        ],
        "order": 95
      },
      {
        "title": "What is IPFS?",
        "answer": "\n            <p><strong>IPFS</strong> (InterPlanetary File System) is a decentralized protocol for storing and sharing files.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Files addressed by content hash (CID)</li>\n                <li>Same content = same address</li>\n                <li>Distributed across network nodes</li>\n                <li>No central server</li>\n            </ul>\n            <strong>Uses in Web3:</strong>\n            <ul>\n                <li>NFT metadata and images</li>\n                <li>dApp frontends</li>\n                <li>Document storage</li>\n            </ul>\n            <strong>Pinning services:</strong> Pinata, Infura, NFT.Storage keep files available\n        ",
        "tags": [
          "storage",
          "decentralized",
          "difficulty-basic"
        ],
        "order": 96
      },
      {
        "title": "What is a rug pull?",
        "answer": "\n            <p>A <strong>rug pull</strong> is a scam where developers abandon a project after collecting investor funds.</p>\n            <strong>Common types:</strong>\n            <ul>\n                <li><strong>Liquidity pull:</strong> Developers remove all liquidity from DEX</li>\n                <li><strong>Selling supply:</strong> Team dumps large token holdings</li>\n                <li><strong>Limiting sells:</strong> Code prevents users from selling</li>\n            </ul>\n            <strong>Red flags:</strong>\n            <ul>\n                <li>Anonymous team</li>\n                <li>Unverified/unaudited contracts</li>\n                <li>Too-good-to-be-true returns</li>\n                <li>Locked liquidity with short timeframe</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "scams",
          "difficulty-basic"
        ],
        "order": 97
      },
      {
        "title": "What is DYOR?",
        "answer": "\n            <p><strong>DYOR</strong> stands for \"Do Your Own Research\" - a common phrase in crypto reminding people to investigate before investing.</p>\n            <strong>What to research:</strong>\n            <ul>\n                <li>Team background and credibility</li>\n                <li>Tokenomics and supply</li>\n                <li>Smart contract audits</li>\n                <li>Community and social presence</li>\n                <li>Roadmap and development activity</li>\n                <li>Use case and competition</li>\n            </ul>\n            <strong>Tools for research:</strong>\n            <ul>\n                <li>CoinGecko, CoinMarketCap</li>\n                <li>Etherscan, block explorers</li>\n                <li>DeFiLlama for TVL</li>\n                <li>GitHub for code activity</li>\n            </ul>\n        ",
        "tags": [
          "culture",
          "security",
          "difficulty-basic"
        ],
        "order": 98
      }
    ],
    "intermediate": [
      {
        "title": "What is a smart contract in detail?",
        "answer": "\n            <p>A <strong>smart contract</strong> is a program stored on a blockchain that automatically executes when predetermined conditions are met. On Ethereum, smart contracts are written in Solidity and compiled to bytecode that runs on the EVM.</p>\n            <strong>Anatomy of a smart contract:</strong>\n            <pre><code class=\"language-solidity\">// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleStorage {\n    // State variables (stored on blockchain)\n    uint256 public storedData;\n    address public owner;\n    \n    // Events\n    event DataStored(uint256 data, address indexed by);\n    \n    // Constructor (runs once at deployment)\n    constructor() {\n        owner = msg.sender;\n    }\n    \n    // Functions\n    function set(uint256 x) public {\n        storedData = x;\n        emit DataStored(x, msg.sender);\n    }\n    \n    function get() public view returns (uint256) {\n        return storedData;\n    }\n}</code></pre>\n            <strong>Key components:</strong>\n            <ul>\n                <li><strong>State variables:</strong> Permanently stored on blockchain</li>\n                <li><strong>Functions:</strong> Executable code</li>\n                <li><strong>Events:</strong> Logging mechanism</li>\n                <li><strong>Modifiers:</strong> Reusable function conditions</li>\n            </ul>\n        ",
        "tags": [
          "smart-contracts",
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 0
      },
      {
        "title": "What is the Ethereum Virtual Machine (EVM)?",
        "answer": "\n            <p>The <strong>EVM</strong> (Ethereum Virtual Machine) is a stack-based virtual machine that executes smart contract bytecode on the Ethereum network.</p>\n            <strong>Key characteristics:</strong>\n            <ul>\n                <li><strong>Turing-complete:</strong> Can compute anything computable (with gas limits)</li>\n                <li><strong>Deterministic:</strong> Same input always produces same output</li>\n                <li><strong>Isolated:</strong> Contracts run in sandboxed environment</li>\n                <li><strong>Stack-based:</strong> Uses a stack for operations</li>\n            </ul>\n            <strong>EVM components:</strong>\n            <ul>\n                <li><strong>Stack:</strong> LIFO, 1024 elements max, 256-bit words</li>\n                <li><strong>Memory:</strong> Temporary, byte-addressable, cleared between calls</li>\n                <li><strong>Storage:</strong> Permanent, key-value store, expensive</li>\n                <li><strong>Calldata:</strong> Read-only input data</li>\n            </ul>\n            <strong>EVM-compatible chains:</strong> Polygon, BSC, Avalanche, Arbitrum, Optimism\n        ",
        "tags": [
          "evm",
          "ethereum",
          "difficulty-intermediate"
        ],
        "order": 1
      },
      {
        "title": "What is bytecode and ABI?",
        "answer": "\n            <p><strong>Bytecode</strong> and <strong>ABI</strong> are two outputs from compiling Solidity code.</p>\n            <strong>Bytecode:</strong>\n            <ul>\n                <li>Low-level machine code that runs on the EVM</li>\n                <li>Hexadecimal representation of opcodes</li>\n                <li>Deployed to the blockchain</li>\n            </ul>\n            <pre><code>// Example bytecode (abbreviated)\n0x608060405234801561001057600080fd5b50...</code></pre>\n            <strong>ABI (Application Binary Interface):</strong>\n            <ul>\n                <li>JSON description of contract interface</li>\n                <li>Defines functions, parameters, and events</li>\n                <li>Used by frontends to interact with contracts</li>\n            </ul>\n            <pre><code class=\"language-json\">[\n  {\n    \"inputs\": [{\"name\": \"x\", \"type\": \"uint256\"}],\n    \"name\": \"set\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]</code></pre>\n        ",
        "tags": [
          "evm",
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 2
      },
      {
        "title": "What is contract deployment?",
        "answer": "\n            <p><strong>Contract deployment</strong> is the process of publishing a smart contract to the blockchain, making it available for interaction.</p>\n            <strong>Deployment process:</strong>\n            <ol>\n                <li>Write and compile Solidity code</li>\n                <li>Create deployment transaction (no 'to' address)</li>\n                <li>Include bytecode in transaction data</li>\n                <li>Sign and broadcast transaction</li>\n                <li>Contract receives unique address</li>\n            </ol>\n            <strong>Deployment with Ethers.js:</strong>\n            <pre><code class=\"language-javascript\">const factory = new ethers.ContractFactory(abi, bytecode, signer);\nconst contract = await factory.deploy(constructorArgs);\nawait contract.deployed();\nconsole.log(\"Deployed to:\", contract.address);</code></pre>\n            <strong>Costs:</strong>\n            <ul>\n                <li>Gas for bytecode storage (200 gas per byte)</li>\n                <li>Constructor execution gas</li>\n                <li>More complex contracts = higher deployment cost</li>\n            </ul>\n        ",
        "tags": [
          "smart-contracts",
          "difficulty-intermediate"
        ],
        "order": 3
      },
      {
        "title": "What are Solidity data types?",
        "answer": "\n            <p>Solidity has various data types for different use cases.</p>\n            <strong>Value Types:</strong>\n            <ul>\n                <li><strong>bool:</strong> true or false</li>\n                <li><strong>uint/int:</strong> Unsigned/signed integers (uint8 to uint256)</li>\n                <li><strong>address:</strong> 20-byte Ethereum address</li>\n                <li><strong>bytes1-bytes32:</strong> Fixed-size byte arrays</li>\n                <li><strong>enum:</strong> User-defined type with set of values</li>\n            </ul>\n            <strong>Reference Types:</strong>\n            <ul>\n                <li><strong>arrays:</strong> Fixed or dynamic size</li>\n                <li><strong>struct:</strong> Custom data structures</li>\n                <li><strong>mapping:</strong> Key-value storage</li>\n                <li><strong>string:</strong> Dynamic UTF-8 encoded string</li>\n                <li><strong>bytes:</strong> Dynamic byte array</li>\n            </ul>\n            <pre><code class=\"language-solidity\">mapping(address => uint256) public balances;\nstruct User { string name; uint256 balance; }\nuint256[] public dynamicArray;</code></pre>\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 4
      },
      {
        "title": "What are function visibility modifiers in Solidity?",
        "answer": "\n            <p>Solidity functions have visibility modifiers that control access.</p>\n            <strong>Visibility Types:</strong>\n            <ul>\n                <li><strong>public:</strong> Accessible from anywhere (internal + external)</li>\n                <li><strong>external:</strong> Only callable from outside the contract</li>\n                <li><strong>internal:</strong> Only from this contract or derived contracts</li>\n                <li><strong>private:</strong> Only from this contract</li>\n            </ul>\n            <strong>State Mutability:</strong>\n            <ul>\n                <li><strong>view:</strong> Reads state but doesn't modify</li>\n                <li><strong>pure:</strong> Doesn't read or modify state</li>\n                <li><strong>payable:</strong> Can receive ETH</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function getBalance() public view returns (uint256) {\n    return address(this).balance;\n}\n\nfunction calculateSum(uint a, uint b) public pure returns (uint) {\n    return a + b;\n}\n\nfunction deposit() public payable {\n    // Can receive ETH\n}</code></pre>\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 5
      },
      {
        "title": "What are events in smart contracts?",
        "answer": "\n            <p><strong>Events</strong> are a logging mechanism in Solidity that emit data to the blockchain's transaction logs, which can be queried by off-chain applications.</p>\n            <pre><code class=\"language-solidity\">contract Token {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n    \n    function transfer(address to, uint256 amount) public {\n        // ... transfer logic\n        emit Transfer(msg.sender, to, amount);\n    }\n}</code></pre>\n            <strong>Key points:</strong>\n            <ul>\n                <li><strong>indexed:</strong> Up to 3 parameters can be indexed for filtering</li>\n                <li>Events are stored in logs, not contract storage (cheaper)</li>\n                <li>Cannot be read by smart contracts, only off-chain</li>\n                <li>Common for frontend updates and historical queries</li>\n            </ul>\n            <strong>Listening to events (JavaScript):</strong>\n            <pre><code class=\"language-javascript\">contract.on(\"Transfer\", (from, to, value) => {\n    console.log(`${from} sent ${value} to ${to}`);\n});</code></pre>\n        ",
        "tags": [
          "solidity",
          "events",
          "difficulty-intermediate"
        ],
        "order": 6
      },
      {
        "title": "What are modifiers in Solidity?",
        "answer": "\n            <p><strong>Modifiers</strong> are reusable code that can be added to functions to add checks or modify behavior.</p>\n            <pre><code class=\"language-solidity\">contract Ownable {\n    address public owner;\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _; // Placeholder for function body\n    }\n    \n    modifier validAddress(address addr) {\n        require(addr != address(0), \"Invalid address\");\n        _;\n    }\n    \n    function withdraw() public onlyOwner {\n        // Only owner can call this\n    }\n    \n    function transfer(address to) public validAddress(to) {\n        // Address must be valid\n    }\n}</code></pre>\n            <strong>Common use cases:</strong>\n            <ul>\n                <li>Access control (onlyOwner, onlyAdmin)</li>\n                <li>Input validation</li>\n                <li>Reentrancy guards</li>\n                <li>Pausable functionality</li>\n            </ul>\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 7
      },
      {
        "title": "What is the difference between require, assert, and revert?",
        "answer": "\n            <p>Solidity provides three ways to handle errors and revert transactions.</p>\n            <strong>require():</strong>\n            <ul>\n                <li>Used for input validation and external conditions</li>\n                <li>Refunds remaining gas</li>\n                <li>Can include error message</li>\n            </ul>\n            <pre><code class=\"language-solidity\">require(balance >= amount, \"Insufficient balance\");</code></pre>\n            <strong>assert():</strong>\n            <ul>\n                <li>Used for internal errors and invariants</li>\n                <li>Consumes all remaining gas (pre-0.8.0)</li>\n                <li>Should never fail in production</li>\n            </ul>\n            <pre><code class=\"language-solidity\">assert(balance == previousBalance - amount);</code></pre>\n            <strong>revert():</strong>\n            <ul>\n                <li>Explicitly reverts with optional message</li>\n                <li>Useful in complex conditions</li>\n                <li>Can use custom errors (gas efficient)</li>\n            </ul>\n            <pre><code class=\"language-solidity\">if (amount > balance) {\n    revert InsufficientBalance(balance, amount);\n}</code></pre>\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 8
      },
      {
        "title": "What is contract inheritance in Solidity?",
        "answer": "\n            <p>Solidity supports multiple inheritance, allowing contracts to inherit from one or more parent contracts.</p>\n            <pre><code class=\"language-solidity\">contract Ownable {\n    address public owner;\n    modifier onlyOwner() { require(msg.sender == owner); _; }\n}\n\ncontract Pausable is Ownable {\n    bool public paused;\n    modifier whenNotPaused() { require(!paused); _; }\n}\n\ncontract Token is Ownable, Pausable {\n    // Inherits from both\n    function transfer() public whenNotPaused {\n        // ...\n    }\n}</code></pre>\n            <strong>Key concepts:</strong>\n            <ul>\n                <li><strong>is:</strong> Keyword for inheritance</li>\n                <li><strong>virtual:</strong> Function can be overridden</li>\n                <li><strong>override:</strong> Function overrides parent</li>\n                <li><strong>super:</strong> Call parent function</li>\n            </ul>\n            <strong>C3 Linearization:</strong> Determines order when multiple parents\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 9
      },
      {
        "title": "What is the difference between memory, storage, and calldata?",
        "answer": "\n            <p>Solidity has three data locations for reference types.</p>\n            <strong>Storage:</strong>\n            <ul>\n                <li>Permanent storage on blockchain</li>\n                <li>State variables are storage by default</li>\n                <li>Most expensive (SSTORE: 20,000 gas)</li>\n                <li>Persists between function calls</li>\n            </ul>\n            <strong>Memory:</strong>\n            <ul>\n                <li>Temporary, exists during function execution</li>\n                <li>Used for function parameters and local variables</li>\n                <li>Cheaper than storage</li>\n                <li>Mutable</li>\n            </ul>\n            <strong>Calldata:</strong>\n            <ul>\n                <li>Read-only, contains function arguments</li>\n                <li>Only for external function parameters</li>\n                <li>Cheapest option</li>\n                <li>Immutable</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function process(string calldata input) external {\n    string memory temp = input; // Copy to memory\n    // storage would be a state variable\n}</code></pre>\n        ",
        "tags": [
          "solidity",
          "evm",
          "difficulty-intermediate"
        ],
        "order": 10
      },
      {
        "title": "What is a constructor in Solidity?",
        "answer": "\n            <p>A <strong>constructor</strong> is a special function that executes only once when a contract is deployed.</p>\n            <pre><code class=\"language-solidity\">contract Token {\n    string public name;\n    address public owner;\n    uint256 public totalSupply;\n    \n    constructor(string memory _name, uint256 _initialSupply) {\n        name = _name;\n        owner = msg.sender;\n        totalSupply = _initialSupply;\n    }\n}</code></pre>\n            <strong>Key points:</strong>\n            <ul>\n                <li>Runs exactly once at deployment</li>\n                <li>Cannot be called after deployment</li>\n                <li>Can accept parameters</li>\n                <li>Used to set initial state and owner</li>\n                <li>No function name or visibility keyword needed</li>\n            </ul>\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 11
      },
      {
        "title": "What are interfaces in Solidity?",
        "answer": "\n            <p><strong>Interfaces</strong> define a contract's external functions without implementation, enabling contract-to-contract interaction.</p>\n            <pre><code class=\"language-solidity\">interface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract MyContract {\n    IERC20 public token;\n    \n    constructor(address tokenAddress) {\n        token = IERC20(tokenAddress);\n    }\n    \n    function checkBalance(address user) public view returns (uint256) {\n        return token.balanceOf(user);\n    }\n}</code></pre>\n            <strong>Interface rules:</strong>\n            <ul>\n                <li>Cannot have state variables</li>\n                <li>Cannot have constructors</li>\n                <li>All functions must be external</li>\n                <li>Cannot implement any functions</li>\n            </ul>\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 12
      },
      {
        "title": "What are libraries in Solidity?",
        "answer": "\n            <p><strong>Libraries</strong> are reusable code deployed once and called by multiple contracts, saving gas.</p>\n            <pre><code class=\"language-solidity\">library SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"Overflow\");\n        return c;\n    }\n}\n\ncontract Token {\n    using SafeMath for uint256;\n    \n    mapping(address => uint256) balances;\n    \n    function transfer(address to, uint256 amount) public {\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n    }\n}</code></pre>\n            <strong>Key points:</strong>\n            <ul>\n                <li><strong>using for:</strong> Attaches library functions to types</li>\n                <li>Libraries cannot have state variables</li>\n                <li>Internal functions are inlined</li>\n                <li>Common examples: SafeMath, Address, Strings</li>\n            </ul>\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 13
      },
      {
        "title": "What is the receive and fallback function?",
        "answer": "\n            <p>Special functions that handle ETH transfers and unknown function calls.</p>\n            <pre><code class=\"language-solidity\">contract Receiver {\n    event Received(address sender, uint256 amount);\n    event FallbackCalled(address sender, bytes data);\n    \n    // Called when ETH is sent with empty calldata\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n    \n    // Called when no function matches or when ETH sent with data\n    fallback() external payable {\n        emit FallbackCalled(msg.sender, msg.data);\n    }\n}</code></pre>\n            <strong>Call order:</strong>\n            <ol>\n                <li>If calldata is empty and receive exists â†’ receive()</li>\n                <li>Otherwise â†’ fallback()</li>\n            </ol>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Receiving ETH</li>\n                <li>Proxy contracts</li>\n                <li>Handling unknown calls</li>\n            </ul>\n        ",
        "tags": [
          "solidity",
          "difficulty-intermediate"
        ],
        "order": 14
      },
      {
        "title": "What is ERC-20?",
        "answer": "\n            <p><strong>ERC-20</strong> is the standard interface for fungible tokens on Ethereum.</p>\n            <strong>Required functions:</strong>\n            <pre><code class=\"language-solidity\">interface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}</code></pre>\n            <strong>Key concepts:</strong>\n            <ul>\n                <li><strong>Fungible:</strong> Each token is identical and interchangeable</li>\n                <li><strong>Approve/TransferFrom:</strong> Allows delegated transfers</li>\n                <li><strong>Examples:</strong> USDC, LINK, UNI, AAVE</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "erc20",
          "difficulty-intermediate"
        ],
        "order": 15
      },
      {
        "title": "What is ERC-721?",
        "answer": "\n            <p><strong>ERC-721</strong> is the standard for non-fungible tokens (NFTs) on Ethereum.</p>\n            <strong>Key functions:</strong>\n            <pre><code class=\"language-solidity\">interface IERC721 {\n    function balanceOf(address owner) external view returns (uint256);\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}</code></pre>\n            <strong>Key concepts:</strong>\n            <ul>\n                <li>Each token has a unique tokenId</li>\n                <li>Non-fungible: Each token is unique</li>\n                <li>Often includes tokenURI for metadata</li>\n                <li><strong>Examples:</strong> CryptoPunks, BAYC, Art Blocks</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "nft",
          "difficulty-intermediate"
        ],
        "order": 16
      },
      {
        "title": "What is ERC-1155?",
        "answer": "\n            <p><strong>ERC-1155</strong> is a multi-token standard that supports both fungible and non-fungible tokens in a single contract.</p>\n            <pre><code class=\"language-solidity\">interface IERC1155 {\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) \n        external view returns (uint256[] memory);\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n    function safeBatchTransferFrom(\n        address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data\n    ) external;\n}</code></pre>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Single contract for multiple token types</li>\n                <li>Batch transfers (gas efficient)</li>\n                <li>Supports fungible, non-fungible, and semi-fungible</li>\n                <li>Popular for gaming items</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "nft",
          "difficulty-intermediate"
        ],
        "order": 17
      },
      {
        "title": "What is token approval and allowance?",
        "answer": "\n            <p>The <strong>approve/allowance</strong> pattern allows a spender to transfer tokens on behalf of the owner.</p>\n            <strong>How it works:</strong>\n            <ol>\n                <li>Owner calls approve(spender, amount)</li>\n                <li>Spender can now call transferFrom(owner, recipient, amount)</li>\n                <li>Allowance decreases by transferred amount</li>\n            </ol>\n            <pre><code class=\"language-solidity\">// User approves Uniswap to spend 100 USDC\nusdc.approve(uniswapRouter, 100 * 10**6);\n\n// Uniswap can now transfer user's USDC\nusdc.transferFrom(user, pool, 100 * 10**6);</code></pre>\n            <strong>Security concerns:</strong>\n            <ul>\n                <li>Infinite approvals are risky</li>\n                <li>Approve to 0 before setting new amount</li>\n                <li>Use increaseAllowance/decreaseAllowance when available</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "erc20",
          "difficulty-intermediate"
        ],
        "order": 18
      },
      {
        "title": "What is ERC-4626?",
        "answer": "\n            <p><strong>ERC-4626</strong> is the tokenized vault standard for yield-bearing tokens.</p>\n            <pre><code class=\"language-solidity\">interface IERC4626 is IERC20 {\n    function asset() external view returns (address);\n    function totalAssets() external view returns (uint256);\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n    function convertToShares(uint256 assets) external view returns (uint256);\n    function convertToAssets(uint256 shares) external view returns (uint256);\n}</code></pre>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Yield aggregators (Yearn vaults)</li>\n                <li>Lending protocols (aTokens, cTokens)</li>\n                <li>Staking derivatives</li>\n                <li>Composable DeFi integrations</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "defi",
          "difficulty-intermediate"
        ],
        "order": 19
      },
      {
        "title": "What is token minting and burning?",
        "answer": "\n            <p><strong>Minting</strong> creates new tokens, while <strong>burning</strong> permanently removes tokens from circulation.</p>\n            <pre><code class=\"language-solidity\">contract Token is ERC20 {\n    address public minter;\n    \n    function mint(address to, uint256 amount) external {\n        require(msg.sender == minter, \"Not minter\");\n        _mint(to, amount); // Creates new tokens\n    }\n    \n    function burn(uint256 amount) external {\n        _burn(msg.sender, amount); // Destroys tokens\n    }\n}</code></pre>\n            <strong>Use cases:</strong>\n            <ul>\n                <li><strong>Minting:</strong> Token rewards, initial distribution, bridging</li>\n                <li><strong>Burning:</strong> Fee burns (EIP-1559), buybacks, deflationary mechanisms</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "difficulty-intermediate"
        ],
        "order": 20
      },
      {
        "title": "What are wrapped tokens?",
        "answer": "\n            <p><strong>Wrapped tokens</strong> are tokens that represent another asset at a 1:1 ratio, making them compatible with different protocols or chains.</p>\n            <strong>Examples:</strong>\n            <ul>\n                <li><strong>WETH:</strong> Wrapped Ether (ETH â†’ ERC-20)</li>\n                <li><strong>WBTC:</strong> Wrapped Bitcoin (BTC on Ethereum)</li>\n                <li><strong>stETH:</strong> Wrapped staked ETH</li>\n            </ul>\n            <pre><code class=\"language-solidity\">contract WETH {\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n    }\n    \n    function withdraw(uint256 amount) public {\n        require(balanceOf[msg.sender] >= amount);\n        balanceOf[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n}</code></pre>\n            <strong>Why wrap?</strong> ETH isn't ERC-20 compliant, so WETH allows ETH to be used in DeFi\n        ",
        "tags": [
          "tokens",
          "defi",
          "difficulty-intermediate"
        ],
        "order": 21
      },
      {
        "title": "What is a token URI and metadata?",
        "answer": "\n            <p><strong>Token URI</strong> points to metadata describing an NFT (image, attributes, description).</p>\n            <pre><code class=\"language-solidity\">function tokenURI(uint256 tokenId) public view returns (string memory) {\n    return string(abi.encodePacked(baseURI, tokenId.toString(), \".json\"));\n}</code></pre>\n            <strong>Metadata JSON format:</strong>\n            <pre><code class=\"language-json\">{\n    \"name\": \"Cool NFT #123\",\n    \"description\": \"A very cool NFT\",\n    \"image\": \"ipfs://Qm.../123.png\",\n    \"attributes\": [\n        {\"trait_type\": \"Background\", \"value\": \"Blue\"},\n        {\"trait_type\": \"Rarity\", \"value\": \"Rare\"}\n    ]\n}</code></pre>\n            <strong>Storage options:</strong>\n            <ul>\n                <li>IPFS (decentralized, immutable)</li>\n                <li>Arweave (permanent storage)</li>\n                <li>On-chain (expensive but fully decentralized)</li>\n                <li>Centralized servers (not recommended)</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "nft",
          "difficulty-intermediate"
        ],
        "order": 22
      },
      {
        "title": "What is ERC-2981 (NFT Royalties)?",
        "answer": "\n            <p><strong>ERC-2981</strong> is a standard for NFT royalty information, allowing creators to receive a percentage of secondary sales.</p>\n            <pre><code class=\"language-solidity\">interface IERC2981 {\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) \n        external view returns (address receiver, uint256 royaltyAmount);\n}\n\ncontract NFT is ERC721, ERC2981 {\n    constructor() {\n        _setDefaultRoyalty(msg.sender, 500); // 5% royalty\n    }\n}</code></pre>\n            <strong>Key points:</strong>\n            <ul>\n                <li>Returns royalty recipient and amount</li>\n                <li>Not enforced on-chain (marketplace must honor)</li>\n                <li>Typically 2.5-10% of sale price</li>\n                <li>Supported by OpenSea, Rarible, etc.</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "nft",
          "difficulty-intermediate"
        ],
        "order": 23
      },
      {
        "title": "What is a soulbound token (SBT)?",
        "answer": "\n            <p><strong>Soulbound tokens</strong> are non-transferable tokens that represent identity, credentials, or achievements.</p>\n            <pre><code class=\"language-solidity\">contract SoulboundToken is ERC721 {\n    error SoulboundTransferDisabled();\n    \n    function _beforeTokenTransfer(\n        address from, address to, uint256 tokenId\n    ) internal override {\n        // Allow minting (from = 0) but not transfers\n        if (from != address(0)) {\n            revert SoulboundTransferDisabled();\n        }\n    }\n}</code></pre>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Educational credentials and certifications</li>\n                <li>Proof of attendance (POAPs)</li>\n                <li>Reputation and identity</li>\n                <li>DAO membership badges</li>\n                <li>Credit scores and trust</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "difficulty-intermediate"
        ],
        "order": 24
      },
      {
        "title": "What is DeFi (Decentralized Finance)?",
        "answer": "\n            <p><strong>DeFi</strong> is a financial system built on blockchain that provides traditional financial services without intermediaries.</p>\n            <strong>Key characteristics:</strong>\n            <ul>\n                <li><strong>Permissionless:</strong> Anyone can participate</li>\n                <li><strong>Transparent:</strong> All code and transactions visible</li>\n                <li><strong>Composable:</strong> Protocols can be combined (money legos)</li>\n                <li><strong>Non-custodial:</strong> Users maintain control of funds</li>\n            </ul>\n            <strong>DeFi categories:</strong>\n            <ul>\n                <li>Decentralized Exchanges (Uniswap, Curve)</li>\n                <li>Lending/Borrowing (Aave, Compound)</li>\n                <li>Yield Aggregators (Yearn)</li>\n                <li>Derivatives (dYdX, GMX)</li>\n                <li>Stablecoins (MakerDAO, Frax)</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "difficulty-intermediate"
        ],
        "order": 25
      },
      {
        "title": "What is a DEX (Decentralized Exchange)?",
        "answer": "\n            <p>A <strong>DEX</strong> is a peer-to-peer marketplace for trading cryptocurrencies without a central authority.</p>\n            <strong>Types of DEXs:</strong>\n            <ul>\n                <li><strong>AMM (Automated Market Maker):</strong> Uniswap, Curve, Balancer</li>\n                <li><strong>Order Book:</strong> dYdX, Serum</li>\n                <li><strong>Aggregators:</strong> 1inch, Paraswap</li>\n            </ul>\n            <strong>How AMMs work:</strong>\n            <ul>\n                <li>Liquidity providers deposit token pairs into pools</li>\n                <li>Traders swap against these pools</li>\n                <li>Prices determined by mathematical formula</li>\n                <li>LPs earn fees from trades</li>\n            </ul>\n            <strong>DEX vs CEX:</strong>\n            <table>\n                <tr><th>Aspect</th><th>DEX</th><th>CEX</th></tr>\n                <tr><td>Custody</td><td>Non-custodial</td><td>Custodial</td></tr>\n                <tr><td>KYC</td><td>None</td><td>Required</td></tr>\n                <tr><td>Speed</td><td>Blockchain speed</td><td>Instant</td></tr>\n            </table>\n        ",
        "tags": [
          "defi",
          "dex",
          "difficulty-intermediate"
        ],
        "order": 26
      },
      {
        "title": "What is an AMM (Automated Market Maker)?",
        "answer": "\n            <p>An <strong>AMM</strong> is a type of DEX that uses mathematical formulas to price assets instead of order books.</p>\n            <strong>Constant Product Formula (Uniswap v2):</strong>\n            <pre><code>x * y = k\n// x = token A reserves\n// y = token B reserves\n// k = constant</code></pre>\n            <strong>How it works:</strong>\n            <ol>\n                <li>Liquidity providers deposit equal value of two tokens</li>\n                <li>Trades change the ratio of tokens in pool</li>\n                <li>Price adjusts based on supply and demand</li>\n                <li>Larger trades have more price impact (slippage)</li>\n            </ol>\n            <strong>Popular AMM designs:</strong>\n            <ul>\n                <li><strong>Uniswap:</strong> Constant product (x*y=k)</li>\n                <li><strong>Curve:</strong> StableSwap (optimized for pegged assets)</li>\n                <li><strong>Balancer:</strong> Weighted pools (any ratio)</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "dex",
          "difficulty-intermediate"
        ],
        "order": 27
      },
      {
        "title": "What is liquidity provision and LP tokens?",
        "answer": "\n            <p><strong>Liquidity provision</strong> is depositing tokens into a DEX pool to enable trading. LPs receive <strong>LP tokens</strong> representing their share.</p>\n            <strong>How it works:</strong>\n            <ol>\n                <li>Deposit equal value of two tokens (e.g., ETH/USDC)</li>\n                <li>Receive LP tokens representing pool share</li>\n                <li>Earn trading fees proportional to share</li>\n                <li>Burn LP tokens to withdraw liquidity + fees</li>\n            </ol>\n            <pre><code class=\"language-solidity\">// Simplified LP token logic\nfunction addLiquidity(uint amountA, uint amountB) external {\n    // Transfer tokens to pool\n    // Mint LP tokens to user\n    uint shares = calculateShares(amountA, amountB);\n    _mint(msg.sender, shares);\n}</code></pre>\n            <strong>Risks:</strong>\n            <ul>\n                <li>Impermanent loss</li>\n                <li>Smart contract risk</li>\n                <li>Token price volatility</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "dex",
          "difficulty-intermediate"
        ],
        "order": 28
      },
      {
        "title": "What is impermanent loss?",
        "answer": "\n            <p><strong>Impermanent loss</strong> occurs when the price of tokens in a liquidity pool changes compared to when you deposited them.</p>\n            <strong>Example:</strong>\n            <ul>\n                <li>Deposit: 1 ETH + 2000 USDC (ETH = $2000)</li>\n                <li>ETH price doubles to $4000</li>\n                <li>Pool rebalances: 0.707 ETH + 2828 USDC</li>\n                <li>If held: 1 ETH + 2000 USDC = $6000</li>\n                <li>In pool: 0.707 ETH + 2828 USDC = $5656</li>\n                <li>Loss: ~5.7%</li>\n            </ul>\n            <strong>Key points:</strong>\n            <ul>\n                <li>Called \"impermanent\" because it reverses if prices return</li>\n                <li>Greater price divergence = greater loss</li>\n                <li>Trading fees may offset the loss</li>\n                <li>Stablecoin pairs have minimal IL</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "dex",
          "difficulty-intermediate"
        ],
        "order": 29
      },
      {
        "title": "What is lending and borrowing in DeFi?",
        "answer": "\n            <p>DeFi <strong>lending protocols</strong> allow users to lend assets to earn interest or borrow against collateral.</p>\n            <strong>How it works:</strong>\n            <ol>\n                <li><strong>Suppliers:</strong> Deposit assets, receive interest-bearing tokens</li>\n                <li><strong>Borrowers:</strong> Deposit collateral, borrow up to a limit</li>\n                <li>Interest rates set algorithmically based on utilization</li>\n                <li>Collateral liquidated if health factor drops too low</li>\n            </ol>\n            <strong>Key metrics:</strong>\n            <ul>\n                <li><strong>LTV (Loan-to-Value):</strong> Max borrow vs collateral</li>\n                <li><strong>Liquidation Threshold:</strong> Point at which liquidation occurs</li>\n                <li><strong>Health Factor:</strong> Risk metric (liquidation if < 1)</li>\n                <li><strong>Utilization Rate:</strong> Borrowed / Total supplied</li>\n            </ul>\n            <strong>Popular protocols:</strong> Aave, Compound, MakerDAO\n        ",
        "tags": [
          "defi",
          "lending",
          "difficulty-intermediate"
        ],
        "order": 30
      },
      {
        "title": "What is collateralization and liquidation?",
        "answer": "\n            <p><strong>Collateralization</strong> is depositing assets to secure a loan. <strong>Liquidation</strong> occurs when collateral value falls below requirements.</p>\n            <strong>Over-collateralization:</strong>\n            <ul>\n                <li>Must deposit more value than you borrow</li>\n                <li>Typical ratio: 150% (borrow $100, need $150 collateral)</li>\n                <li>Protects lenders from defaults</li>\n            </ul>\n            <strong>Liquidation process:</strong>\n            <ol>\n                <li>Collateral value drops below threshold</li>\n                <li>Position becomes eligible for liquidation</li>\n                <li>Liquidator repays debt, receives collateral + bonus</li>\n                <li>Remaining collateral returned to borrower</li>\n            </ol>\n            <pre><code>Health Factor = (Collateral * Liquidation Threshold) / Debt\nIf Health Factor < 1 â†’ Liquidation</code></pre>\n        ",
        "tags": [
          "defi",
          "lending",
          "difficulty-intermediate"
        ],
        "order": 31
      },
      {
        "title": "What is yield farming?",
        "answer": "\n            <p><strong>Yield farming</strong> is the practice of moving crypto between DeFi protocols to maximize returns.</p>\n            <strong>Common strategies:</strong>\n            <ul>\n                <li>Providing liquidity to DEXs for trading fees</li>\n                <li>Lending assets for interest</li>\n                <li>Staking LP tokens for additional rewards</li>\n                <li>Leveraged farming (borrow to farm more)</li>\n            </ul>\n            <strong>Reward sources:</strong>\n            <ul>\n                <li>Trading fees</li>\n                <li>Interest from lending</li>\n                <li>Protocol token incentives</li>\n                <li>Governance rewards</li>\n            </ul>\n            <strong>Risks:</strong>\n            <ul>\n                <li>Impermanent loss</li>\n                <li>Smart contract bugs</li>\n                <li>Token price crashes</li>\n                <li>Rug pulls</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "difficulty-intermediate"
        ],
        "order": 32
      },
      {
        "title": "What is TVL (Total Value Locked)?",
        "answer": "\n            <p><strong>TVL</strong> measures the total value of assets deposited in a DeFi protocol, indicating its size and trust.</p>\n            <strong>What TVL includes:</strong>\n            <ul>\n                <li>Liquidity in DEX pools</li>\n                <li>Collateral in lending protocols</li>\n                <li>Assets in vaults and yield aggregators</li>\n                <li>Staked tokens</li>\n            </ul>\n            <strong>Interpreting TVL:</strong>\n            <ul>\n                <li>Higher TVL = more trusted/used protocol</li>\n                <li>Can be inflated by token prices rising</li>\n                <li>Compare to market cap for valuation</li>\n            </ul>\n            <strong>Top protocols by TVL:</strong> Lido, Aave, MakerDAO, Uniswap\n        ",
        "tags": [
          "defi",
          "metrics",
          "difficulty-intermediate"
        ],
        "order": 33
      },
      {
        "title": "What is a flash loan?",
        "answer": "\n            <p>A <strong>flash loan</strong> is an uncollateralized loan that must be borrowed and repaid within a single transaction.</p>\n            <pre><code class=\"language-solidity\">contract FlashLoanExample {\n    function executeFlashLoan(uint256 amount) external {\n        // 1. Borrow from Aave\n        pool.flashLoan(address(this), token, amount, \"\");\n        // Control returns to executeOperation()\n    }\n    \n    function executeOperation(\n        address asset, uint256 amount, uint256 premium, bytes calldata\n    ) external returns (bool) {\n        // 2. Use the borrowed funds\n        // Arbitrage, liquidation, collateral swap, etc.\n        \n        // 3. Repay loan + fee\n        IERC20(asset).approve(pool, amount + premium);\n        return true;\n    }\n}</code></pre>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Arbitrage opportunities</li>\n                <li>Collateral swaps</li>\n                <li>Self-liquidation</li>\n                <li>One-click leverage</li>\n            </ul>\n            <strong>Risk:</strong> Transaction reverts if loan isn't repaid\n        ",
        "tags": [
          "defi",
          "difficulty-intermediate"
        ],
        "order": 34
      },
      {
        "title": "What is slippage in DeFi?",
        "answer": "\n            <p><strong>Slippage</strong> is the difference between the expected price and the actual execution price of a trade.</p>\n            <strong>Causes:</strong>\n            <ul>\n                <li>Trade size relative to liquidity (price impact)</li>\n                <li>Price movement between submission and execution</li>\n                <li>MEV/frontrunning attacks</li>\n            </ul>\n            <strong>Slippage tolerance:</strong>\n            <pre><code class=\"language-solidity\">// User expects 100 tokens, accepts 1% slippage\nuint256 amountOutMin = expectedAmount * 99 / 100;\nrouter.swapExactTokensForTokens(\n    amountIn, amountOutMin, path, to, deadline\n);</code></pre>\n            <strong>Best practices:</strong>\n            <ul>\n                <li>Set appropriate slippage tolerance (0.5-1% typical)</li>\n                <li>Use DEX aggregators for better prices</li>\n                <li>Split large trades</li>\n                <li>Trade in liquid pools</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "dex",
          "difficulty-intermediate"
        ],
        "order": 35
      },
      {
        "title": "What is a stablecoin and how do they work?",
        "answer": "\n            <p>A <strong>stablecoin</strong> maintains a stable value, usually pegged to USD. Different mechanisms achieve this stability.</p>\n            <strong>Types:</strong>\n            <ul>\n                <li><strong>Fiat-backed (USDC, USDT):</strong> $1 reserve per token</li>\n                <li><strong>Crypto-backed (DAI):</strong> Over-collateralized by crypto</li>\n                <li><strong>Algorithmic (FRAX):</strong> Uses algorithms + partial collateral</li>\n            </ul>\n            <strong>DAI mechanism:</strong>\n            <ol>\n                <li>Deposit ETH as collateral (150% min)</li>\n                <li>Borrow DAI against collateral</li>\n                <li>If collateral drops, position liquidated</li>\n                <li>Stability fees maintain peg</li>\n            </ol>\n            <strong>Risks:</strong>\n            <ul>\n                <li>Depegging events</li>\n                <li>Counterparty risk (fiat-backed)</li>\n                <li>Collateral volatility (crypto-backed)</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "stablecoin",
          "difficulty-intermediate"
        ],
        "order": 36
      },
      {
        "title": "What is a DAO (Decentralized Autonomous Organization)?",
        "answer": "\n            <p>A <strong>DAO</strong> is an organization governed by smart contracts and token holder votes rather than traditional management.</p>\n            <strong>Governance process:</strong>\n            <ol>\n                <li>Token holders create proposals</li>\n                <li>Community discusses and votes</li>\n                <li>If passed, proposal executed on-chain</li>\n            </ol>\n            <pre><code class=\"language-solidity\">contract DAO {\n    function propose(address target, bytes calldata data) external {\n        require(token.balanceOf(msg.sender) >= proposalThreshold);\n        proposals[proposalId] = Proposal(target, data);\n    }\n    \n    function vote(uint256 proposalId, bool support) external {\n        uint256 weight = token.balanceOf(msg.sender);\n        proposals[proposalId].votes += support ? weight : -weight;\n    }\n    \n    function execute(uint256 proposalId) external {\n        require(proposals[proposalId].votes > quorum);\n        target.call(proposals[proposalId].data);\n    }\n}</code></pre>\n            <strong>Examples:</strong> MakerDAO, Uniswap, Aave, Compound\n        ",
        "tags": [
          "defi",
          "governance",
          "difficulty-intermediate"
        ],
        "order": 37
      },
      {
        "title": "What is a governance token?",
        "answer": "\n            <p>A <strong>governance token</strong> gives holders voting power over protocol decisions.</p>\n            <strong>Rights typically include:</strong>\n            <ul>\n                <li>Voting on protocol upgrades</li>\n                <li>Parameter changes (fees, rates)</li>\n                <li>Treasury allocation</li>\n                <li>Adding new features or assets</li>\n            </ul>\n            <strong>Popular governance tokens:</strong>\n            <ul>\n                <li><strong>UNI:</strong> Uniswap governance</li>\n                <li><strong>AAVE:</strong> Aave lending protocol</li>\n                <li><strong>MKR:</strong> MakerDAO governance</li>\n                <li><strong>COMP:</strong> Compound governance</li>\n            </ul>\n            <strong>Vote delegation:</strong> Many protocols allow delegating voting power to others\n        ",
        "tags": [
          "defi",
          "governance",
          "difficulty-intermediate"
        ],
        "order": 38
      },
      {
        "title": "What is a liquidity pool?",
        "answer": "\n            <p>A <strong>liquidity pool</strong> is a smart contract containing locked tokens that facilitate trading on a DEX.</p>\n            <strong>Components:</strong>\n            <ul>\n                <li>Token pair (e.g., ETH/USDC)</li>\n                <li>Reserves of each token</li>\n                <li>Pricing algorithm</li>\n                <li>LP token for tracking ownership</li>\n            </ul>\n            <pre><code class=\"language-solidity\">contract LiquidityPool {\n    uint256 public reserveA;\n    uint256 public reserveB;\n    \n    function swap(address tokenIn, uint256 amountIn) external {\n        // Calculate output using constant product formula\n        uint256 amountOut = getAmountOut(amountIn, reserveA, reserveB);\n        // Update reserves and transfer tokens\n    }\n    \n    function getAmountOut(uint256 amountIn, uint256 resIn, uint256 resOut) \n        internal pure returns (uint256) {\n        uint256 amountInWithFee = amountIn * 997; // 0.3% fee\n        return (amountInWithFee * resOut) / (resIn * 1000 + amountInWithFee);\n    }\n}</code></pre>\n        ",
        "tags": [
          "defi",
          "dex",
          "difficulty-intermediate"
        ],
        "order": 39
      },
      {
        "title": "What is Hardhat?",
        "answer": "\n            <p><strong>Hardhat</strong> is a popular Ethereum development environment for compiling, testing, and deploying smart contracts.</p>\n            <strong>Key features:</strong>\n            <ul>\n                <li>Local Ethereum network for testing</li>\n                <li>Built-in Solidity compiler</li>\n                <li>Debugging with console.log</li>\n                <li>Plugin ecosystem (ethers, waffle, etc.)</li>\n            </ul>\n            <pre><code class=\"language-javascript\">// hardhat.config.js\nmodule.exports = {\n    solidity: \"0.8.19\",\n    networks: {\n        hardhat: {},\n        sepolia: {\n            url: process.env.SEPOLIA_RPC,\n            accounts: [process.env.PRIVATE_KEY]\n        }\n    }\n};\n\n// Deploy script\nasync function main() {\n    const Contract = await ethers.getContractFactory(\"MyContract\");\n    const contract = await Contract.deploy();\n    console.log(\"Deployed to:\", contract.address);\n}</code></pre>\n        ",
        "tags": [
          "development",
          "tools",
          "difficulty-intermediate"
        ],
        "order": 40
      },
      {
        "title": "What is Foundry?",
        "answer": "\n            <p><strong>Foundry</strong> is a fast, portable Ethereum development toolkit written in Rust.</p>\n            <strong>Components:</strong>\n            <ul>\n                <li><strong>Forge:</strong> Testing and building</li>\n                <li><strong>Cast:</strong> CLI for interacting with contracts</li>\n                <li><strong>Anvil:</strong> Local Ethereum node</li>\n                <li><strong>Chisel:</strong> Solidity REPL</li>\n            </ul>\n            <strong>Testing in Solidity:</strong>\n            <pre><code class=\"language-solidity\">contract TokenTest is Test {\n    Token token;\n    \n    function setUp() public {\n        token = new Token();\n    }\n    \n    function testTransfer() public {\n        token.mint(address(this), 100);\n        token.transfer(address(1), 50);\n        assertEq(token.balanceOf(address(1)), 50);\n    }\n    \n    function testFuzz_Transfer(uint256 amount) public {\n        vm.assume(amount <= 100);\n        // Fuzz testing with random inputs\n    }\n}</code></pre>\n        ",
        "tags": [
          "development",
          "tools",
          "difficulty-intermediate"
        ],
        "order": 41
      },
      {
        "title": "What is ethers.js?",
        "answer": "\n            <p><strong>ethers.js</strong> is a JavaScript library for interacting with Ethereum.</p>\n            <pre><code class=\"language-javascript\">import { ethers } from 'ethers';\n\n// Connect to provider\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\n\n// Get signer\nconst signer = provider.getSigner();\n\n// Connect to contract\nconst contract = new ethers.Contract(address, abi, signer);\n\n// Read data\nconst balance = await contract.balanceOf(address);\n\n// Write transaction\nconst tx = await contract.transfer(recipient, amount);\nawait tx.wait(); // Wait for confirmation\n\n// Parse units\nconst oneEth = ethers.utils.parseEther(\"1.0\");\nconst formatted = ethers.utils.formatEther(balance);</code></pre>\n            <strong>Key classes:</strong>\n            <ul>\n                <li><strong>Provider:</strong> Read-only blockchain access</li>\n                <li><strong>Signer:</strong> Can sign transactions</li>\n                <li><strong>Contract:</strong> Interface to smart contracts</li>\n            </ul>\n        ",
        "tags": [
          "development",
          "javascript",
          "difficulty-intermediate"
        ],
        "order": 42
      },
      {
        "title": "What is web3.js vs ethers.js?",
        "answer": "\n            <p>Both are JavaScript libraries for Ethereum, but have different designs.</p>\n            <table>\n                <tr><th>Aspect</th><th>web3.js</th><th>ethers.js</th></tr>\n                <tr><td>Size</td><td>Larger</td><td>Smaller</td></tr>\n                <tr><td>Architecture</td><td>Single object</td><td>Modular (Provider/Signer)</td></tr>\n                <tr><td>TypeScript</td><td>Add-on</td><td>Native</td></tr>\n                <tr><td>Maintenance</td><td>Ethereum Foundation</td><td>Richard Moore</td></tr>\n                <tr><td>ENS</td><td>Manual</td><td>Built-in</td></tr>\n            </table>\n            <strong>ethers.js is generally preferred for:</strong>\n            <ul>\n                <li>Smaller bundle size</li>\n                <li>Better TypeScript support</li>\n                <li>Cleaner API design</li>\n                <li>Built-in ENS and utilities</li>\n            </ul>\n        ",
        "tags": [
          "development",
          "javascript",
          "difficulty-intermediate"
        ],
        "order": 43
      },
      {
        "title": "What is IPFS?",
        "answer": "\n            <p><strong>IPFS</strong> (InterPlanetary File System) is a decentralized storage protocol for storing and sharing files.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Content is addressed by its hash (CID)</li>\n                <li>Same content always has same address</li>\n                <li>Files distributed across network nodes</li>\n                <li>No central server</li>\n            </ul>\n            <strong>Use in Web3:</strong>\n            <ul>\n                <li>NFT metadata and images</li>\n                <li>dApp frontends</li>\n                <li>Document storage</li>\n            </ul>\n            <pre><code>// IPFS URL format\nipfs://QmPK1s3pNYLi9ERiq3BDxKa4XosgWwFRQUydHUtz4YgpqB\n\n// Gateway URL\nhttps://ipfs.io/ipfs/QmPK1s3pNYLi9ERiq3BDxKa4XosgWwFRQUydHUtz4YgpqB</code></pre>\n            <strong>Pinning services:</strong> Pinata, Infura, NFT.Storage\n        ",
        "tags": [
          "storage",
          "decentralized",
          "difficulty-intermediate"
        ],
        "order": 44
      }
    ],
    "advanced": [
      {
        "title": "What are Optimistic Rollups and how do they work?",
        "answer": "\n            <p><strong>Optimistic Rollups</strong> execute transactions off-chain and post data to L1, assuming transactions are valid unless challenged.</p>\n            <strong>How they work:</strong>\n            <pre><code>1. Users submit transactions to L2 sequencer\n2. Sequencer batches and executes transactions\n3. State root posted to L1 contract\n4. 7-day challenge period begins\n5. If no valid fraud proof â†’ finalized\n6. If fraud proven â†’ state reverted, prover rewarded</code></pre>\n            <strong>Fraud proof process:</strong>\n            <ol>\n                <li>Challenger identifies invalid state transition</li>\n                <li>Interactive dispute game begins</li>\n                <li>Binary search to find exact invalid step</li>\n                <li>L1 executes single step to verify</li>\n            </ol>\n            <strong>Examples:</strong> Arbitrum, Optimism, Base\n            <strong>Trade-offs:</strong>\n            <ul>\n                <li>+ EVM compatible</li>\n                <li>+ Lower fees than L1</li>\n                <li>- 7-day withdrawal delay</li>\n                <li>- Sequencer centralization risk</li>\n            </ul>\n        ",
        "tags": [
          "layer2",
          "rollups",
          "difficulty-advanced"
        ],
        "order": 0
      },
      {
        "title": "What are ZK-Rollups and how do they work?",
        "answer": "\n            <p><strong>ZK-Rollups</strong> use zero-knowledge proofs to cryptographically prove transaction validity without revealing details.</p>\n            <strong>How they work:</strong>\n            <pre><code>1. Transactions executed off-chain\n2. Prover generates validity proof (ZK-SNARK/STARK)\n3. Proof + state diff posted to L1\n4. L1 verifier contract validates proof\n5. If valid â†’ state updated immediately\n6. No challenge period needed</code></pre>\n            <strong>Types of ZK proofs:</strong>\n            <table>\n                <tr><th>Type</th><th>Proof Size</th><th>Prover Time</th><th>Trusted Setup</th></tr>\n                <tr><td>SNARK</td><td>Small (~200B)</td><td>Slower</td><td>Required</td></tr>\n                <tr><td>STARK</td><td>Larger (~50KB)</td><td>Faster</td><td>Not required</td></tr>\n            </table>\n            <strong>Examples:</strong> zkSync Era, Starknet, Polygon zkEVM, Scroll\n            <strong>Trade-offs:</strong>\n            <ul>\n                <li>+ Instant finality</li>\n                <li>+ Highest security</li>\n                <li>- Proving is computationally expensive</li>\n                <li>- EVM compatibility challenges</li>\n            </ul>\n        ",
        "tags": [
          "layer2",
          "rollups",
          "zk",
          "difficulty-advanced"
        ],
        "order": 1
      },
      {
        "title": "What is the difference between Optimistic and ZK Rollups?",
        "answer": "\n            <p>Both scale Ethereum but use different approaches to ensure validity.</p>\n            <table>\n                <tr><th>Aspect</th><th>Optimistic</th><th>ZK</th></tr>\n                <tr><td>Validity</td><td>Fraud proofs</td><td>Validity proofs</td></tr>\n                <tr><td>Finality</td><td>7 days</td><td>Minutes (after proof)</td></tr>\n                <tr><td>Withdrawals</td><td>7 day delay</td><td>Fast</td></tr>\n                <tr><td>EVM support</td><td>Full compatibility</td><td>Challenging (zkEVM)</td></tr>\n                <tr><td>Computation</td><td>Minimal off-chain</td><td>Heavy proving</td></tr>\n                <tr><td>Data on L1</td><td>Full tx data</td><td>State diffs only</td></tr>\n            </table>\n            <strong>When to use:</strong>\n            <ul>\n                <li><strong>Optimistic:</strong> General purpose, dApp deployment</li>\n                <li><strong>ZK:</strong> Payments, exchanges, privacy needs</li>\n            </ul>\n        ",
        "tags": [
          "layer2",
          "rollups",
          "difficulty-advanced"
        ],
        "order": 2
      },
      {
        "title": "What is EIP-4844 (Proto-Danksharding)?",
        "answer": "\n            <p><strong>EIP-4844</strong> introduces \"blob\" transactions to dramatically reduce L2 data posting costs.</p>\n            <strong>Key concepts:</strong>\n            <pre><code>// Blob-carrying transaction\n{\n    type: 0x03,\n    maxFeePerBlobGas: ...,\n    blobVersionedHashes: [...],\n    // Blobs attached separately, not in execution\n}\n\n// Blobs:\n// - 128 KB each\n// - Up to 6 per block (initially)\n// - Pruned after ~18 days\n// - Not accessible to EVM</code></pre>\n            <strong>Benefits for L2s:</strong>\n            <ul>\n                <li>10-100x cheaper data availability</li>\n                <li>Separate fee market from execution</li>\n                <li>Path to full Danksharding</li>\n            </ul>\n            <strong>Impact:</strong> L2 fees dropped significantly after Dencun upgrade\n        ",
        "tags": [
          "layer2",
          "ethereum",
          "scaling",
          "difficulty-advanced"
        ],
        "order": 3
      },
      {
        "title": "What is data availability and why does it matter?",
        "answer": "\n            <p><strong>Data availability (DA)</strong> ensures transaction data is accessible to verify state transitions.</p>\n            <strong>Why it matters:</strong>\n            <ul>\n                <li>Without data, can't verify fraud proofs (Optimistic)</li>\n                <li>Can't reconstruct state if sequencer fails</li>\n                <li>Enables trustless withdrawals</li>\n            </ul>\n            <strong>DA solutions:</strong>\n            <table>\n                <tr><th>Solution</th><th>Cost</th><th>Security</th></tr>\n                <tr><td>Ethereum calldata</td><td>High</td><td>Highest</td></tr>\n                <tr><td>Ethereum blobs</td><td>Medium</td><td>High</td></tr>\n                <tr><td>Celestia</td><td>Low</td><td>Own security</td></tr>\n                <tr><td>EigenDA</td><td>Low</td><td>Ethereum restaking</td></tr>\n                <tr><td>DAC (Data Availability Committee)</td><td>Lowest</td><td>Trust assumptions</td></tr>\n            </table>\n            <strong>Trade-off:</strong> Cheaper DA = weaker security guarantees\n        ",
        "tags": [
          "layer2",
          "scaling",
          "difficulty-advanced"
        ],
        "order": 4
      },
      {
        "title": "What is a sequencer and what are its risks?",
        "answer": "\n            <p>A <strong>sequencer</strong> orders and batches transactions on L2 before posting to L1.</p>\n            <strong>Sequencer responsibilities:</strong>\n            <ul>\n                <li>Receive user transactions</li>\n                <li>Order transactions (can extract MEV)</li>\n                <li>Execute and batch transactions</li>\n                <li>Post batches to L1</li>\n            </ul>\n            <strong>Centralization risks:</strong>\n            <ul>\n                <li><strong>Censorship:</strong> Can refuse to include transactions</li>\n                <li><strong>Liveness:</strong> Single point of failure</li>\n                <li><strong>MEV extraction:</strong> Can front-run users</li>\n            </ul>\n            <strong>Mitigations:</strong>\n            <ul>\n                <li><strong>Forced inclusion:</strong> Submit tx directly to L1</li>\n                <li><strong>Decentralized sequencers:</strong> In development</li>\n                <li><strong>Shared sequencing:</strong> Espresso, Astria</li>\n                <li><strong>Based rollups:</strong> L1 validators as sequencers</li>\n            </ul>\n        ",
        "tags": [
          "layer2",
          "rollups",
          "difficulty-advanced"
        ],
        "order": 5
      },
      {
        "title": "What are Validiums and Volitions?",
        "answer": "\n            <p><strong>Validiums</strong> and <strong>Volitions</strong> are scaling solutions with different data availability trade-offs.</p>\n            <strong>Validium:</strong>\n            <ul>\n                <li>Validity proofs (like ZK rollup)</li>\n                <li>Data stored off-chain (DAC)</li>\n                <li>Much cheaper than rollups</li>\n                <li>Weaker security guarantees</li>\n            </ul>\n            <strong>Volition:</strong>\n            <ul>\n                <li>Hybrid: user chooses per-transaction</li>\n                <li>Option for on-chain (rollup mode)</li>\n                <li>Option for off-chain (validium mode)</li>\n                <li>Flexibility vs cost trade-off</li>\n            </ul>\n            <pre><code>// User choice per transaction:\nRollup mode: Higher cost, full security\nValidium mode: Lower cost, DA trust assumptions\n\n// StarkEx, zkSync support this model</code></pre>\n        ",
        "tags": [
          "layer2",
          "scaling",
          "difficulty-advanced"
        ],
        "order": 6
      },
      {
        "title": "What is account abstraction (ERC-4337)?",
        "answer": "\n            <p><strong>Account abstraction</strong> makes smart contracts first-class accounts, enabling advanced wallet features.</p>\n            <strong>ERC-4337 architecture:</strong>\n            <pre><code>UserOperation (not transaction) {\n    sender: smart wallet address,\n    nonce: ...,\n    callData: what to execute,\n    callGasLimit: ...,\n    verificationGasLimit: ...,\n    preVerificationGas: ...,\n    maxFeePerGas: ...,\n    maxPriorityFeePerGas: ...,\n    paymasterAndData: optional sponsor,\n    signature: ...\n}\n\nFlow:\nUser â†’ Bundler â†’ EntryPoint Contract â†’ Wallet Contract</code></pre>\n            <strong>Features enabled:</strong>\n            <ul>\n                <li>Gasless transactions (paymasters)</li>\n                <li>Social recovery</li>\n                <li>Multi-sig built-in</li>\n                <li>Session keys</li>\n                <li>Batch transactions</li>\n                <li>Any signature scheme</li>\n            </ul>\n        ",
        "tags": [
          "layer2",
          "wallets",
          "difficulty-advanced"
        ],
        "order": 7
      },
      {
        "title": "How do state channels work?",
        "answer": "\n            <p><strong>State channels</strong> allow parties to transact off-chain with on-chain settlement only for disputes.</p>\n            <strong>How they work:</strong>\n            <pre><code>1. Open channel: Lock funds in multisig contract\n2. Off-chain: Exchange signed state updates\n3. Each update has incrementing nonce\n4. Either party can submit latest state to chain\n5. Challenge period for disputes\n6. Close: Funds distributed per final state</code></pre>\n            <strong>Lightning Network (Bitcoin):</strong>\n            <ul>\n                <li>Payment channels network</li>\n                <li>HTLCs for multi-hop payments</li>\n                <li>Instant, near-zero fees</li>\n            </ul>\n            <strong>Limitations:</strong>\n            <ul>\n                <li>Need to lock capital</li>\n                <li>Both parties must be online (or watchtowers)</li>\n                <li>Not suitable for general computation</li>\n            </ul>\n        ",
        "tags": [
          "layer2",
          "scaling",
          "difficulty-advanced"
        ],
        "order": 8
      },
      {
        "title": "What is cross-L2 communication?",
        "answer": "\n            <p><strong>Cross-L2 communication</strong> enables transactions between different Layer 2 networks.</p>\n            <strong>Approaches:</strong>\n            <ul>\n                <li><strong>Via L1:</strong> L2A â†’ L1 â†’ L2B (slow, secure)</li>\n                <li><strong>Liquidity networks:</strong> Atomic swaps with LPs</li>\n                <li><strong>Shared sequencing:</strong> Atomic cross-L2 bundles</li>\n                <li><strong>Superchain:</strong> Native interop (Optimism vision)</li>\n            </ul>\n            <strong>Fast bridges:</strong>\n            <pre><code>// Liquidity provider model\n1. User wants to go L2A â†’ L2B\n2. LP has funds on both L2s\n3. User sends to LP on L2A\n4. LP sends to user on L2B\n5. LP rebalances later via slow bridge</code></pre>\n            <strong>Examples:</strong> Across, Hop, Stargate, Connext\n        ",
        "tags": [
          "layer2",
          "bridges",
          "difficulty-advanced"
        ],
        "order": 9
      },
      {
        "title": "What is a Based Rollup?",
        "answer": "\n            <p>A <strong>Based Rollup</strong> uses Ethereum L1 validators as the sequencer instead of a centralized sequencer.</p>\n            <strong>How it works:</strong>\n            <pre><code>Traditional Rollup:\nUser â†’ Centralized Sequencer â†’ L1\n\nBased Rollup:\nUser â†’ L1 Block Proposer â†’ L1\n\nL1 proposers include L2 transactions directly\nNo separate sequencer needed</code></pre>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Inherits L1 liveness and censorship resistance</li>\n                <li>No sequencer centralization</li>\n                <li>L1 economic security from day 1</li>\n                <li>Simpler architecture</li>\n            </ul>\n            <strong>Trade-offs:</strong>\n            <ul>\n                <li>Slower block times (L1 speed)</li>\n                <li>Higher latency for users</li>\n                <li>MEV flows to L1</li>\n            </ul>\n            <strong>Example:</strong> Taiko\n        ",
        "tags": [
          "layer2",
          "rollups",
          "difficulty-advanced"
        ],
        "order": 10
      },
      {
        "title": "What are Plasma chains?",
        "answer": "\n            <p><strong>Plasma</strong> is a scaling framework where child chains periodically commit to the main chain.</p>\n            <strong>How it works:</strong>\n            <pre><code>1. Child chain processes transactions\n2. Merkle root of state committed to L1 periodically\n3. Users can exit with Merkle proof\n4. Challenge period for fraud\n5. Mass exit problem if operator misbehaves</code></pre>\n            <strong>Plasma types:</strong>\n            <ul>\n                <li><strong>Plasma MVP:</strong> Simple UTXO model</li>\n                <li><strong>Plasma Cash:</strong> NFT-like unique tokens</li>\n                <li><strong>Plasma Debit:</strong> Account-based</li>\n            </ul>\n            <strong>Why Plasma lost to Rollups:</strong>\n            <ul>\n                <li>Data availability issues</li>\n                <li>Mass exit problem</li>\n                <li>Complex exit games</li>\n                <li>Doesn't support general smart contracts well</li>\n            </ul>\n        ",
        "tags": [
          "layer2",
          "scaling",
          "difficulty-advanced"
        ],
        "order": 11
      },
      {
        "title": "How do Automated Market Makers (AMMs) work mathematically?",
        "answer": "\n            <p>AMMs use mathematical formulas to determine token prices and enable permissionless trading.</p>\n            <strong>Constant Product (Uniswap V2):</strong>\n            <pre><code>x * y = k\n// x = reserve of token A\n// y = reserve of token B  \n// k = constant (invariant)\n\n// Price of A in terms of B\nPrice = y / x\n\n// For a swap of Î”x tokens A:\nÎ”y = y - (k / (x + Î”x))</code></pre>\n            <strong>Constant Sum:</strong>\n            <pre><code>x + y = k\n// Fixed price, limited use (runs out of tokens)</code></pre>\n            <strong>StableSwap (Curve):</strong>\n            <pre><code>// Combines constant product and constant sum\n// Optimized for assets that should be equal value\nAn^n * sum(xi) + D = ADn^n + D^(n+1) / (n^n * prod(xi))</code></pre>\n            <strong>Concentrated Liquidity (Uniswap V3):</strong>\n            <ul>\n                <li>LPs provide liquidity in price ranges</li>\n                <li>Virtual reserves within each range</li>\n                <li>Tick-based price system</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "amm",
          "difficulty-advanced"
        ],
        "order": 12
      },
      {
        "title": "What is impermanent loss and how is it calculated?",
        "answer": "\n            <p><strong>Impermanent loss (IL)</strong> is the difference between holding tokens in an AMM vs simply holding them.</p>\n            <strong>Formula:</strong>\n            <pre><code>IL = 2 * sqrt(price_ratio) / (1 + price_ratio) - 1\n\n// Where price_ratio = new_price / old_price\n\n// Examples:\n1.25x price change â†’ 0.6% IL\n1.50x price change â†’ 2.0% IL\n2x price change â†’ 5.7% IL  \n3x price change â†’ 13.4% IL\n5x price change â†’ 25.5% IL</code></pre>\n            <strong>Why it happens:</strong>\n            <ul>\n                <li>Arbitrageurs rebalance pool as prices change</li>\n                <li>You end up with more of the depreciated asset</li>\n                <li>Less of the appreciated asset</li>\n            </ul>\n            <strong>Mitigation:</strong>\n            <ul>\n                <li>Provide to correlated pairs</li>\n                <li>Earn enough fees to offset IL</li>\n                <li>Use concentrated liquidity carefully</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "amm",
          "difficulty-advanced"
        ],
        "order": 13
      },
      {
        "title": "How do liquidations work in lending protocols?",
        "answer": "\n            <p><strong>Liquidation</strong> occurs when a borrower's collateral value falls below the required threshold.</p>\n            <strong>Key metrics:</strong>\n            <pre><code>Health Factor = (Collateral Value * Liquidation Threshold) / Debt\n\n// If Health Factor < 1 â†’ Liquidatable\n\nLTV (Loan-to-Value) = Debt / Collateral\nLiquidation Threshold = Max LTV before liquidation\n\n// Example (Aave):\n// ETH: 80% LTV, 82.5% Liquidation Threshold\n// Deposit $10,000 ETH\n// Max borrow: $8,000\n// Liquidation when debt > $8,250 value of collateral</code></pre>\n            <strong>Liquidation process:</strong>\n            <ol>\n                <li>Liquidator repays portion of debt</li>\n                <li>Receives collateral at discount (liquidation bonus)</li>\n                <li>Protocol takes small fee</li>\n                <li>Borrower's position is partially closed</li>\n            </ol>\n            <strong>Liquidation bonus:</strong> Typically 5-15% incentive for liquidators\n        ",
        "tags": [
          "defi",
          "lending",
          "difficulty-advanced"
        ],
        "order": 14
      },
      {
        "title": "What are flash loans and how do they work technically?",
        "answer": "\n            <p><strong>Flash loans</strong> are uncollateralized loans that must be borrowed and repaid within a single transaction.</p>\n            <strong>Technical implementation:</strong>\n            <pre><code class=\"language-solidity\">// Aave Flash Loan\ncontract FlashLoanReceiver is IFlashLoanReceiver {\n    function executeOperation(\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata premiums,\n        address initiator,\n        bytes calldata params\n    ) external override returns (bool) {\n        // 1. You have the borrowed funds here\n        uint256 borrowed = amounts[0];\n        \n        // 2. Do something profitable\n        // - Arbitrage\n        // - Collateral swap\n        // - Self-liquidation\n        \n        // 3. Approve repayment\n        uint256 amountOwed = amounts[0] + premiums[0];\n        IERC20(assets[0]).approve(address(POOL), amountOwed);\n        \n        return true;\n    }\n    \n    function requestFlashLoan(address asset, uint256 amount) external {\n        address[] memory assets = new address[](1);\n        assets[0] = asset;\n        // ... initiate flash loan\n    }\n}</code></pre>\n            <strong>Fees:</strong> Typically 0.05-0.3% of borrowed amount\n        ",
        "tags": [
          "defi",
          "flash-loans",
          "difficulty-advanced"
        ],
        "order": 15
      },
      {
        "title": "What is MEV (Maximal Extractable Value)?",
        "answer": "\n            <p><strong>MEV</strong> is the maximum value that can be extracted from block production beyond standard rewards.</p>\n            <strong>Types of MEV:</strong>\n            <ul>\n                <li><strong>Arbitrage:</strong> Price differences between DEXs</li>\n                <li><strong>Liquidations:</strong> Claiming liquidation bonuses</li>\n                <li><strong>Sandwich attacks:</strong> Front and back-running trades</li>\n                <li><strong>JIT liquidity:</strong> Providing liquidity just for one trade</li>\n            </ul>\n            <strong>MEV supply chain:</strong>\n            <pre><code>Searchers â†’ Builders â†’ Validators\n    â†“           â†“           â†“\nFind MEV    Bundle txs    Include blocks</code></pre>\n            <strong>MEV Protection:</strong>\n            <ul>\n                <li><strong>Flashbots Protect:</strong> Private transaction submission</li>\n                <li><strong>MEV Blocker:</strong> Rebates from backrunning</li>\n                <li><strong>CoW Protocol:</strong> Batch auctions</li>\n            </ul>\n            <strong>Stats:</strong> MEV extraction has exceeded $600M+ on Ethereum\n        ",
        "tags": [
          "mev",
          "defi",
          "difficulty-advanced"
        ],
        "order": 16
      },
      {
        "title": "How do bridges work technically?",
        "answer": "\n            <p><strong>Bridges</strong> transfer assets between blockchains using various trust models.</p>\n            <strong>Lock and Mint Pattern:</strong>\n            <pre><code class=\"language-solidity\">// Source Chain (Lock)\ncontract SourceBridge {\n    function lock(address token, uint256 amount, uint256 destChainId) external {\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        emit Locked(msg.sender, token, amount, destChainId);\n    }\n}\n\n// Destination Chain (Mint)\ncontract DestBridge {\n    function mint(\n        address user, address token, uint256 amount, \n        bytes memory proof\n    ) external {\n        require(verifyProof(proof), \"Invalid proof\");\n        wrappedToken.mint(user, amount);\n    }\n}</code></pre>\n            <strong>Bridge types:</strong>\n            <ul>\n                <li><strong>Trusted:</strong> Multisig validators (fast, centralized)</li>\n                <li><strong>Light client:</strong> Verify proofs on-chain (trustless, expensive)</li>\n                <li><strong>Optimistic:</strong> Fraud proofs with challenge period</li>\n                <li><strong>ZK:</strong> Validity proofs (trustless, complex)</li>\n            </ul>\n            <strong>Risks:</strong> Bridge hacks account for $2B+ in losses\n        ",
        "tags": [
          "bridges",
          "crosschain",
          "difficulty-advanced"
        ],
        "order": 17
      },
      {
        "title": "What are ERC-4626 tokenized vaults?",
        "answer": "\n            <p><strong>ERC-4626</strong> is a standard for tokenized vaults, providing a consistent interface for yield-bearing tokens.</p>\n            <strong>Core functions:</strong>\n            <pre><code class=\"language-solidity\">interface IERC4626 is IERC20 {\n    // Asset info\n    function asset() external view returns (address);\n    function totalAssets() external view returns (uint256);\n    \n    // Deposit/Withdraw\n    function deposit(uint256 assets, address receiver) \n        external returns (uint256 shares);\n    function withdraw(uint256 assets, address receiver, address owner) \n        external returns (uint256 shares);\n    function redeem(uint256 shares, address receiver, address owner) \n        external returns (uint256 assets);\n    \n    // Conversion\n    function convertToShares(uint256 assets) external view returns (uint256);\n    function convertToAssets(uint256 shares) external view returns (uint256);\n    \n    // Preview\n    function previewDeposit(uint256 assets) external view returns (uint256);\n    function previewMint(uint256 shares) external view returns (uint256);\n    function previewWithdraw(uint256 assets) external view returns (uint256);\n    function previewRedeem(uint256 shares) external view returns (uint256);\n}</code></pre>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Composability across DeFi</li>\n                <li>Standardized yield calculation</li>\n                <li>Easier integrations</li>\n            </ul>\n        ",
        "tags": [
          "tokens",
          "defi",
          "difficulty-advanced"
        ],
        "order": 18
      },
      {
        "title": "How do perpetual futures work on-chain?",
        "answer": "\n            <p><strong>Perpetual futures</strong> are derivatives with no expiry that track underlying asset prices via funding rates.</p>\n            <strong>Funding rate mechanism:</strong>\n            <pre><code>// If perp price > spot price:\n// Longs pay shorts â†’ incentivizes shorting â†’ price decreases\n\n// If perp price < spot price:\n// Shorts pay longs â†’ incentivizes longing â†’ price increases\n\nFunding Rate = (Perp Price - Spot Price) / Spot Price * Factor\n// Paid every 8 hours typically</code></pre>\n            <strong>Key components:</strong>\n            <ul>\n                <li><strong>Margin:</strong> Collateral deposited</li>\n                <li><strong>Leverage:</strong> Position size / margin (1x-100x)</li>\n                <li><strong>Liquidation price:</strong> When losses exceed margin</li>\n                <li><strong>Mark price:</strong> Fair price for liquidations</li>\n            </ul>\n            <strong>Protocols:</strong> dYdX, GMX, Perpetual Protocol, Gains Network\n        ",
        "tags": [
          "defi",
          "derivatives",
          "difficulty-advanced"
        ],
        "order": 19
      },
      {
        "title": "What is veTokenomics?",
        "answer": "\n            <p><strong>veTokenomics</strong> (vote-escrowed tokenomics) locks tokens for governance power and rewards.</p>\n            <strong>How it works:</strong>\n            <pre><code>// Lock TOKEN for 1-4 years\n// Receive veTOKEN based on lock duration\n\nveTOKEN = TOKEN * (lock_duration / max_duration)\n\n// 100 TOKEN locked for 4 years = 100 veTOKEN\n// 100 TOKEN locked for 1 year = 25 veTOKEN\n\n// veTOKEN decreases linearly as lock expires</code></pre>\n            <strong>Benefits of veTOKEN:</strong>\n            <ul>\n                <li>Governance voting power</li>\n                <li>Boosted rewards</li>\n                <li>Protocol revenue share</li>\n                <li>Gauge weight voting (direct emissions)</li>\n            </ul>\n            <strong>Examples:</strong>\n            <ul>\n                <li><strong>veCRV:</strong> Curve Finance</li>\n                <li><strong>veBAL:</strong> Balancer</li>\n                <li><strong>veFXS:</strong> Frax</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "governance",
          "tokenomics",
          "difficulty-advanced"
        ],
        "order": 20
      },
      {
        "title": "How do liquidity gauges and bribes work?",
        "answer": "\n            <p><strong>Liquidity gauges</strong> direct token emissions to pools based on governance votes. <strong>Bribes</strong> are incentives to vote for specific pools.</p>\n            <strong>Gauge voting system:</strong>\n            <pre><code>// Each epoch (week), veTOKEN holders vote\n// Votes determine emission distribution\n\nPool A gets 30% of votes â†’ 30% of emissions\nPool B gets 50% of votes â†’ 50% of emissions\nPool C gets 20% of votes â†’ 20% of emissions</code></pre>\n            <strong>Bribe markets:</strong>\n            <ol>\n                <li>Protocols want emissions for their pools</li>\n                <li>They bribe veTOKEN holders to vote for their gauge</li>\n                <li>Voters receive bribes + their regular rewards</li>\n            </ol>\n            <strong>Economics:</strong>\n            <pre><code>// If $1 of bribe directs $2 of emissions\n// ROI for briber: 100%\n// Voter earns bribe + regular APR</code></pre>\n            <strong>Bribe platforms:</strong> Votium, Warden, Hidden Hand\n        ",
        "tags": [
          "defi",
          "governance",
          "difficulty-advanced"
        ],
        "order": 21
      },
      {
        "title": "What are Merkle trees and how are they used in DeFi?",
        "answer": "\n            <p><strong>Merkle trees</strong> are data structures that enable efficient and secure verification of large datasets.</p>\n            <strong>Structure:</strong>\n            <pre><code>        [Root Hash]\n           /    \\\n      [AB]        [CD]\n      /  \\        /  \\\n    [A]  [B]    [C]  [D]\n     â†“    â†“      â†“    â†“\n   Leaf  Leaf  Leaf  Leaf</code></pre>\n            <strong>DeFi applications:</strong>\n            <ul>\n                <li><strong>Airdrops:</strong> Merkle proofs for claiming</li>\n                <li><strong>Rollups:</strong> State roots for verification</li>\n                <li><strong>Whitelist mints:</strong> Prove address is included</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function claim(\n    uint256 index,\n    address account,\n    uint256 amount,\n    bytes32[] calldata merkleProof\n) external {\n    bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), \"Invalid proof\");\n    // Process claim...\n}</code></pre>\n            <strong>Benefits:</strong> O(log n) proof size, O(log n) verification\n        ",
        "tags": [
          "cryptography",
          "defi",
          "difficulty-advanced"
        ],
        "order": 22
      },
      {
        "title": "How does Uniswap V3 concentrated liquidity work?",
        "answer": "\n            <p><strong>Concentrated liquidity</strong> allows LPs to provide liquidity within custom price ranges.</p>\n            <strong>Tick system:</strong>\n            <pre><code>// Price at tick i:\nprice(i) = 1.0001^i\n\n// Tick spacing depends on fee tier:\n// 0.05% fee â†’ 10 tick spacing\n// 0.30% fee â†’ 60 tick spacing\n// 1.00% fee â†’ 200 tick spacing\n\n// Position defined by:\n// - Lower tick\n// - Upper tick  \n// - Liquidity amount</code></pre>\n            <strong>Virtual liquidity:</strong>\n            <ul>\n                <li>Within range: position acts like infinite liquidity</li>\n                <li>Outside range: position is all one token, earns nothing</li>\n                <li>Capital efficiency: up to 4000x vs V2</li>\n            </ul>\n            <strong>LP NFTs:</strong> Each position is a unique NFT with:\n            <ul>\n                <li>Pool address</li>\n                <li>Tick range</li>\n                <li>Liquidity amount</li>\n                <li>Fees earned</li>\n            </ul>\n        ",
        "tags": [
          "defi",
          "amm",
          "difficulty-advanced"
        ],
        "order": 23
      },
      {
        "title": "What is an intent-based trading system?",
        "answer": "\n            <p><strong>Intent-based trading</strong> separates what users want (intent) from how it's executed.</p>\n            <strong>How it works:</strong>\n            <pre><code>// User signs intent (not transaction):\nIntent {\n    sellToken: USDC,\n    buyToken: ETH,\n    sellAmount: 1000,\n    minBuyAmount: 0.5,  // Slippage protection\n    deadline: timestamp,\n    signature: ...\n}\n\n// Solvers compete to fill:\n// - Find best execution path\n// - May use multiple DEXs\n// - Can batch with other intents</code></pre>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>MEV protection (private submission)</li>\n                <li>Better prices (solver competition)</li>\n                <li>Gasless for users (solver pays)</li>\n                <li>Cross-chain capable</li>\n            </ul>\n            <strong>Protocols:</strong> CoW Protocol, UniswapX, 1inch Fusion\n        ",
        "tags": [
          "defi",
          "trading",
          "difficulty-advanced"
        ],
        "order": 24
      },
      {
        "title": "How do options protocols work on-chain?",
        "answer": "\n            <p><strong>On-chain options</strong> provide the right (not obligation) to buy/sell at a strike price.</p>\n            <strong>Option types:</strong>\n            <ul>\n                <li><strong>Call:</strong> Right to buy at strike price</li>\n                <li><strong>Put:</strong> Right to sell at strike price</li>\n                <li><strong>European:</strong> Exercise only at expiry</li>\n                <li><strong>American:</strong> Exercise anytime before expiry</li>\n            </ul>\n            <strong>Pricing (Black-Scholes on-chain is complex):</strong>\n            <pre><code>// Simplified factors:\nOption Price = Intrinsic Value + Time Value\n\nIntrinsic (Call) = max(0, Spot - Strike)\nIntrinsic (Put) = max(0, Strike - Spot)\n\nTime Value depends on:\n- Time to expiry\n- Volatility\n- Interest rates</code></pre>\n            <strong>Collateralization:</strong>\n            <ul>\n                <li>Covered calls: Lock underlying asset</li>\n                <li>Cash-secured puts: Lock strike amount</li>\n                <li>Spreads: Partially collateralized</li>\n            </ul>\n            <strong>Protocols:</strong> Opyn, Dopex, Lyra, Hegic\n        ",
        "tags": [
          "defi",
          "derivatives",
          "difficulty-advanced"
        ],
        "order": 25
      },
      {
        "title": "What are zero-knowledge proofs and how do they work?",
        "answer": "\n            <p><strong>Zero-knowledge proofs (ZKPs)</strong> allow proving a statement is true without revealing any information beyond the statement's validity.</p>\n            <strong>Properties:</strong>\n            <ul>\n                <li><strong>Completeness:</strong> If statement is true, honest verifier will be convinced</li>\n                <li><strong>Soundness:</strong> If statement is false, no cheating prover can convince verifier</li>\n                <li><strong>Zero-knowledge:</strong> Verifier learns nothing except that statement is true</li>\n            </ul>\n            <strong>Classic example (Ali Baba's cave):</strong>\n            <pre><code>// Peggy wants to prove she knows secret password\n// Without revealing the password\n\n1. Victor waits outside, Peggy enters cave\n2. Cave has two paths meeting at locked door\n3. Victor shouts which path to return from\n4. If Peggy knows password, she can always comply\n5. Repeat many times â†’ convinces Victor</code></pre>\n            <strong>Applications:</strong> Private transactions, identity verification, rollups\n        ",
        "tags": [
          "cryptography",
          "zk",
          "difficulty-advanced"
        ],
        "order": 26
      },
      {
        "title": "What is the difference between SNARKs and STARKs?",
        "answer": "\n            <p><strong>SNARKs</strong> and <strong>STARKs</strong> are two types of zero-knowledge proof systems.</p>\n            <table>\n                <tr><th>Aspect</th><th>SNARK</th><th>STARK</th></tr>\n                <tr><td>Full name</td><td>Succinct Non-interactive ARgument of Knowledge</td><td>Scalable Transparent ARgument of Knowledge</td></tr>\n                <tr><td>Trusted setup</td><td>Required</td><td>Not required</td></tr>\n                <tr><td>Proof size</td><td>~200 bytes</td><td>~50 KB</td></tr>\n                <tr><td>Verification time</td><td>Fast</td><td>Slightly slower</td></tr>\n                <tr><td>Prover time</td><td>Slower</td><td>Faster (scalable)</td></tr>\n                <tr><td>Quantum resistance</td><td>No</td><td>Yes</td></tr>\n                <tr><td>Cryptographic basis</td><td>Elliptic curves</td><td>Hash functions</td></tr>\n            </table>\n            <strong>Use cases:</strong>\n            <ul>\n                <li><strong>SNARKs:</strong> Zcash, zkSync, Polygon zkEVM</li>\n                <li><strong>STARKs:</strong> StarkNet, StarkEx</li>\n            </ul>\n        ",
        "tags": [
          "cryptography",
          "zk",
          "difficulty-advanced"
        ],
        "order": 27
      },
      {
        "title": "What is a trusted setup and why is it needed?",
        "answer": "\n            <p>A <strong>trusted setup</strong> is a ceremony that generates public parameters for SNARK systems.</p>\n            <strong>The problem:</strong>\n            <pre><code>// During setup, \"toxic waste\" is generated\n// If anyone keeps this data, they can:\n// - Create fake proofs\n// - Break the entire system\n\n// Solution: Multi-party computation (MPC)\n1. Many participants contribute randomness\n2. Each destroys their secret\n3. System is secure if ANY ONE participant is honest</code></pre>\n            <strong>Types of setups:</strong>\n            <ul>\n                <li><strong>Per-circuit:</strong> New setup for each program (Groth16)</li>\n                <li><strong>Universal:</strong> One setup for any program (PLONK, Marlin)</li>\n                <li><strong>Transparent:</strong> No trusted setup needed (STARKs)</li>\n            </ul>\n            <strong>Famous ceremonies:</strong>\n            <ul>\n                <li>Zcash Powers of Tau (87 participants)</li>\n                <li>Hermez ceremony (over 100 participants)</li>\n            </ul>\n        ",
        "tags": [
          "cryptography",
          "zk",
          "difficulty-advanced"
        ],
        "order": 28
      },
      {
        "title": "How do zk-SNARKs work at a high level?",
        "answer": "\n            <p><strong>zk-SNARKs</strong> convert computational problems into polynomial equations that can be verified efficiently.</p>\n            <strong>Pipeline:</strong>\n            <pre><code>1. COMPUTATION â†’ Write program logic\n   â†“\n2. ARITHMETIC CIRCUIT â†’ Gates and wires\n   â†“\n3. R1CS â†’ Rank-1 Constraint System (equations)\n   â†“\n4. QAP â†’ Quadratic Arithmetic Program (polynomials)\n   â†“\n5. PROOF â†’ Elliptic curve cryptography\n   â†“\n6. VERIFY â†’ Check polynomial relationships</code></pre>\n            <strong>Key insight:</strong>\n            <ul>\n                <li>Polynomials are used because they have useful properties</li>\n                <li>Two different polynomials rarely intersect</li>\n                <li>Checking at random point is sufficient</li>\n            </ul>\n            <strong>Prover work:</strong> O(n log n) - must process entire computation\n            <strong>Verifier work:</strong> O(1) - constant time regardless of computation size\n        ",
        "tags": [
          "cryptography",
          "zk",
          "difficulty-advanced"
        ],
        "order": 29
      },
      {
        "title": "What is Circom and how is it used?",
        "answer": "\n            <p><strong>Circom</strong> is a domain-specific language for writing arithmetic circuits for ZK proofs.</p>\n            <strong>Example circuit:</strong>\n            <pre><code class=\"language-javascript\">pragma circom 2.0.0;\n\ntemplate Multiplier() {\n    signal input a;\n    signal input b;\n    signal output c;\n    \n    c <== a * b;  // Constraint: c must equal a * b\n}\n\ntemplate ProveSolution() {\n    signal input x;      // Private input\n    signal output hash;  // Public output\n    \n    component hasher = Poseidon(1);\n    hasher.inputs[0] <== x;\n    hash <== hasher.out;\n    \n    // Proves: \"I know x such that Poseidon(x) = hash\"\n}\n\ncomponent main = ProveSolution();</code></pre>\n            <strong>Workflow:</strong>\n            <ol>\n                <li>Write circuit in Circom</li>\n                <li>Compile to R1CS + WASM</li>\n                <li>Generate proving/verification keys</li>\n                <li>Create proofs with snarkjs</li>\n                <li>Verify on-chain with Solidity verifier</li>\n            </ol>\n        ",
        "tags": [
          "cryptography",
          "zk",
          "development",
          "difficulty-advanced"
        ],
        "order": 30
      },
      {
        "title": "What is the difference between PLONK and Groth16?",
        "answer": "\n            <p><strong>Groth16</strong> and <strong>PLONK</strong> are different proving systems with distinct trade-offs.</p>\n            <table>\n                <tr><th>Aspect</th><th>Groth16</th><th>PLONK</th></tr>\n                <tr><td>Trusted setup</td><td>Per circuit</td><td>Universal</td></tr>\n                <tr><td>Proof size</td><td>~200 bytes (smallest)</td><td>~400 bytes</td></tr>\n                <tr><td>Verification</td><td>Fastest</td><td>Fast</td></tr>\n                <tr><td>Prover time</td><td>Slow</td><td>Moderate</td></tr>\n                <tr><td>Flexibility</td><td>Fixed circuit</td><td>Any circuit</td></tr>\n            </table>\n            <strong>When to use:</strong>\n            <ul>\n                <li><strong>Groth16:</strong> Single, fixed application (Zcash)</li>\n                <li><strong>PLONK:</strong> General purpose, upgradeable systems</li>\n            </ul>\n            <strong>PLONK variants:</strong> TurboPLONK, UltraPLONK, HyperPLONK\n        ",
        "tags": [
          "cryptography",
          "zk",
          "difficulty-advanced"
        ],
        "order": 31
      },
      {
        "title": "What is recursive proof composition?",
        "answer": "\n            <p><strong>Recursive proofs</strong> allow a proof to verify other proofs, enabling unlimited scalability.</p>\n            <strong>How it works:</strong>\n            <pre><code>// Instead of verifying each proof individually:\nProof1 + Proof2 + Proof3 + ... + ProofN\n\n// Create proof that verifies proofs:\nRecursiveProof = prove(\n    \"Proof1 is valid\" AND \n    \"Proof2 is valid\" AND\n    ...\n)\n\n// Can nest further:\nFinalProof = prove(\"RecursiveProof is valid\")</code></pre>\n            <strong>Applications:</strong>\n            <ul>\n                <li><strong>Rollup aggregation:</strong> One proof for thousands of txs</li>\n                <li><strong>Incremental computation:</strong> Verify ongoing process</li>\n                <li><strong>Proof compression:</strong> Reduce on-chain verification</li>\n            </ul>\n            <strong>Challenge:</strong> Verifying SNARK inside SNARK is expensive\n            <strong>Solution:</strong> Cycle of curves (Pasta curves, used by Mina)\n        ",
        "tags": [
          "cryptography",
          "zk",
          "difficulty-advanced"
        ],
        "order": 32
      },
      {
        "title": "What is KZG polynomial commitment?",
        "answer": "\n            <p><strong>KZG</strong> (Kate-Zaverucha-Goldberg) is a polynomial commitment scheme used in many ZK systems.</p>\n            <strong>How it works:</strong>\n            <pre><code>// Commitment\n1. Have polynomial P(x)\n2. Commit: C = [P(Ï„)]â‚ (evaluate at secret Ï„ in elliptic curve group)\n3. Commitment is single group element (48 bytes)\n\n// Opening\nTo prove P(z) = y:\n1. Compute quotient polynomial Q(x) = (P(x) - y) / (x - z)\n2. Proof: Ï€ = [Q(Ï„)]â‚\n3. Verify using pairing: e(C - [y]â‚, [1]â‚‚) = e(Ï€, [Ï„ - z]â‚‚)</code></pre>\n            <strong>Properties:</strong>\n            <ul>\n                <li>Constant size commitment (48 bytes)</li>\n                <li>Constant size proofs</li>\n                <li>Requires trusted setup</li>\n            </ul>\n            <strong>Used in:</strong> EIP-4844 blobs, PLONK, Ethereum's future data sharding\n        ",
        "tags": [
          "cryptography",
          "difficulty-advanced"
        ],
        "order": 33
      },
      {
        "title": "What is elliptic curve cryptography in blockchain?",
        "answer": "\n            <p><strong>Elliptic curve cryptography (ECC)</strong> provides the mathematical foundation for blockchain signatures and addresses.</p>\n            <strong>Curve equation:</strong>\n            <pre><code>yÂ² = xÂ³ + ax + b (mod p)\n\n// secp256k1 (Bitcoin, Ethereum):\nyÂ² = xÂ³ + 7 (mod p)\np = 2Â²âµâ¶ - 2Â³Â² - 977</code></pre>\n            <strong>Key generation:</strong>\n            <pre><code>1. Private key: Random 256-bit number (k)\n2. Public key: k Ã— G (scalar multiplication)\n   where G is generator point\n3. Address: Hash of public key</code></pre>\n            <strong>ECDSA Signature:</strong>\n            <pre><code>Sign(message, privateKey):\n1. Hash message â†’ z\n2. Pick random k\n3. R = k Ã— G\n4. r = R.x mod n\n5. s = kâ»Â¹(z + r Ã— privateKey) mod n\n6. Signature = (r, s)</code></pre>\n            <strong>Why ECC:</strong> Same security as RSA with much smaller keys\n        ",
        "tags": [
          "cryptography",
          "difficulty-advanced"
        ],
        "order": 34
      },
      {
        "title": "What is BLS signature aggregation?",
        "answer": "\n            <p><strong>BLS signatures</strong> (Boneh-Lynn-Shacham) allow multiple signatures to be aggregated into one.</p>\n            <strong>Key benefit:</strong>\n            <pre><code>// Traditional (n signatures):\nVerify(sigâ‚, pkâ‚, msg) AND Verify(sigâ‚‚, pkâ‚‚, msg) AND ...\n// n separate verifications, n signatures stored\n\n// BLS aggregation:\naggSig = sigâ‚ + sigâ‚‚ + ... + sigâ‚™\nVerify(aggSig, aggPk, msg)\n// ONE verification, ONE signature stored</code></pre>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Uses pairing-friendly curves (BLS12-381)</li>\n                <li>Signatures are curve points</li>\n                <li>Addition of points = signature aggregation</li>\n            </ul>\n            <strong>Used in:</strong>\n            <ul>\n                <li>Ethereum 2.0 consensus (validators)</li>\n                <li>Threshold signatures</li>\n                <li>Multi-signatures</li>\n            </ul>\n            <strong>Trade-off:</strong> Slower than ECDSA for single signatures\n        ",
        "tags": [
          "cryptography",
          "difficulty-advanced"
        ],
        "order": 35
      },
      {
        "title": "What is a commitment scheme?",
        "answer": "\n            <p>A <strong>commitment scheme</strong> allows committing to a value without revealing it, then opening later.</p>\n            <strong>Properties:</strong>\n            <ul>\n                <li><strong>Hiding:</strong> Commitment reveals nothing about value</li>\n                <li><strong>Binding:</strong> Cannot change value after commitment</li>\n            </ul>\n            <strong>Hash commitment:</strong>\n            <pre><code>// Commit\ncommitment = hash(value || salt)\n\n// Open\nreveal(value, salt)\nverify: hash(value || salt) == commitment</code></pre>\n            <strong>Pedersen commitment:</strong>\n            <pre><code>// Commit\nC = vG + rH\n// v = value, r = random blinding factor\n// G, H = generator points\n\n// Homomorphic property:\nCâ‚ + Câ‚‚ = (vâ‚ + vâ‚‚)G + (râ‚ + râ‚‚)H\n// Can add commitments without opening!</code></pre>\n            <strong>Uses:</strong> Voting, sealed-bid auctions, zero-knowledge proofs\n        ",
        "tags": [
          "cryptography",
          "difficulty-advanced"
        ],
        "order": 36
      },
      {
        "title": "What is a Merkle-Patricia Trie?",
        "answer": "\n            <p>The <strong>Merkle-Patricia Trie</strong> is Ethereum's data structure for storing state, combining Merkle trees and Patricia tries.</p>\n            <strong>Structure:</strong>\n            <pre><code>// Node types:\n1. Null node (empty)\n2. Leaf node: [encodedPath, value]\n3. Extension node: [encodedPath, key to next node]\n4. Branch node: [v0...v15, value] (16 children + value)\n\n// Path encoding (hex):\nAddress: 0x123...\nPath through trie follows hex digits</code></pre>\n            <strong>Benefits:</strong>\n            <ul>\n                <li>Cryptographic proof of state</li>\n                <li>Efficient updates (only change affected path)</li>\n                <li>Light client proofs</li>\n            </ul>\n            <strong>Ethereum tries:</strong>\n            <ul>\n                <li>State trie: account data</li>\n                <li>Storage trie: contract storage</li>\n                <li>Transactions trie: block transactions</li>\n                <li>Receipts trie: transaction receipts</li>\n            </ul>\n        ",
        "tags": [
          "cryptography",
          "ethereum",
          "difficulty-advanced"
        ],
        "order": 37
      },
      {
        "title": "What is Shamir's Secret Sharing?",
        "answer": "\n            <p><strong>Shamir's Secret Sharing</strong> splits a secret into n shares where k shares are needed to reconstruct.</p>\n            <strong>How it works:</strong>\n            <pre><code>// (k, n) threshold scheme\n// k shares needed to reconstruct from n total\n\n// Create shares:\n1. Secret = s (constant term)\n2. Create random polynomial of degree k-1:\n   f(x) = s + aâ‚x + aâ‚‚xÂ² + ... + aâ‚–â‚‹â‚xáµâ»Â¹\n3. Shares are points on polynomial:\n   Shareâ‚ = (1, f(1))\n   Shareâ‚‚ = (2, f(2))\n   ...\n\n// Reconstruct:\nUse Lagrange interpolation with any k shares\nto find f(0) = s</code></pre>\n            <strong>Properties:</strong>\n            <ul>\n                <li>k-1 shares reveal nothing about secret</li>\n                <li>Any k shares can reconstruct</li>\n                <li>Information-theoretic security</li>\n            </ul>\n            <strong>Uses:</strong> Multi-party key management, social recovery wallets\n        ",
        "tags": [
          "cryptography",
          "security",
          "difficulty-advanced"
        ],
        "order": 38
      },
      {
        "title": "What is multi-party computation (MPC)?",
        "answer": "\n            <p><strong>Multi-party computation</strong> allows multiple parties to jointly compute a function while keeping inputs private.</p>\n            <strong>Example - MPC Wallet:</strong>\n            <pre><code>// Traditional: Single private key â†’ single point of failure\n// MPC: Key split across multiple parties\n\nSigning with MPC:\n1. Key shares held by: User device, Server, Recovery\n2. To sign, parties run MPC protocol\n3. Each contributes partial signature\n4. Combined into valid signature\n5. No party ever has complete key</code></pre>\n            <strong>Properties:</strong>\n            <ul>\n                <li>No single party learns others' inputs</li>\n                <li>Result is correct even with malicious parties</li>\n                <li>Threshold schemes (t-of-n)</li>\n            </ul>\n            <strong>MPC Wallet providers:</strong> Fireblocks, ZenGo, Coinbase\n            <strong>Trade-offs:</strong> Communication overhead, coordination required\n        ",
        "tags": [
          "cryptography",
          "security",
          "difficulty-advanced"
        ],
        "order": 39
      },
      {
        "title": "How does the EVM execute bytecode?",
        "answer": "\n            <p>The <strong>EVM</strong> is a stack-based virtual machine that executes bytecode instruction by instruction.</p>\n            <strong>Execution model:</strong>\n            <pre><code>// EVM State during execution:\n{\n    stack: [],           // LIFO, max 1024 items\n    memory: bytes,       // Byte-addressable, expandable\n    storage: mapping,    // Persistent key-value store\n    pc: number,          // Program counter\n    gas: number,         // Remaining gas\n    calldata: bytes,     // Input data (read-only)\n    returndata: bytes    // Output from last call\n}\n\n// Execution loop:\nwhile (pc < code.length && gas > 0) {\n    opcode = code[pc]\n    executeOpcode(opcode)\n    pc++\n}</code></pre>\n            <strong>Example bytecode:</strong>\n            <pre><code>// Solidity: return 1 + 2\nPUSH1 0x01  // Push 1 to stack\nPUSH1 0x02  // Push 2 to stack\nADD         // Pop 2 values, push sum (3)\nPUSH1 0x00  // Memory offset\nMSTORE      // Store in memory\nPUSH1 0x20  // Return size (32 bytes)\nPUSH1 0x00  // Return offset\nRETURN      // Return value</code></pre>\n        ",
        "tags": [
          "evm",
          "difficulty-advanced"
        ],
        "order": 40
      },
      {
        "title": "What are the most important EVM opcodes?",
        "answer": "\n            <p>EVM <strong>opcodes</strong> are the low-level instructions that smart contracts execute.</p>\n            <strong>Stack operations:</strong>\n            <pre><code>PUSH1-PUSH32  // Push 1-32 bytes to stack\nPOP           // Remove top item\nDUP1-DUP16    // Duplicate nth item\nSWAP1-SWAP16  // Swap top with nth item</code></pre>\n            <strong>Arithmetic:</strong>\n            <pre><code>ADD, SUB, MUL, DIV    // Basic math\nMOD, EXP              // Modulo, exponent\nADDMOD, MULMOD        // Modular operations\nSIGNEXTEND            // Sign extension</code></pre>\n            <strong>Memory/Storage:</strong>\n            <pre><code>MLOAD, MSTORE, MSTORE8  // Memory (temporary)\nSLOAD, SSTORE           // Storage (persistent)\nCALLDATALOAD           // Read input data\nCODECOPY               // Copy contract code</code></pre>\n            <strong>Control flow:</strong>\n            <pre><code>JUMP, JUMPI    // Unconditional/conditional jump\nJUMPDEST       // Valid jump destination\nREVERT         // Revert with data\nRETURN         // Return with data\nSTOP           // Halt execution</code></pre>\n            <strong>Gas costs vary:</strong> ADD = 3 gas, SSTORE = 20,000 gas (new value)\n        ",
        "tags": [
          "evm",
          "opcodes",
          "difficulty-advanced"
        ],
        "order": 41
      },
      {
        "title": "How does the EVM handle function calls?",
        "answer": "\n            <p>Function calls use a <strong>function selector</strong> (first 4 bytes of keccak256 hash) to route to the correct function.</p>\n            <strong>Function selector:</strong>\n            <pre><code>// Function: transfer(address,uint256)\nselector = keccak256(\"transfer(address,uint256)\")[:4]\n         = 0xa9059cbb\n\n// Calldata structure:\n[4 bytes selector][32 bytes param1][32 bytes param2]...\n0xa9059cbb\n0000000000000000000000001234567890123456789012345678901234567890\n0000000000000000000000000000000000000000000000000000000000000064</code></pre>\n            <strong>Dispatcher pattern (compiled Solidity):</strong>\n            <pre><code>// Pseudo-bytecode\nCALLDATALOAD(0)      // Load first 32 bytes\nSHR(224)             // Right shift to get 4 bytes\nDUP1\nPUSH4 0xa9059cbb     // transfer selector\nEQ\nPUSH2 [transfer_offset]\nJUMPI                // Jump if match\n// ... check other selectors</code></pre>\n            <strong>External vs Internal calls:</strong>\n            <ul>\n                <li>External: CALL opcode, new context</li>\n                <li>Internal: JUMP opcode, same context</li>\n            </ul>\n        ",
        "tags": [
          "evm",
          "solidity",
          "difficulty-advanced"
        ],
        "order": 42
      },
      {
        "title": "What is the EVM memory model?",
        "answer": "\n            <p>EVM <strong>memory</strong> is a byte-addressable, linear array that expands dynamically.</p>\n            <strong>Memory layout:</strong>\n            <pre><code>// Solidity memory layout:\n0x00-0x3f (64 bytes): Scratch space\n0x40-0x5f (32 bytes): Free memory pointer\n0x60-0x7f (32 bytes): Zero slot\n0x80+: Actual memory allocations\n\n// Free memory pointer:\nmload(0x40)  // Get current free memory position\nmstore(0x40, newPtr)  // Update after allocation</code></pre>\n            <strong>Memory expansion cost:</strong>\n            <pre><code>// Gas cost grows quadratically\nmemory_cost = (memory_size_wordsÂ² / 512) + (3 * memory_size_words)\n\n// Accessing memory at offset expands if needed\nMSTORE(offset, value)  // May expand memory</code></pre>\n            <strong>Best practices:</strong>\n            <ul>\n                <li>Memory is cleared between external calls</li>\n                <li>Use memory for temporary calculations</li>\n                <li>Minimize memory expansion</li>\n            </ul>\n        ",
        "tags": [
          "evm",
          "memory",
          "difficulty-advanced"
        ],
        "order": 43
      },
      {
        "title": "How does storage work in the EVM?",
        "answer": "\n            <p>EVM <strong>storage</strong> is a persistent key-value store with 256-bit keys and values.</p>\n            <strong>Storage layout:</strong>\n            <pre><code>// State variables get sequential slots\ncontract Example {\n    uint256 a;        // slot 0\n    uint256 b;        // slot 1\n    uint128 c;        // slot 2 (first 16 bytes)\n    uint128 d;        // slot 2 (next 16 bytes) - PACKED!\n}\n\n// Mappings and arrays:\nmapping(address => uint) balances;\n// balances[addr] stored at: keccak256(addr . slot)\n\nuint[] dynamicArray;\n// Length at slot n\n// Element i at: keccak256(n) + i</code></pre>\n            <strong>Gas costs:</strong>\n            <pre><code>SLOAD:  2100 gas (cold), 100 gas (warm)\nSSTORE: \n  - 0 â†’ non-zero: 20,000 gas\n  - non-zero â†’ non-zero: 2,900 gas\n  - non-zero â†’ 0: 2,900 gas + 4,800 refund</code></pre>\n            <strong>Optimization:</strong> Pack variables, minimize storage writes\n        ",
        "tags": [
          "evm",
          "storage",
          "difficulty-advanced"
        ],
        "order": 44
      },
      {
        "title": "What is the CREATE and CREATE2 difference?",
        "answer": "\n            <p><strong>CREATE</strong> and <strong>CREATE2</strong> are opcodes for deploying contracts with different address derivation.</p>\n            <strong>CREATE:</strong>\n            <pre><code>// Address = keccak256(rlp([sender, nonce]))[12:]\naddress = keccak256(\n    rlp.encode([deployer_address, deployer_nonce])\n)[12:32]\n\n// Address changes with each deployment (nonce increases)\n// Cannot predict address before deployment</code></pre>\n            <strong>CREATE2:</strong>\n            <pre><code>// Address = keccak256(0xff ++ sender ++ salt ++ keccak256(initCode))[12:]\naddress = keccak256(\n    0xff,\n    deployer_address,\n    salt,            // User-provided 32 bytes\n    keccak256(bytecode)\n)[12:32]\n\n// Address is deterministic and predictable\n// Same salt + same code = same address (any chain!)</code></pre>\n            <strong>Use cases for CREATE2:</strong>\n            <ul>\n                <li>Counterfactual deployments</li>\n                <li>Cross-chain same address</li>\n                <li>Factory patterns</li>\n                <li>Upgradeable proxies</li>\n            </ul>\n        ",
        "tags": [
          "evm",
          "deployment",
          "difficulty-advanced"
        ],
        "order": 45
      },
      {
        "title": "How do proxy patterns work at the EVM level?",
        "answer": "\n            <p><strong>Proxy patterns</strong> use DELEGATECALL to execute implementation logic with proxy storage.</p>\n            <strong>Minimal proxy (EIP-1167):</strong>\n            <pre><code>// Clone bytecode (45 bytes)\n3d602d80600a3d3981f3363d3d373d3d3d363d73\n<implementation_address>\n5af43d82803e903d91602b57fd5bf3\n\n// What it does:\n1. Copy calldata to memory\n2. DELEGATECALL to implementation\n3. Copy returndata\n4. Return or revert based on success</code></pre>\n            <strong>Transparent Proxy:</strong>\n            <pre><code>fallback() {\n    if (msg.sender == admin) {\n        // Admin calls go to proxy functions\n        handleAdmin();\n    } else {\n        // User calls delegatecall to implementation\n        delegateToImplementation();\n    }\n}</code></pre>\n            <strong>UUPS (Universal Upgradeable Proxy):</strong>\n            <pre><code>// Upgrade logic in implementation, not proxy\n// Proxy is simpler and cheaper to deploy\nfunction upgradeTo(address newImpl) external {\n    require(msg.sender == owner);\n    StorageSlot.getAddressSlot(IMPL_SLOT).value = newImpl;\n}</code></pre>\n        ",
        "tags": [
          "evm",
          "upgrades",
          "difficulty-advanced"
        ],
        "order": 46
      },
      {
        "title": "What is the EVM call stack and context?",
        "answer": "\n            <p>Each <strong>call</strong> creates a new execution context on the call stack.</p>\n            <strong>Context includes:</strong>\n            <pre><code>CallContext {\n    address: executing contract address,\n    caller: msg.sender,\n    value: msg.value,\n    calldata: input data,\n    gas: available gas,\n    code: bytecode to execute,\n    storage: contract's storage,\n    memory: fresh memory,\n    returndata: empty initially,\n    stack: empty\n}</code></pre>\n            <strong>Call types and context:</strong>\n            <table>\n                <tr><th>Opcode</th><th>Storage</th><th>msg.sender</th><th>msg.value</th></tr>\n                <tr><td>CALL</td><td>Callee's</td><td>Caller</td><td>Can send</td></tr>\n                <tr><td>DELEGATECALL</td><td>Caller's</td><td>Original</td><td>Preserved</td></tr>\n                <tr><td>STATICCALL</td><td>Callee's (read)</td><td>Caller</td><td>0</td></tr>\n                <tr><td>CALLCODE</td><td>Caller's</td><td>Caller</td><td>Can send</td></tr>\n            </table>\n            <strong>Call stack limit:</strong> 1024 depth (causes stack overflow error)\n        ",
        "tags": [
          "evm",
          "difficulty-advanced"
        ],
        "order": 47
      },
      {
        "title": "How does gas metering work in the EVM?",
        "answer": "\n            <p><strong>Gas metering</strong> ensures execution costs are paid and prevents infinite loops.</p>\n            <strong>Gas calculation:</strong>\n            <pre><code>// Transaction gas\ntx_gas = 21000 (base) + calldata_gas + execution_gas\n\n// Calldata gas:\n- Zero byte: 4 gas\n- Non-zero byte: 16 gas\n\n// Execution gas:\n- Each opcode has specific cost\n- Memory expansion adds cost\n- Storage operations are expensive</code></pre>\n            <strong>EIP-1559 gas model:</strong>\n            <pre><code>max_fee = maxFeePerGas * gasLimit\nactual_fee = (baseFee + priorityFee) * gasUsed\n\n// Burned: baseFee * gasUsed\n// To validator: priorityFee * gasUsed\n// Refunded: (gasLimit - gasUsed) * effectiveGasPrice</code></pre>\n            <strong>Gas optimization patterns:</strong>\n            <ul>\n                <li>Short-circuit evaluation</li>\n                <li>Caching storage reads</li>\n                <li>Packing storage variables</li>\n                <li>Using unchecked for safe math</li>\n            </ul>\n        ",
        "tags": [
          "evm",
          "gas",
          "difficulty-advanced"
        ],
        "order": 48
      },
      {
        "title": "What are precompiled contracts?",
        "answer": "\n            <p><strong>Precompiles</strong> are contracts at fixed addresses with native implementations for expensive operations.</p>\n            <strong>Ethereum precompiles (addresses 0x01-0x09):</strong>\n            <pre><code>0x01: ecRecover     - Recover signer from signature\n0x02: SHA256        - SHA-256 hash\n0x03: RIPEMD160     - RIPEMD-160 hash\n0x04: identity      - Data copy\n0x05: modexp        - Modular exponentiation\n0x06: ecAdd         - BN256 curve point addition\n0x07: ecMul         - BN256 curve point multiplication\n0x08: ecPairing     - BN256 pairing check\n0x09: blake2f       - BLAKE2 compression</code></pre>\n            <strong>Usage:</strong>\n            <pre><code class=\"language-solidity\">// ecRecover example\nfunction recoverSigner(bytes32 hash, bytes memory sig) \n    public pure returns (address) \n{\n    (bytes32 r, bytes32 s, uint8 v) = splitSig(sig);\n    // Calls precompile at 0x01\n    return ecrecover(hash, v, r, s);\n}</code></pre>\n            <strong>Why precompiles:</strong>\n            <ul>\n                <li>Much cheaper than EVM implementation</li>\n                <li>Enable cryptographic operations</li>\n                <li>Fixed gas costs</li>\n            </ul>\n        ",
        "tags": [
          "evm",
          "difficulty-advanced"
        ],
        "order": 49
      },
      {
        "title": "How does the EVM handle errors and reverts?",
        "answer": "\n            <p>The EVM has several ways to handle errors and revert state changes.</p>\n            <strong>Error types:</strong>\n            <pre><code>// REVERT opcode\n- Returns remaining gas\n- Can include error data\n- State changes undone\n\n// INVALID opcode / Assert failure\n- Consumes all gas (pre-0.8.0)\n- No error data\n- State changes undone\n\n// Out of gas\n- No return data\n- State changes undone</code></pre>\n            <strong>Error encoding (Solidity 0.8+):</strong>\n            <pre><code class=\"language-solidity\">// String error\nrevert(\"Insufficient balance\");\n// Encoded as: Error(string)\n// 0x08c379a0 + abi.encode(\"Insufficient balance\")\n\n// Custom error\nerror InsufficientBalance(uint256 available, uint256 required);\nrevert InsufficientBalance(100, 200);\n// Encoded as: selector + abi.encode(100, 200)\n\n// Panic codes\nassert(x > 0);  // Panic(uint256)\n// 0x01: Assert failure\n// 0x11: Arithmetic overflow\n// 0x12: Division by zero</code></pre>\n        ",
        "tags": [
          "evm",
          "errors",
          "difficulty-advanced"
        ],
        "order": 50
      },
      {
        "title": "What is EVM bytecode optimization?",
        "answer": "\n            <p><strong>Bytecode optimization</strong> reduces gas costs by minimizing operations and storage access.</p>\n            <strong>Compiler optimizations (solc):</strong>\n            <pre><code>// Optimizer settings\n{\n    \"optimizer\": {\n        \"enabled\": true,\n        \"runs\": 200  // Optimize for ~200 calls\n    }\n}\n\n// runs: trade-off\n// Low runs: smaller bytecode, higher exec cost\n// High runs: larger bytecode, lower exec cost</code></pre>\n            <strong>Manual optimizations:</strong>\n            <pre><code class=\"language-solidity\">// Cache storage reads\nuint256 _balance = balances[user]; // SLOAD once\nrequire(_balance >= amount);\nbalances[user] = _balance - amount;\n\n// Use unchecked for known-safe math\nunchecked {\n    balances[to] += amount; // Skip overflow check\n}\n\n// Short-circuit expensive operations\nrequire(amount > 0 && balances[msg.sender] >= amount);\n\n// Pack structs\nstruct Packed {\n    uint128 a;  // Same slot\n    uint128 b;  // Same slot\n}</code></pre>\n        ",
        "tags": [
          "evm",
          "optimization",
          "difficulty-advanced"
        ],
        "order": 51
      },
      {
        "title": "How do events and logs work at the EVM level?",
        "answer": "\n            <p><strong>Events</strong> emit logs stored in transaction receipts, not contract storage.</p>\n            <strong>Log structure:</strong>\n            <pre><code>Log {\n    address: contract address,\n    topics: [topic0, topic1, topic2, topic3],  // Max 4 topics\n    data: bytes  // Unlimited size\n}\n\n// topic0 = keccak256(event signature)\n// indexed params â†’ topics (max 3)\n// non-indexed params â†’ data</code></pre>\n            <strong>EVM opcodes:</strong>\n            <pre><code>LOG0  // No topics\nLOG1  // 1 topic\nLOG2  // 2 topics\nLOG3  // 3 topics\nLOG4  // 4 topics\n\n// Gas cost: 375 + 375*numTopics + 8*dataSize</code></pre>\n            <strong>Solidity events:</strong>\n            <pre><code class=\"language-solidity\">event Transfer(\n    address indexed from,   // topic1\n    address indexed to,     // topic2\n    uint256 value          // data\n);\n// topic0 = keccak256(\"Transfer(address,address,uint256)\")\n\nemit Transfer(sender, recipient, amount);</code></pre>\n            <strong>Note:</strong> Logs cannot be read by smart contracts, only off-chain\n        ",
        "tags": [
          "evm",
          "events",
          "difficulty-advanced"
        ],
        "order": 52
      },
      {
        "title": "What is a reentrancy attack?",
        "answer": "\n            <p>A <strong>reentrancy attack</strong> occurs when a malicious contract calls back into the calling contract before the first execution is complete.</p>\n            <strong>Vulnerable pattern:</strong>\n            <pre><code class=\"language-solidity\">// VULNERABLE\nfunction withdraw() external {\n    uint256 amount = balances[msg.sender];\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success);\n    balances[msg.sender] = 0; // State updated AFTER external call\n}\n\n// ATTACKER\nreceive() external payable {\n    if (address(target).balance >= 1 ether) {\n        target.withdraw(); // Reenter before balance is set to 0\n    }\n}</code></pre>\n            <strong>Prevention (Checks-Effects-Interactions):</strong>\n            <pre><code class=\"language-solidity\">function withdraw() external {\n    uint256 amount = balances[msg.sender];\n    balances[msg.sender] = 0; // Update state BEFORE external call\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success);\n}</code></pre>\n            <strong>Other mitigations:</strong> ReentrancyGuard modifier, pull payment pattern\n            <strong>Famous exploit:</strong> The DAO hack (2016) - $60M stolen\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 53
      },
      {
        "title": "What is the Checks-Effects-Interactions pattern?",
        "answer": "\n            <p>The <strong>Checks-Effects-Interactions (CEI)</strong> pattern is a best practice for ordering operations in smart contracts to prevent reentrancy.</p>\n            <strong>Pattern order:</strong>\n            <ol>\n                <li><strong>Checks:</strong> Validate all conditions (require, assert)</li>\n                <li><strong>Effects:</strong> Update all state variables</li>\n                <li><strong>Interactions:</strong> External calls last</li>\n            </ol>\n            <pre><code class=\"language-solidity\">function withdraw(uint256 amount) external {\n    // CHECKS\n    require(balances[msg.sender] >= amount, \"Insufficient\");\n    require(amount > 0, \"Zero amount\");\n    \n    // EFFECTS\n    balances[msg.sender] -= amount;\n    totalWithdrawn += amount;\n    \n    // INTERACTIONS\n    (bool success, ) = msg.sender.call{value: amount}(\"\");\n    require(success, \"Transfer failed\");\n}</code></pre>\n            <strong>Why it works:</strong> State is finalized before any external call can re-enter\n        ",
        "tags": [
          "security",
          "patterns",
          "difficulty-advanced"
        ],
        "order": 54
      },
      {
        "title": "What is a flash loan attack?",
        "answer": "\n            <p>A <strong>flash loan attack</strong> exploits protocols using borrowed funds that are returned within one transaction.</p>\n            <strong>Attack flow:</strong>\n            <ol>\n                <li>Borrow large amount via flash loan</li>\n                <li>Manipulate a vulnerable protocol</li>\n                <li>Extract value from manipulation</li>\n                <li>Repay flash loan + fee</li>\n                <li>Keep the profit</li>\n            </ol>\n            <strong>Common attack vectors:</strong>\n            <ul>\n                <li><strong>Oracle manipulation:</strong> Move prices on low-liquidity DEXs</li>\n                <li><strong>Governance attacks:</strong> Borrow tokens to vote</li>\n                <li><strong>Arbitrage exploitation:</strong> Drain vulnerable pools</li>\n            </ul>\n            <strong>Famous attacks:</strong>\n            <ul>\n                <li>bZx (2020): $1M</li>\n                <li>Cream Finance (2021): $130M</li>\n                <li>Euler Finance (2023): $197M</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "defi",
          "difficulty-advanced"
        ],
        "order": 55
      },
      {
        "title": "What is integer overflow/underflow?",
        "answer": "\n            <p><strong>Integer overflow/underflow</strong> occurs when arithmetic operations exceed the variable's bounds.</p>\n            <strong>Pre-Solidity 0.8.0 vulnerability:</strong>\n            <pre><code class=\"language-solidity\">// uint8 max is 255\nuint8 a = 255;\na = a + 1; // Overflows to 0!\n\nuint8 b = 0;\nb = b - 1; // Underflows to 255!</code></pre>\n            <strong>Exploitation example:</strong>\n            <pre><code class=\"language-solidity\">// Vulnerable token transfer\nfunction transfer(address to, uint256 amount) {\n    require(balances[msg.sender] - amount >= 0); // Always true with underflow!\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n}</code></pre>\n            <strong>Solutions:</strong>\n            <ul>\n                <li>Solidity 0.8.0+: Built-in overflow checks (reverts)</li>\n                <li>Pre-0.8.0: Use SafeMath library</li>\n                <li>Use <code>unchecked</code> only when overflow is intended</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 56
      },
      {
        "title": "What is front-running?",
        "answer": "\n            <p><strong>Front-running</strong> is when someone observes a pending transaction and submits their own with higher gas to execute first.</p>\n            <strong>How it works:</strong>\n            <ol>\n                <li>Attacker monitors mempool</li>\n                <li>Sees profitable pending transaction</li>\n                <li>Submits same/similar transaction with higher gas</li>\n                <li>Their transaction executes first</li>\n            </ol>\n            <strong>Common targets:</strong>\n            <ul>\n                <li>DEX trades (sandwich attacks)</li>\n                <li>NFT mints</li>\n                <li>Liquidations</li>\n                <li>Arbitrage opportunities</li>\n            </ul>\n            <strong>Mitigations:</strong>\n            <ul>\n                <li>Commit-reveal schemes</li>\n                <li>Private mempools (Flashbots Protect)</li>\n                <li>Batch auctions (CoW Protocol)</li>\n                <li>Slippage protection</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "mev",
          "difficulty-advanced"
        ],
        "order": 57
      },
      {
        "title": "What is a sandwich attack?",
        "answer": "\n            <p>A <strong>sandwich attack</strong> is a type of front-running where an attacker places transactions before AND after a victim's trade.</p>\n            <strong>Attack sequence:</strong>\n            <ol>\n                <li>Victim submits large buy order</li>\n                <li>Attacker front-runs with a buy (raises price)</li>\n                <li>Victim's trade executes at higher price</li>\n                <li>Attacker back-runs with a sell (profits from price increase)</li>\n            </ol>\n            <pre><code>Block execution order:\n1. Attacker: Buy 100 ETH of Token (price goes up)\n2. Victim: Buy 50 ETH of Token (at higher price)\n3. Attacker: Sell 100 ETH of Token (at even higher price)</code></pre>\n            <strong>Protection:</strong>\n            <ul>\n                <li>Set tight slippage tolerance</li>\n                <li>Use private transactions (Flashbots)</li>\n                <li>Use DEXs with MEV protection</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "mev",
          "difficulty-advanced"
        ],
        "order": 58
      },
      {
        "title": "What is access control vulnerability?",
        "answer": "\n            <p><strong>Access control vulnerabilities</strong> occur when functions can be called by unauthorized users.</p>\n            <strong>Vulnerable patterns:</strong>\n            <pre><code class=\"language-solidity\">// Missing access control\nfunction mint(address to, uint256 amount) external {\n    _mint(to, amount); // Anyone can mint!\n}\n\n// Incorrect modifier logic\nmodifier onlyOwner() {\n    if (msg.sender == owner) {\n        _;\n    }\n    // Doesn't revert if not owner!\n}</code></pre>\n            <strong>Secure implementation:</strong>\n            <pre><code class=\"language-solidity\">modifier onlyOwner() {\n    require(msg.sender == owner, \"Not owner\");\n    _;\n}\n\nfunction mint(address to, uint256 amount) external onlyOwner {\n    _mint(to, amount);\n}</code></pre>\n            <strong>Best practices:</strong>\n            <ul>\n                <li>Use OpenZeppelin's AccessControl or Ownable</li>\n                <li>Implement role-based permissions</li>\n                <li>Always test access control</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 59
      },
      {
        "title": "What is tx.origin vulnerability?",
        "answer": "\n            <p>Using <strong>tx.origin</strong> for authorization is dangerous because it refers to the original transaction sender, not the immediate caller.</p>\n            <strong>Vulnerable pattern:</strong>\n            <pre><code class=\"language-solidity\">// VULNERABLE\nfunction withdraw() external {\n    require(tx.origin == owner, \"Not owner\");\n    payable(owner).transfer(address(this).balance);\n}\n\n// Attack contract\nfunction attack(VulnerableContract target) external {\n    // If owner calls this, tx.origin is still owner\n    target.withdraw(); // Drains funds to attacker\n}</code></pre>\n            <strong>The attack:</strong>\n            <ol>\n                <li>Attacker tricks owner into calling attacker's contract</li>\n                <li>Attacker's contract calls vulnerable function</li>\n                <li>tx.origin is still the owner</li>\n                <li>Authorization check passes</li>\n            </ol>\n            <strong>Solution:</strong> Always use <code>msg.sender</code> for authorization\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 60
      },
      {
        "title": "What is a denial of service (DoS) attack in smart contracts?",
        "answer": "\n            <p>A <strong>DoS attack</strong> makes a contract unusable by exploiting logic that can be blocked.</p>\n            <strong>Common DoS patterns:</strong>\n            <pre><code class=\"language-solidity\">// Vulnerable to DoS - unbounded loop\nfunction distributeRewards() external {\n    for (uint i = 0; i < users.length; i++) {\n        payable(users[i]).transfer(rewards[i]); // Gas limit reached\n    }\n}\n\n// Vulnerable - revert on external call\nfunction claimFirst() external {\n    require(msg.sender == users[0]);\n    (bool success,) = msg.sender.call{value: prize}(\"\");\n    require(success); // Attacker can always revert\n}</code></pre>\n            <strong>Mitigations:</strong>\n            <ul>\n                <li>Pull over push payments</li>\n                <li>Limit loop iterations</li>\n                <li>Allow partial execution</li>\n                <li>Don't require external call success for critical paths</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 61
      },
      {
        "title": "What is a signature replay attack?",
        "answer": "\n            <p>A <strong>signature replay attack</strong> reuses a valid signature to execute unauthorized actions.</p>\n            <strong>Vulnerable pattern:</strong>\n            <pre><code class=\"language-solidity\">// VULNERABLE - no replay protection\nfunction executeWithSignature(\n    address to, uint256 amount, bytes memory signature\n) external {\n    bytes32 hash = keccak256(abi.encodePacked(to, amount));\n    address signer = ECDSA.recover(hash, signature);\n    require(signer == owner);\n    _transfer(to, amount);\n    // Same signature can be used again!\n}</code></pre>\n            <strong>Protected version:</strong>\n            <pre><code class=\"language-solidity\">mapping(bytes32 => bool) public usedHashes;\n\nfunction executeWithSignature(\n    address to, uint256 amount, uint256 nonce, bytes memory signature\n) external {\n    bytes32 hash = keccak256(abi.encodePacked(to, amount, nonce, address(this), block.chainid));\n    require(!usedHashes[hash], \"Already used\");\n    usedHashes[hash] = true;\n    // ... verify and execute\n}</code></pre>\n            <strong>Include in hash:</strong> Nonce, contract address, chain ID\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 62
      },
      {
        "title": "What is oracle manipulation?",
        "answer": "\n            <p><strong>Oracle manipulation</strong> exploits reliance on easily manipulated price sources.</p>\n            <strong>Vulnerable patterns:</strong>\n            <ul>\n                <li>Using spot DEX prices directly</li>\n                <li>Low-liquidity price feeds</li>\n                <li>Single oracle source</li>\n            </ul>\n            <strong>Attack example:</strong>\n            <pre><code class=\"language-solidity\">// VULNERABLE - uses spot price\nfunction getPrice() public view returns (uint256) {\n    (uint112 reserve0, uint112 reserve1,) = pair.getReserves();\n    return reserve1 / reserve0; // Easily manipulated with flash loan\n}\n\n// Attack:\n// 1. Flash loan large amount\n// 2. Swap to skew reserves\n// 3. Call vulnerable function (uses wrong price)\n// 4. Profit and repay flash loan</code></pre>\n            <strong>Mitigations:</strong>\n            <ul>\n                <li>Use time-weighted average prices (TWAP)</li>\n                <li>Use Chainlink decentralized oracles</li>\n                <li>Multiple oracle sources</li>\n                <li>Circuit breakers for extreme price moves</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "oracles",
          "defi",
          "difficulty-advanced"
        ],
        "order": 63
      },
      {
        "title": "What is storage collision in proxy contracts?",
        "answer": "\n            <p><strong>Storage collision</strong> occurs when a proxy and implementation contract use the same storage slot for different variables.</p>\n            <strong>The problem:</strong>\n            <pre><code class=\"language-solidity\">// Proxy\ncontract Proxy {\n    address public implementation; // Slot 0\n    address public admin;         // Slot 1\n}\n\n// Implementation  \ncontract Token {\n    address public owner;     // Slot 0 - COLLIDES!\n    uint256 public totalSupply; // Slot 1 - COLLIDES!\n}</code></pre>\n            <strong>Solution (EIP-1967 slots):</strong>\n            <pre><code class=\"language-solidity\">// Use specific, calculated slots\nbytes32 constant IMPLEMENTATION_SLOT = \n    bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);\n\nfunction _setImplementation(address impl) internal {\n    StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = impl;\n}</code></pre>\n            <strong>Best practice:</strong> Use OpenZeppelin's transparent or UUPS proxy\n        ",
        "tags": [
          "security",
          "upgrades",
          "difficulty-advanced"
        ],
        "order": 64
      },
      {
        "title": "What is the difference between delegatecall and call?",
        "answer": "\n            <p><strong>call</strong> and <strong>delegatecall</strong> are low-level methods to invoke other contracts, with different execution contexts.</p>\n            <strong>call:</strong>\n            <ul>\n                <li>Executes in the context of the called contract</li>\n                <li>Uses called contract's storage</li>\n                <li>msg.sender is the calling contract</li>\n            </ul>\n            <strong>delegatecall:</strong>\n            <ul>\n                <li>Executes in the context of the calling contract</li>\n                <li>Uses calling contract's storage</li>\n                <li>msg.sender remains the original caller</li>\n            </ul>\n            <pre><code class=\"language-solidity\">// With delegatecall, implementation code modifies proxy storage\ncontract Proxy {\n    address impl;\n    \n    fallback() external payable {\n        (bool success,) = impl.delegatecall(msg.data);\n        require(success);\n    }\n}</code></pre>\n            <strong>Danger:</strong> delegatecall to untrusted code can be catastrophic\n        ",
        "tags": [
          "security",
          "evm",
          "difficulty-advanced"
        ],
        "order": 65
      },
      {
        "title": "What is selfdestruct and its security implications?",
        "answer": "\n            <p><strong>selfdestruct</strong> removes a contract from the blockchain and sends remaining ETH to a specified address.</p>\n            <strong>Security implications:</strong>\n            <pre><code class=\"language-solidity\">contract Vulnerable {\n    uint256 public balance;\n    \n    function deposit() external payable {\n        balance += msg.value;\n    }\n    \n    function getBalance() public view returns (uint256) {\n        return address(this).balance; // Can be forcibly increased!\n    }\n}\n\n// Attack: selfdestruct sends ETH bypassing receive/fallback\ncontract Attacker {\n    function attack(address target) external payable {\n        selfdestruct(payable(target));\n    }\n}</code></pre>\n            <strong>Issues:</strong>\n            <ul>\n                <li>ETH can be force-sent to contracts</li>\n                <li>Can break invariants relying on balance</li>\n                <li>Destroyed contracts can still receive ETH</li>\n            </ul>\n            <strong>Note:</strong> selfdestruct is deprecated (EIP-6049) and behavior may change\n        ",
        "tags": [
          "security",
          "evm",
          "difficulty-advanced"
        ],
        "order": 66
      },
      {
        "title": "What is a griefing attack?",
        "answer": "\n            <p>A <strong>griefing attack</strong> harms others at a cost to the attacker, without direct profit motive.</p>\n            <strong>Examples:</strong>\n            <ul>\n                <li>Always reverting when receiving ETH</li>\n                <li>Filling blocks to prevent others' transactions</li>\n                <li>Voting against all proposals</li>\n                <li>Front-running NFT purchases to cancel sales</li>\n            </ul>\n            <pre><code class=\"language-solidity\">// Griefing: attacker can block withdrawals\ncontract Vulnerable {\n    address[] public winners;\n    \n    function distributeWinnings() external {\n        for (uint i = 0; i < winners.length; i++) {\n            // Attacker adds contract that reverts\n            payable(winners[i]).transfer(prize);\n        }\n    }\n}</code></pre>\n            <strong>Mitigations:</strong>\n            <ul>\n                <li>Pull over push patterns</li>\n                <li>Don't rely on external call success</li>\n                <li>Economic incentives against griefing</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 67
      },
      {
        "title": "What is a time manipulation attack?",
        "answer": "\n            <p><strong>Time manipulation</strong> exploits contracts that rely on block.timestamp for critical logic.</p>\n            <strong>Vulnerable pattern:</strong>\n            <pre><code class=\"language-solidity\">// VULNERABLE - randomness from timestamp\nfunction roll() external payable {\n    require(msg.value == 1 ether);\n    if (block.timestamp % 2 == 0) {\n        payable(msg.sender).transfer(2 ether);\n    }\n}\n\n// VULNERABLE - short time window\nfunction claim() external {\n    require(block.timestamp == deadline); // Miners can manipulate\n    _claim();\n}</code></pre>\n            <strong>Miner manipulation:</strong>\n            <ul>\n                <li>Can adjust timestamp within ~15 second range</li>\n                <li>Can choose not to include transactions</li>\n            </ul>\n            <strong>Best practices:</strong>\n            <ul>\n                <li>Use >= or <= for time comparisons</li>\n                <li>Don't use timestamp for randomness</li>\n                <li>Use block numbers for longer durations</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 68
      },
      {
        "title": "What is the difference between view, pure, and state-changing functions?",
        "answer": "\n            <p>Function modifiers indicate what state a function can access or modify.</p>\n            <strong>Comparison:</strong>\n            <table>\n                <tr><th>Modifier</th><th>Read State</th><th>Modify State</th><th>Gas Cost</th></tr>\n                <tr><td>view</td><td>Yes</td><td>No</td><td>Free (if external call)</td></tr>\n                <tr><td>pure</td><td>No</td><td>No</td><td>Free (if external call)</td></tr>\n                <tr><td>none</td><td>Yes</td><td>Yes</td><td>Costs gas</td></tr>\n            </table>\n            <pre><code class=\"language-solidity\">// View - reads storage\nfunction getBalance(address user) external view returns (uint256) {\n    return balances[user];\n}\n\n// Pure - no state access\nfunction calculateFee(uint256 amount) external pure returns (uint256) {\n    return amount * 3 / 100;\n}\n\n// State-changing\nfunction transfer(address to, uint256 amount) external {\n    balances[msg.sender] -= amount;\n    balances[to] += amount;\n}</code></pre>\n            <strong>Security note:</strong> Marking incorrectly won't save gas but may confuse auditors\n        ",
        "tags": [
          "security",
          "solidity",
          "difficulty-advanced"
        ],
        "order": 69
      },
      {
        "title": "What is uninitialized storage pointer vulnerability?",
        "answer": "\n            <p>An <strong>uninitialized storage pointer</strong> can point to unexpected storage slots, allowing overwrites.</p>\n            <strong>Vulnerable pattern (pre-0.5.0):</strong>\n            <pre><code class=\"language-solidity\">contract Vulnerable {\n    address public owner;\n    \n    function addUser(string memory name) public {\n        User user; // Uninitialized storage pointer!\n        user.name = name; // Overwrites slot 0 (owner)!\n    }\n}</code></pre>\n            <strong>Why it happens:</strong>\n            <ul>\n                <li>Local storage variables default to slot 0</li>\n                <li>Compiler doesn't warn (older versions)</li>\n                <li>Can overwrite critical state</li>\n            </ul>\n            <strong>Modern solution:</strong>\n            <ul>\n                <li>Solidity 0.5.0+ requires explicit memory/storage</li>\n                <li>Always specify data location</li>\n                <li>Initialize variables properly</li>\n            </ul>\n        ",
        "tags": [
          "security",
          "vulnerabilities",
          "difficulty-advanced"
        ],
        "order": 70
      }
    ],
    "projects": [
      {
        "title": "Simple ERC-20 Token",
        "answer": "\n            <p>Create your own fungible token following the ERC-20 standard.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand token standards</li>\n                <li>Learn Solidity basics</li>\n                <li>Deploy to testnet</li>\n                <li>Interact with your contract</li>\n            </ul>\n            <strong>Features to implement:</strong>\n            <ul>\n                <li>totalSupply, balanceOf, transfer</li>\n                <li>approve, transferFrom, allowance</li>\n                <li>Minting function (with access control)</li>\n                <li>Burning function</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, Hardhat/Foundry, ethers.js\n            <strong>Extension:</strong> Add pausable, capped supply, or snapshot features\n        ",
        "tags": [
          "beginner",
          "tokens",
          "solidity"
        ],
        "order": 0
      },
      {
        "title": "Basic NFT Collection",
        "answer": "\n            <p>Build an ERC-721 NFT collection with metadata on IPFS.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand ERC-721 standard</li>\n                <li>Work with IPFS for metadata</li>\n                <li>Implement minting logic</li>\n                <li>Add reveal mechanism</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Mint function with price</li>\n                <li>Max supply limit</li>\n                <li>Base URI for metadata</li>\n                <li>Owner withdrawal function</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, OpenZeppelin, Pinata/NFT.Storage\n            <strong>Extension:</strong> Add whitelist, reveal mechanism, or royalties (ERC-2981)\n        ",
        "tags": [
          "beginner",
          "nft",
          "solidity"
        ],
        "order": 1
      },
      {
        "title": "Crypto Wallet Tracker",
        "answer": "\n            <p>Build a web app that tracks wallet balances and transaction history.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Use blockchain APIs (Etherscan, Alchemy)</li>\n                <li>Parse and display blockchain data</li>\n                <li>Handle multiple networks</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Input any wallet address</li>\n                <li>Show ETH and token balances</li>\n                <li>Display recent transactions</li>\n                <li>Calculate portfolio value in USD</li>\n            </ul>\n            <strong>Tech Stack:</strong> React/Vue, ethers.js, CoinGecko API\n            <strong>Extension:</strong> Add NFT display, multi-chain support, or alerts\n        ",
        "tags": [
          "beginner",
          "frontend",
          "api"
        ],
        "order": 2
      },
      {
        "title": "Simple Voting dApp",
        "answer": "\n            <p>Create a decentralized voting application with smart contract backend.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Connect frontend to smart contracts</li>\n                <li>Handle wallet connections</li>\n                <li>Implement voting logic</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Create proposals</li>\n                <li>Cast votes (one per address)</li>\n                <li>View results in real-time</li>\n                <li>Time-limited voting periods</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, React, ethers.js, MetaMask\n            <strong>Extension:</strong> Add weighted voting, delegation, or quadratic voting\n        ",
        "tags": [
          "beginner",
          "dapp",
          "solidity"
        ],
        "order": 3
      },
      {
        "title": "Tip Jar Smart Contract",
        "answer": "\n            <p>Build a smart contract that accepts ETH tips and allows owner withdrawal.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Handle ETH payments</li>\n                <li>Implement access control</li>\n                <li>Learn payable functions</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Receive ETH tips</li>\n                <li>Track tipper addresses and amounts</li>\n                <li>Owner can withdraw</li>\n                <li>Emit events for tips</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function tip() external payable {\n    require(msg.value > 0, \"Must send ETH\");\n    tips[msg.sender] += msg.value;\n    emit TipReceived(msg.sender, msg.value);\n}</code></pre>\n            <strong>Extension:</strong> Add leaderboard, messages with tips, or multi-recipient splitting\n        ",
        "tags": [
          "beginner",
          "solidity",
          "payments"
        ],
        "order": 4
      },
      {
        "title": "ENS Name Resolver App",
        "answer": "\n            <p>Build an app that resolves ENS names to addresses and vice versa.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Work with ENS protocol</li>\n                <li>Understand name resolution</li>\n                <li>Display ENS metadata</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Resolve .eth names to addresses</li>\n                <li>Reverse resolve addresses to names</li>\n                <li>Display avatar and other records</li>\n                <li>Check name availability</li>\n            </ul>\n            <strong>Tech Stack:</strong> React, ethers.js (built-in ENS support)\n            <strong>Extension:</strong> Add registration flow, text records, or subdomain creation\n        ",
        "tags": [
          "beginner",
          "ens",
          "frontend"
        ],
        "order": 5
      },
      {
        "title": "Gas Price Tracker",
        "answer": "\n            <p>Create a real-time gas price tracker with historical data.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Fetch blockchain data</li>\n                <li>Display real-time updates</li>\n                <li>Work with charting libraries</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Current gas prices (slow, standard, fast)</li>\n                <li>Historical gas charts</li>\n                <li>Estimated transaction costs</li>\n                <li>Push notifications for low gas</li>\n            </ul>\n            <strong>Tech Stack:</strong> React, ethers.js, Chart.js, Etherscan API\n            <strong>Extension:</strong> Add multi-chain, transaction simulation, or gas predictions\n        ",
        "tags": [
          "beginner",
          "tools",
          "api"
        ],
        "order": 6
      },
      {
        "title": "Multi-Sig Wallet (Basic)",
        "answer": "\n            <p>Build a simple multi-signature wallet requiring multiple approvals.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand multi-sig concepts</li>\n                <li>Implement approval mechanisms</li>\n                <li>Handle transaction execution</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Add/remove owners</li>\n                <li>Set required confirmations</li>\n                <li>Submit and confirm transactions</li>\n                <li>Execute after threshold met</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, Hardhat\n            <strong>Extension:</strong> Add time locks, transaction batching, or ERC-20 support\n        ",
        "tags": [
          "beginner",
          "security",
          "solidity"
        ],
        "order": 7
      },
      {
        "title": "Token Faucet",
        "answer": "\n            <p>Create a testnet token faucet that distributes tokens with rate limiting.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Token distribution logic</li>\n                <li>Rate limiting mechanisms</li>\n                <li>Frontend wallet integration</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Claim tokens once per day</li>\n                <li>CAPTCHA or wallet verification</li>\n                <li>Display remaining balance</li>\n                <li>Transaction history</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, React, ethers.js\n            <strong>Extension:</strong> Add social verification, referral bonuses, or multi-token support\n        ",
        "tags": [
          "beginner",
          "tokens",
          "dapp"
        ],
        "order": 8
      },
      {
        "title": "Blockchain Event Listener",
        "answer": "\n            <p>Build a service that listens to smart contract events and logs them.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand blockchain events</li>\n                <li>Work with WebSocket connections</li>\n                <li>Handle event data</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Listen to specific contract events</li>\n                <li>Store events in database</li>\n                <li>Real-time notifications</li>\n                <li>Historical event queries</li>\n            </ul>\n            <pre><code class=\"language-javascript\">contract.on(\"Transfer\", (from, to, value, event) => {\n    console.log(`Transfer: ${from} â†’ ${to}: ${value}`);\n});</code></pre>\n            <strong>Extension:</strong> Add webhook notifications, multi-contract monitoring, or analytics\n        ",
        "tags": [
          "beginner",
          "events",
          "backend"
        ],
        "order": 9
      },
      {
        "title": "Crypto Price Ticker",
        "answer": "\n            <p>Build a live cryptocurrency price ticker with multiple coins.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Work with price APIs</li>\n                <li>Handle real-time data</li>\n                <li>Display price changes</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Live prices for top cryptocurrencies</li>\n                <li>24h price change percentages</li>\n                <li>Sparkline mini charts</li>\n                <li>Favorites/watchlist</li>\n            </ul>\n            <strong>Tech Stack:</strong> React, CoinGecko/CoinMarketCap API\n            <strong>Extension:</strong> Add price alerts, portfolio tracking, or compare charts\n        ",
        "tags": [
          "beginner",
          "api",
          "frontend"
        ],
        "order": 10
      },
      {
        "title": "Simple Crowdfunding Contract",
        "answer": "\n            <p>Create a crowdfunding smart contract with goal-based funding.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Handle multiple contributors</li>\n                <li>Implement funding deadlines</li>\n                <li>Refund logic if goal not met</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Create campaigns with goals and deadlines</li>\n                <li>Accept contributions</li>\n                <li>Automatic refunds if goal not met</li>\n                <li>Creator withdrawal on success</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, Hardhat, React\n            <strong>Extension:</strong> Add milestone-based release, voting on milestones, or NFT rewards\n        ",
        "tags": [
          "beginner",
          "defi",
          "solidity"
        ],
        "order": 11
      },
      {
        "title": "Wallet Connect Integration",
        "answer": "\n            <p>Build a dApp with multiple wallet connection options.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Integrate WalletConnect</li>\n                <li>Support multiple wallets</li>\n                <li>Handle wallet state</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Connect MetaMask, WalletConnect, Coinbase Wallet</li>\n                <li>Display connected address</li>\n                <li>Show wallet balance</li>\n                <li>Switch networks</li>\n            </ul>\n            <strong>Tech Stack:</strong> React, wagmi, RainbowKit/Web3Modal\n            <strong>Extension:</strong> Add session persistence, mobile deep links, or account switching\n        ",
        "tags": [
          "beginner",
          "frontend",
          "wallets"
        ],
        "order": 12
      },
      {
        "title": "Token Swap Interface",
        "answer": "\n            <p>Build a frontend that interfaces with a DEX for token swaps.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Integrate with DEX protocols</li>\n                <li>Handle token approvals</li>\n                <li>Calculate swap rates</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Token selection</li>\n                <li>Quote display</li>\n                <li>Slippage settings</li>\n                <li>Approve and swap transactions</li>\n            </ul>\n            <strong>Tech Stack:</strong> React, ethers.js, Uniswap SDK\n            <strong>Extension:</strong> Add multi-hop routing, price impact warnings, or limit orders\n        ",
        "tags": [
          "beginner",
          "defi",
          "frontend"
        ],
        "order": 13
      },
      {
        "title": "NFT Gallery Viewer",
        "answer": "\n            <p>Create an app that displays NFTs owned by any wallet.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Query NFT ownership</li>\n                <li>Fetch and display metadata</li>\n                <li>Handle IPFS content</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Input wallet address</li>\n                <li>Display all NFTs with images</li>\n                <li>Show traits and attributes</li>\n                <li>Link to OpenSea/marketplaces</li>\n            </ul>\n            <strong>Tech Stack:</strong> React, Alchemy NFT API, IPFS gateways\n            <strong>Extension:</strong> Add collection filtering, rarity rankings, or batch transfers\n        ",
        "tags": [
          "beginner",
          "nft",
          "frontend"
        ],
        "order": 14
      },
      {
        "title": "Decentralized Exchange (Simple AMM)",
        "answer": "\n            <p>Build a basic Automated Market Maker like Uniswap V2.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand constant product formula (x*y=k)</li>\n                <li>Implement liquidity pools</li>\n                <li>Handle swap mechanics</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Create liquidity pools</li>\n                <li>Add/remove liquidity</li>\n                <li>Swap tokens</li>\n                <li>LP token minting/burning</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function swap(uint amountIn, address tokenIn) external {\n    uint amountOut = getAmountOut(amountIn, reserveIn, reserveOut);\n    // Transfer tokens...\n}</code></pre>\n            <strong>Extension:</strong> Add multi-hop swaps, fees, or price oracle\n        ",
        "tags": [
          "intermediate",
          "defi",
          "amm"
        ],
        "order": 15
      },
      {
        "title": "Lending Protocol (Basic)",
        "answer": "\n            <p>Create a simplified lending/borrowing protocol like Compound.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand collateralization</li>\n                <li>Implement interest rate models</li>\n                <li>Handle liquidations</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Deposit collateral</li>\n                <li>Borrow against collateral</li>\n                <li>Accrue interest over time</li>\n                <li>Liquidation mechanism</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, OpenZeppelin, Chainlink Price Feeds\n            <strong>Extension:</strong> Add flash loans, governance, or multiple assets\n        ",
        "tags": [
          "intermediate",
          "defi",
          "lending"
        ],
        "order": 16
      },
      {
        "title": "NFT Marketplace",
        "answer": "\n            <p>Build a decentralized NFT marketplace with listings and auctions.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Handle NFT transfers</li>\n                <li>Implement listing/delisting</li>\n                <li>Create auction mechanics</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>List NFTs for fixed price</li>\n                <li>Create timed auctions</li>\n                <li>Handle bids and settlements</li>\n                <li>Royalty payments (ERC-2981)</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, The Graph, React\n            <strong>Extension:</strong> Add collection offers, bundle sales, or lazy minting\n        ",
        "tags": [
          "intermediate",
          "nft",
          "marketplace"
        ],
        "order": 17
      },
      {
        "title": "DAO with Governance",
        "answer": "\n            <p>Create a DAO with proposal creation, voting, and execution.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Implement voting mechanisms</li>\n                <li>Handle proposal lifecycle</li>\n                <li>Execute on-chain actions</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Token-weighted voting</li>\n                <li>Proposal creation with threshold</li>\n                <li>Timelock for execution</li>\n                <li>Delegate voting power</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, OpenZeppelin Governor, Tally\n            <strong>Extension:</strong> Add quadratic voting, rage quit, or multi-sig integration\n        ",
        "tags": [
          "intermediate",
          "dao",
          "governance"
        ],
        "order": 18
      },
      {
        "title": "Staking Platform",
        "answer": "\n            <p>Build a staking platform with rewards distribution.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Calculate staking rewards</li>\n                <li>Handle stake/unstake logic</li>\n                <li>Implement lock periods</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Stake tokens</li>\n                <li>Earn rewards proportionally</li>\n                <li>Compound rewards</li>\n                <li>Different lock tiers</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function earned(address account) public view returns (uint256) {\n    return (staked[account] * (rewardPerToken() - userRewardPerTokenPaid[account])) / 1e18 + rewards[account];\n}</code></pre>\n            <strong>Extension:</strong> Add boosted rewards, NFT staking, or veToken model\n        ",
        "tags": [
          "intermediate",
          "defi",
          "staking"
        ],
        "order": 19
      },
      {
        "title": "On-chain SVG NFTs",
        "answer": "\n            <p>Create NFTs with fully on-chain SVG art and metadata.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Generate SVG in Solidity</li>\n                <li>Base64 encoding</li>\n                <li>Dynamic metadata</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Procedurally generated art</li>\n                <li>100% on-chain (no IPFS)</li>\n                <li>Dynamic traits based on token ID</li>\n                <li>Updatable artwork</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function tokenURI(uint256 tokenId) public view returns (string memory) {\n    string memory svg = generateSVG(tokenId);\n    return string(abi.encodePacked(\"data:application/json;base64,\", ...));\n}</code></pre>\n            <strong>Extension:</strong> Add animated SVGs, evolving art, or composable layers\n        ",
        "tags": [
          "intermediate",
          "nft",
          "generative"
        ],
        "order": 20
      },
      {
        "title": "Bridge for ERC-20 Tokens",
        "answer": "\n            <p>Build a basic token bridge between two EVM chains.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand cross-chain messaging</li>\n                <li>Lock-and-mint pattern</li>\n                <li>Handle validators/relayers</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Lock tokens on source chain</li>\n                <li>Mint wrapped tokens on destination</li>\n                <li>Burn to unlock originals</li>\n                <li>Multi-sig validation</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity (both chains), relayer backend\n            <strong>Warning:</strong> Bridges are high-risk. Use testnet only!\n            <strong>Extension:</strong> Add challenge period, optimistic verification, or multiple assets\n        ",
        "tags": [
          "intermediate",
          "bridge",
          "crosschain"
        ],
        "order": 21
      },
      {
        "title": "Yield Aggregator",
        "answer": "\n            <p>Create a yield aggregator that auto-compounds rewards.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Integrate with DeFi protocols</li>\n                <li>Implement vault pattern</li>\n                <li>Auto-compound logic</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Deposit to vault</li>\n                <li>Vault deploys to strategies</li>\n                <li>Auto-harvest and compound</li>\n                <li>Share-based accounting</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, ERC-4626 vault standard\n            <strong>Extension:</strong> Add multiple strategies, strategy scoring, or emergency withdrawal\n        ",
        "tags": [
          "intermediate",
          "defi",
          "yield"
        ],
        "order": 22
      },
      {
        "title": "Decentralized Identity (DID)",
        "answer": "\n            <p>Build a decentralized identity system with verifiable credentials.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand DID standards</li>\n                <li>Issue verifiable credentials</li>\n                <li>Implement attestations</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Create DID documents</li>\n                <li>Issue credentials (soulbound tokens)</li>\n                <li>Verify credentials</li>\n                <li>Revocation registry</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, ERC-5192 (Soulbound), did-jwt\n            <strong>Extension:</strong> Add ZK proofs for privacy, social recovery, or reputation system\n        ",
        "tags": [
          "intermediate",
          "identity",
          "credentials"
        ],
        "order": 23
      },
      {
        "title": "On-chain Game (Simple)",
        "answer": "\n            <p>Create a simple on-chain game with verifiable randomness.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Secure randomness (Chainlink VRF)</li>\n                <li>Game state management</li>\n                <li>Reward distribution</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Coin flip or dice game</li>\n                <li>Provably fair randomness</li>\n                <li>Bet placement and payouts</li>\n                <li>House edge configuration</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, Chainlink VRF\n            <strong>Extension:</strong> Add multi-player games, tournaments, or progressive jackpots\n        ",
        "tags": [
          "intermediate",
          "gaming",
          "randomness"
        ],
        "order": 24
      },
      {
        "title": "Token Vesting Contract",
        "answer": "\n            <p>Build a token vesting system with cliff and linear release.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Time-based unlocking</li>\n                <li>Cliff periods</li>\n                <li>Revocation handling</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Create vesting schedules</li>\n                <li>Cliff period before any release</li>\n                <li>Linear or step-based vesting</li>\n                <li>Admin can revoke unvested tokens</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function vestedAmount() public view returns (uint256) {\n    if (block.timestamp < cliff) return 0;\n    if (block.timestamp >= end) return totalAmount;\n    return totalAmount * (block.timestamp - start) / (end - start);\n}</code></pre>\n            <strong>Extension:</strong> Add multiple beneficiaries, transferable vesting, or milestone-based vesting\n        ",
        "tags": [
          "intermediate",
          "tokens",
          "vesting"
        ],
        "order": 25
      },
      {
        "title": "Subscription NFT Membership",
        "answer": "\n            <p>Create NFT-based subscriptions that expire and can be renewed.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Time-limited token validity</li>\n                <li>Renewal mechanics</li>\n                <li>Access control based on NFT</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Mint subscription NFT with duration</li>\n                <li>Check if subscription is active</li>\n                <li>Renew subscription</li>\n                <li>Tier-based pricing</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, ERC-721\n            <strong>Extension:</strong> Add auto-renewal, gifting, or family plans\n        ",
        "tags": [
          "intermediate",
          "nft",
          "subscription"
        ],
        "order": 26
      },
      {
        "title": "Gasless Transactions (Meta-transactions)",
        "answer": "\n            <p>Implement ERC-2771 meta-transactions for gasless user experience.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand ERC-2771</li>\n                <li>Trusted forwarder pattern</li>\n                <li>Signature verification</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>User signs transaction off-chain</li>\n                <li>Relayer submits transaction</li>\n                <li>Contract trusts forwarder</li>\n                <li>User doesn't need ETH for gas</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, OpenZeppelin, Gelato/Biconomy\n            <strong>Extension:</strong> Add ERC-20 gas payment, sponsored transactions, or batch execution\n        ",
        "tags": [
          "intermediate",
          "ux",
          "gasless"
        ],
        "order": 27
      },
      {
        "title": "The Graph Subgraph",
        "answer": "\n            <p>Create a subgraph to index and query blockchain data.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand event indexing</li>\n                <li>Write GraphQL schema</li>\n                <li>Map events to entities</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Index smart contract events</li>\n                <li>Create queryable entities</li>\n                <li>Handle relationships</li>\n                <li>Query via GraphQL API</li>\n            </ul>\n            <strong>Tech Stack:</strong> The Graph, AssemblyScript, GraphQL\n            <strong>Extension:</strong> Add aggregations, time-series data, or cross-contract indexing\n        ",
        "tags": [
          "intermediate",
          "indexing",
          "thegraph"
        ],
        "order": 28
      },
      {
        "title": "Commit-Reveal Voting",
        "answer": "\n            <p>Implement voting with commit-reveal to prevent vote peeking.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Two-phase voting</li>\n                <li>Commitment schemes</li>\n                <li>Reveal verification</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Commit phase: Submit hashed votes</li>\n                <li>Reveal phase: Reveal and verify votes</li>\n                <li>Prevent voting based on others' votes</li>\n                <li>Slash unrevealed votes</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function commit(bytes32 commitment) external {\n    commits[msg.sender] = commitment;\n}\n\nfunction reveal(uint256 vote, bytes32 salt) external {\n    require(keccak256(abi.encode(vote, salt)) == commits[msg.sender]);\n    // Count vote...\n}</code></pre>\n            <strong>Extension:</strong> Add ZK proofs, vote weighting, or delegation\n        ",
        "tags": [
          "intermediate",
          "governance",
          "privacy"
        ],
        "order": 29
      },
      {
        "title": "Escrow Contract",
        "answer": "\n            <p>Build an escrow system with dispute resolution.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Multi-party fund management</li>\n                <li>State machine patterns</li>\n                <li>Dispute handling</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Buyer deposits funds</li>\n                <li>Seller delivers goods/service</li>\n                <li>Buyer confirms or disputes</li>\n                <li>Arbiter resolves disputes</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity\n            <strong>Extension:</strong> Add milestone releases, multiple arbiters, or reputation system\n        ",
        "tags": [
          "intermediate",
          "payments",
          "security"
        ],
        "order": 30
      },
      {
        "title": "Merkle Airdrop",
        "answer": "\n            <p>Implement gas-efficient airdrops using Merkle proofs.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Generate Merkle trees off-chain</li>\n                <li>Verify proofs on-chain</li>\n                <li>Efficient claim mechanism</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Generate tree from address list</li>\n                <li>Users claim with proof</li>\n                <li>Prevent double claims</li>\n                <li>Set expiration dates</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function claim(uint256 amount, bytes32[] calldata proof) external {\n    bytes32 leaf = keccak256(abi.encode(msg.sender, amount));\n    require(MerkleProof.verify(proof, merkleRoot, leaf));\n    require(!claimed[msg.sender]);\n    claimed[msg.sender] = true;\n    token.transfer(msg.sender, amount);\n}</code></pre>\n            <strong>Extension:</strong> Add streaming claims, retroactive airdrops, or multi-token drops\n        ",
        "tags": [
          "intermediate",
          "tokens",
          "airdrop"
        ],
        "order": 31
      },
      {
        "title": "Upgradeable Contract System",
        "answer": "\n            <p>Implement upgradeable smart contracts using proxy patterns.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand proxy patterns</li>\n                <li>Storage layout considerations</li>\n                <li>Safe upgrade practices</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Transparent or UUPS proxy</li>\n                <li>Admin-controlled upgrades</li>\n                <li>Initialization instead of constructor</li>\n                <li>Storage gap for future variables</li>\n            </ul>\n            <strong>Tech Stack:</strong> OpenZeppelin Upgrades, Hardhat\n            <strong>Extension:</strong> Add timelock, multi-sig approval, or beacon proxy\n        ",
        "tags": [
          "intermediate",
          "upgrades",
          "patterns"
        ],
        "order": 32
      },
      {
        "title": "Chainlink Price Feed Integration",
        "answer": "\n            <p>Build a DeFi app that uses Chainlink for reliable price data.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Integrate Chainlink feeds</li>\n                <li>Handle price data correctly</li>\n                <li>Implement staleness checks</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Fetch ETH/USD price</li>\n                <li>Use for collateral valuation</li>\n                <li>Check for stale data</li>\n                <li>Multiple price feeds</li>\n            </ul>\n            <pre><code class=\"language-solidity\">function getLatestPrice() public view returns (int256) {\n    (,int256 price,,uint256 updatedAt,) = priceFeed.latestRoundData();\n    require(block.timestamp - updatedAt < 1 hours, \"Stale price\");\n    return price;\n}</code></pre>\n            <strong>Extension:</strong> Add derived prices, circuit breakers, or fallback oracles\n        ",
        "tags": [
          "intermediate",
          "oracles",
          "chainlink"
        ],
        "order": 33
      },
      {
        "title": "NFT Staking for Rewards",
        "answer": "\n            <p>Create a system where NFT holders can stake for token rewards.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Handle NFT deposits/withdrawals</li>\n                <li>Calculate time-based rewards</li>\n                <li>Rarity-based reward multipliers</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Stake NFTs from collection</li>\n                <li>Earn tokens over time</li>\n                <li>Claim rewards anytime</li>\n                <li>Bonus for rare NFTs</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, ERC-721, ERC-20\n            <strong>Extension:</strong> Add lock-up bonuses, collection bonuses, or boosting\n        ",
        "tags": [
          "intermediate",
          "nft",
          "staking"
        ],
        "order": 34
      },
      {
        "title": "Flash Loan Arbitrage Bot",
        "answer": "\n            <p>Build an arbitrage bot using flash loans to profit from price differences.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Flash loan mechanics</li>\n                <li>Arbitrage detection</li>\n                <li>Gas optimization</li>\n                <li>MEV protection</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Detect price discrepancies</li>\n                <li>Execute flash loan arbitrage</li>\n                <li>Calculate profitability including gas</li>\n                <li>Use Flashbots for MEV protection</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, Aave/dYdX flash loans, ethers.js\n            <strong>Warning:</strong> Highly competitive, expect losses learning\n            <strong>Extension:</strong> Add multi-hop, multi-DEX, or triangular arbitrage\n        ",
        "tags": [
          "advanced",
          "defi",
          "mev"
        ],
        "order": 35
      },
      {
        "title": "ZK Proof Integration",
        "answer": "\n            <p>Implement a smart contract that verifies zero-knowledge proofs.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Understand ZK circuits</li>\n                <li>Generate and verify proofs</li>\n                <li>Integrate Circom/snarkjs</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Write circuit in Circom</li>\n                <li>Generate trusted setup</li>\n                <li>Create Solidity verifier</li>\n                <li>Private proof verification</li>\n            </ul>\n            <strong>Example use case:</strong>\n            <ul>\n                <li>Prove age > 18 without revealing birthdate</li>\n                <li>Prove membership without revealing identity</li>\n                <li>Private voting</li>\n            </ul>\n            <strong>Tech Stack:</strong> Circom, snarkjs, Solidity\n            <strong>Extension:</strong> Add recursive proofs, anonymous voting, or private transfers\n        ",
        "tags": [
          "advanced",
          "zk",
          "privacy"
        ],
        "order": 36
      },
      {
        "title": "Concentrated Liquidity AMM (Uniswap V3 style)",
        "answer": "\n            <p>Build an AMM with concentrated liquidity positions.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Tick-based pricing</li>\n                <li>Range orders</li>\n                <li>Capital efficiency</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Provide liquidity in price ranges</li>\n                <li>NFT position tokens</li>\n                <li>Fee collection per position</li>\n                <li>Tick math implementation</li>\n            </ul>\n            <strong>Challenges:</strong>\n            <ul>\n                <li>Complex math (Q64.96 fixed point)</li>\n                <li>Tick spacing and fee tiers</li>\n                <li>Position management</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, PRBMath library\n            <strong>Extension:</strong> Add limit orders, TWAP oracle, or fee switch\n        ",
        "tags": [
          "advanced",
          "defi",
          "amm"
        ],
        "order": 37
      },
      {
        "title": "MEV Bot (Searcher)",
        "answer": "\n            <p>Create a searcher bot that extracts MEV opportunities.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Mempool monitoring</li>\n                <li>Transaction simulation</li>\n                <li>Bundle creation</li>\n                <li>Flashbots integration</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Monitor pending transactions</li>\n                <li>Simulate opportunities</li>\n                <li>Create profitable bundles</li>\n                <li>Submit to Flashbots</li>\n            </ul>\n            <strong>Strategies to explore:</strong>\n            <ul>\n                <li>Arbitrage</li>\n                <li>Liquidations</li>\n                <li>Long-tail MEV</li>\n            </ul>\n            <strong>Tech Stack:</strong> ethers.js, Flashbots SDK\n            <strong>Warning:</strong> Highly competitive, requires significant capital\n        ",
        "tags": [
          "advanced",
          "mev",
          "bot"
        ],
        "order": 38
      },
      {
        "title": "Layer 2 Bridge",
        "answer": "\n            <p>Build a trustless bridge between L1 and an L2 rollup.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Cross-chain communication</li>\n                <li>Merkle proof verification</li>\n                <li>Challenge periods</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Deposit on L1, receive on L2</li>\n                <li>Withdraw with proof</li>\n                <li>Handle optimistic verification</li>\n                <li>Fast exit with liquidity providers</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity (L1 & L2), SDK for L2\n            <strong>Extension:</strong> Add NFT bridging, fast withdrawals, or multi-token support\n        ",
        "tags": [
          "advanced",
          "layer2",
          "bridge"
        ],
        "order": 39
      },
      {
        "title": "Account Abstraction Wallet (ERC-4337)",
        "answer": "\n            <p>Implement an ERC-4337 compliant smart contract wallet.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>UserOperation structure</li>\n                <li>Bundler interaction</li>\n                <li>Paymaster integration</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Smart contract wallet</li>\n                <li>Social recovery</li>\n                <li>Session keys</li>\n                <li>Gasless transactions via paymaster</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, ERC-4337 SDK (eth-infinitism)\n            <strong>Extension:</strong> Add plugins, multi-sig, or spending limits\n        ",
        "tags": [
          "advanced",
          "wallet",
          "aa"
        ],
        "order": 40
      },
      {
        "title": "Perpetual Futures DEX",
        "answer": "\n            <p>Create a decentralized perpetual futures exchange.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Funding rate mechanics</li>\n                <li>Leverage and margin</li>\n                <li>Liquidation engine</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Open long/short positions</li>\n                <li>Leverage up to 10-50x</li>\n                <li>Funding rate calculation</li>\n                <li>Partial/full liquidations</li>\n            </ul>\n            <strong>Challenges:</strong>\n            <ul>\n                <li>Oracle integration</li>\n                <li>Insurance fund</li>\n                <li>Position sizing</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, Chainlink, The Graph\n        ",
        "tags": [
          "advanced",
          "defi",
          "derivatives"
        ],
        "order": 41
      },
      {
        "title": "Optimistic Rollup (Simplified)",
        "answer": "\n            <p>Build a simplified optimistic rollup with fraud proofs.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>State root management</li>\n                <li>Fraud proof mechanics</li>\n                <li>Challenge games</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Batch transaction submission</li>\n                <li>State root commitments</li>\n                <li>Fraud proof verification</li>\n                <li>Challenge/response protocol</li>\n            </ul>\n            <strong>Components:</strong>\n            <ul>\n                <li>L1 contract (state roots, deposits)</li>\n                <li>Sequencer (batching)</li>\n                <li>Verifier (fraud detection)</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, Node.js sequencer\n        ",
        "tags": [
          "advanced",
          "layer2",
          "rollup"
        ],
        "order": 42
      },
      {
        "title": "Algorithmic Stablecoin",
        "answer": "\n            <p>Create an algorithmic stablecoin with stability mechanisms.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Monetary policy on-chain</li>\n                <li>Collateralization models</li>\n                <li>Stability mechanisms</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Mint stablecoin with collateral</li>\n                <li>Stability fee/interest</li>\n                <li>Liquidation mechanism</li>\n                <li>Governance for parameters</li>\n            </ul>\n            <strong>Warning:</strong> Algorithmic stablecoins are high-risk\n            <strong>Study:</strong> MakerDAO, Frax, UST collapse\n            <strong>Extension:</strong> Add PSM (Peg Stability Module), emergency shutdown\n        ",
        "tags": [
          "advanced",
          "defi",
          "stablecoin"
        ],
        "order": 43
      },
      {
        "title": "Intent-Based Trading System",
        "answer": "\n            <p>Build a system where users sign intents that solvers compete to fulfill.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Intent architecture</li>\n                <li>Solver competition</li>\n                <li>Off-chain matching</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Users sign swap intents</li>\n                <li>Solvers find best execution</li>\n                <li>On-chain settlement</li>\n                <li>MEV protection for users</li>\n            </ul>\n            <strong>Inspired by:</strong> CoW Protocol, UniswapX\n            <strong>Tech Stack:</strong> Solidity, EIP-712, solver backend\n            <strong>Extension:</strong> Add batch auctions, solver reputation, or cross-chain intents\n        ",
        "tags": [
          "advanced",
          "defi",
          "intents"
        ],
        "order": 44
      },
      {
        "title": "Liquid Staking Derivative",
        "answer": "\n            <p>Create a liquid staking protocol like Lido for a PoS chain.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Staking pool management</li>\n                <li>Derivative token mechanics</li>\n                <li>Oracle for rewards</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Stake ETH, receive stETH</li>\n                <li>Rebase or reward-bearing token</li>\n                <li>Withdrawal queue</li>\n                <li>Node operator management</li>\n            </ul>\n            <strong>Tech Stack:</strong> Solidity, Beacon chain interaction\n            <strong>Extension:</strong> Add insurance, distributed validators, or governance\n        ",
        "tags": [
          "advanced",
          "defi",
          "staking"
        ],
        "order": 45
      },
      {
        "title": "Decentralized Options Protocol",
        "answer": "\n            <p>Build a protocol for trading on-chain options.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Options pricing (Black-Scholes)</li>\n                <li>Collateralization</li>\n                <li>Settlement mechanics</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Create call/put options</li>\n                <li>European or American style</li>\n                <li>Automated exercise at expiry</li>\n                <li>Collateral management</li>\n            </ul>\n            <strong>Study:</strong> Opyn, Dopex, Lyra\n            <strong>Tech Stack:</strong> Solidity, Chainlink, PRBMath\n            <strong>Extension:</strong> Add exotic options, vaults, or AMM for options\n        ",
        "tags": [
          "advanced",
          "defi",
          "derivatives"
        ],
        "order": 46
      },
      {
        "title": "Cross-chain Messaging Protocol",
        "answer": "\n            <p>Build a protocol for passing arbitrary messages between chains.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Message verification</li>\n                <li>Relay networks</li>\n                <li>Security models</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Send messages between chains</li>\n                <li>Verify message authenticity</li>\n                <li>Execute arbitrary calls</li>\n                <li>Handle failures gracefully</li>\n            </ul>\n            <strong>Inspired by:</strong> LayerZero, Axelar, Hyperlane\n            <strong>Tech Stack:</strong> Solidity (multiple chains), relayer\n            <strong>Extension:</strong> Add multi-chain governance, token transfers, or NFT bridging\n        ",
        "tags": [
          "advanced",
          "crosschain",
          "messaging"
        ],
        "order": 47
      },
      {
        "title": "Fully On-chain Game (Complex)",
        "answer": "\n            <p>Create a fully on-chain game with autonomous world mechanics.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>On-chain game state</li>\n                <li>Turn-based or time-based mechanics</li>\n                <li>NFT integration for assets</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>All game logic on-chain</li>\n                <li>Composable game entities</li>\n                <li>Player-owned assets</li>\n                <li>Emergent gameplay</li>\n            </ul>\n            <strong>Inspired by:</strong> Dark Forest, Loot, Realms\n            <strong>Tech Stack:</strong> Solidity/Cairo, MUD/Dojo framework\n            <strong>Extension:</strong> Add ZK fog of war, autonomous agents, or economic systems\n        ",
        "tags": [
          "advanced",
          "gaming",
          "autonomous"
        ],
        "order": 48
      },
      {
        "title": "Privacy Pool (ZK Mixer)",
        "answer": "\n            <p>Build a privacy-preserving transaction system using ZK proofs.</p>\n            <strong>Learning Goals:</strong>\n            <ul>\n                <li>Nullifier/commitment scheme</li>\n                <li>ZK proof generation</li>\n                <li>Compliance considerations</li>\n            </ul>\n            <strong>Features:</strong>\n            <ul>\n                <li>Deposit with commitment</li>\n                <li>Withdraw with ZK proof</li>\n                <li>No link between deposit/withdrawal</li>\n                <li>Merkle tree of commitments</li>\n            </ul>\n            <strong>Study:</strong> Tornado Cash (for educational purposes)\n            <strong>Tech Stack:</strong> Circom, snarkjs, Solidity\n            <strong>Legal note:</strong> Be aware of regulatory requirements\n            <strong>Extension:</strong> Add compliance proofs, shielded transfers, or multi-asset\n        ",
        "tags": [
          "advanced",
          "privacy",
          "zk"
        ],
        "order": 49
      }
    ],
    "rust": [
      {
        "title": "Why is Rust popular for blockchain development?",
        "answer": "\n            <p><strong>Rust</strong> has become the preferred language for blockchain development due to its unique combination of safety and performance.</p>\n            <strong>Key advantages:</strong>\n            <ul>\n                <li><strong>Memory safety:</strong> No null pointers, buffer overflows, or data races</li>\n                <li><strong>Zero-cost abstractions:</strong> High-level features compile to efficient code</li>\n                <li><strong>No garbage collector:</strong> Predictable performance, crucial for consensus</li>\n                <li><strong>Strong type system:</strong> Catches bugs at compile time</li>\n                <li><strong>Concurrency:</strong> Fearless concurrency with ownership model</li>\n            </ul>\n            <strong>Major blockchain projects in Rust:</strong>\n            <ul>\n                <li>Solana</li>\n                <li>Polkadot/Substrate</li>\n                <li>Near Protocol</li>\n                <li>Cosmos SDK (some components)</li>\n                <li>Aptos, Sui (Move VM is Rust-based)</li>\n            </ul>\n        ",
        "tags": [
          "rust",
          "blockchain",
          "difficulty-intermediate"
        ],
        "order": 0
      },
      {
        "title": "What is ownership in Rust and why does it matter?",
        "answer": "\n            <p><strong>Ownership</strong> is Rust's core concept that enables memory safety without garbage collection.</p>\n            <strong>Ownership rules:</strong>\n            <ol>\n                <li>Each value has exactly one owner</li>\n                <li>When owner goes out of scope, value is dropped</li>\n                <li>Ownership can be transferred (moved)</li>\n            </ol>\n            <pre><code class=\"language-rust\">fn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1;  // s1 is MOVED to s2\n    // println!(\"{}\", s1);  // ERROR: s1 no longer valid\n    \n    let s3 = s2.clone();  // Deep copy\n    println!(\"{} {}\", s2, s3);  // Both valid\n}\n\nfn takes_ownership(s: String) {\n    println!(\"{}\", s);\n}  // s is dropped here\n\nfn main() {\n    let s = String::from(\"hello\");\n    takes_ownership(s);\n    // s is no longer valid here\n}</code></pre>\n            <strong>Why it matters for blockchain:</strong>\n            <ul>\n                <li>Prevents double-spending bugs at compile time</li>\n                <li>No memory leaks in long-running nodes</li>\n                <li>Predictable resource cleanup</li>\n            </ul>\n        ",
        "tags": [
          "rust",
          "difficulty-intermediate"
        ],
        "order": 1
      },
      {
        "title": "What are borrowing and references in Rust?",
        "answer": "\n            <p><strong>Borrowing</strong> allows accessing data without taking ownership, using references.</p>\n            <strong>Reference rules:</strong>\n            <ul>\n                <li>Many immutable references OR one mutable reference (not both)</li>\n                <li>References must always be valid (no dangling)</li>\n            </ul>\n            <pre><code class=\"language-rust\">fn main() {\n    let mut s = String::from(\"hello\");\n    \n    // Immutable borrow\n    let len = calculate_length(&s);\n    println!(\"Length: {}\", len);\n    \n    // Mutable borrow\n    change(&mut s);\n    println!(\"{}\", s);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()  // Can read, cannot modify\n}\n\nfn change(s: &mut String) {\n    s.push_str(\", world\");  // Can modify\n}\n\n// This won't compile:\nfn bad() {\n    let mut s = String::from(\"hello\");\n    let r1 = &s;\n    let r2 = &s;      // OK: multiple immutable\n    let r3 = &mut s;  // ERROR: can't borrow mutably\n}</code></pre>\n        ",
        "tags": [
          "rust",
          "difficulty-intermediate"
        ],
        "order": 2
      },
      {
        "title": "What are lifetimes in Rust?",
        "answer": "\n            <p><strong>Lifetimes</strong> are Rust's way of ensuring references are valid for as long as they're used.</p>\n            <strong>Lifetime annotations:</strong>\n            <pre><code class=\"language-rust\">// Lifetime parameter 'a\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() { x } else { y }\n}\n\n// Tells compiler: returned reference lives as long as\n// the shorter of x or y\n\nfn main() {\n    let s1 = String::from(\"long\");\n    let result;\n    {\n        let s2 = String::from(\"short\");\n        result = longest(&s1, &s2);\n        println!(\"{}\", result);  // OK here\n    }\n    // println!(\"{}\", result);  // ERROR: s2 dropped\n}</code></pre>\n            <strong>Struct lifetimes:</strong>\n            <pre><code class=\"language-rust\">struct Transaction<'a> {\n    sender: &'a str,\n    receiver: &'a str,\n    amount: u64,\n}\n\n// Transaction can't outlive the strings it references</code></pre>\n        ",
        "tags": [
          "rust",
          "difficulty-advanced"
        ],
        "order": 3
      },
      {
        "title": "What are traits in Rust?",
        "answer": "\n            <p><strong>Traits</strong> define shared behavior, similar to interfaces in other languages.</p>\n            <pre><code class=\"language-rust\">// Define a trait\ntrait Hashable {\n    fn hash(&self) -> Vec<u8>;\n    \n    // Default implementation\n    fn hash_hex(&self) -> String {\n        hex::encode(self.hash())\n    }\n}\n\n// Implement for a struct\nstruct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n}\n\nimpl Hashable for Transaction {\n    fn hash(&self) -> Vec<u8> {\n        use sha2::{Sha256, Digest};\n        let data = format!(\"{}{}{}\", self.from, self.to, self.amount);\n        Sha256::digest(data.as_bytes()).to_vec()\n    }\n}\n\n// Trait bounds\nfn process<T: Hashable>(item: T) {\n    println!(\"Hash: {}\", item.hash_hex());\n}\n\n// Multiple bounds\nfn complex<T: Hashable + Clone + Send>(item: T) { }</code></pre>\n            <strong>Common traits:</strong> Clone, Copy, Debug, Default, Send, Sync\n        ",
        "tags": [
          "rust",
          "difficulty-intermediate"
        ],
        "order": 4
      },
      {
        "title": "What is Result and Option in Rust?",
        "answer": "\n            <p><strong>Result</strong> and <strong>Option</strong> are enums for handling errors and optional values safely.</p>\n            <strong>Option - for optional values:</strong>\n            <pre><code class=\"language-rust\">enum Option<T> {\n    Some(T),\n    None,\n}\n\nfn find_balance(address: &str) -> Option<u64> {\n    if address == \"0x123\" {\n        Some(1000)\n    } else {\n        None\n    }\n}\n\nfn main() {\n    match find_balance(\"0x123\") {\n        Some(balance) => println!(\"Balance: {}\", balance),\n        None => println!(\"Address not found\"),\n    }\n    \n    // Or use combinators\n    let balance = find_balance(\"0x123\").unwrap_or(0);\n}</code></pre>\n            <strong>Result - for errors:</strong>\n            <pre><code class=\"language-rust\">enum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n\nfn transfer(amount: u64) -> Result<(), TransferError> {\n    if amount == 0 {\n        return Err(TransferError::ZeroAmount);\n    }\n    Ok(())\n}\n\n// ? operator for propagation\nfn process() -> Result<(), Error> {\n    let balance = get_balance()?;  // Returns early if Err\n    transfer(balance)?;\n    Ok(())\n}</code></pre>\n        ",
        "tags": [
          "rust",
          "difficulty-intermediate"
        ],
        "order": 5
      },
      {
        "title": "What are enums and pattern matching in Rust?",
        "answer": "\n            <p><strong>Enums</strong> in Rust can hold data and are matched exhaustively with <strong>pattern matching</strong>.</p>\n            <pre><code class=\"language-rust\">// Enum with variants holding data\nenum Transaction {\n    Transfer { from: String, to: String, amount: u64 },\n    Stake { validator: String, amount: u64 },\n    Unstake { validator: String },\n    Governance { proposal_id: u32, vote: bool },\n}\n\nfn process(tx: Transaction) {\n    match tx {\n        Transaction::Transfer { from, to, amount } => {\n            println!(\"{} sends {} to {}\", from, amount, to);\n        }\n        Transaction::Stake { validator, amount } => {\n            println!(\"Staking {} to {}\", amount, validator);\n        }\n        Transaction::Unstake { validator } => {\n            println!(\"Unstaking from {}\", validator);\n        }\n        Transaction::Governance { proposal_id, vote } => {\n            let v = if vote { \"yes\" } else { \"no\" };\n            println!(\"Vote {} on proposal {}\", v, proposal_id);\n        }\n    }\n}\n\n// if let for single pattern\nif let Transaction::Transfer { amount, .. } = tx {\n    println!(\"Transfer of {}\", amount);\n}</code></pre>\n        ",
        "tags": [
          "rust",
          "difficulty-intermediate"
        ],
        "order": 6
      },
      {
        "title": "What is async/await in Rust?",
        "answer": "\n            <p><strong>Async/await</strong> enables non-blocking concurrent programming in Rust.</p>\n            <pre><code class=\"language-rust\">use tokio;\n\n// Async function\nasync fn fetch_block(height: u64) -> Result<Block, Error> {\n    let response = client.get(&format!(\"/block/{}\", height)).await?;\n    let block: Block = response.json().await?;\n    Ok(block)\n}\n\n// Main with tokio runtime\n#[tokio::main]\nasync fn main() {\n    // Sequential\n    let block1 = fetch_block(1).await.unwrap();\n    let block2 = fetch_block(2).await.unwrap();\n    \n    // Concurrent\n    let (b1, b2) = tokio::join!(\n        fetch_block(1),\n        fetch_block(2)\n    );\n    \n    // Spawn tasks\n    let handle = tokio::spawn(async {\n        fetch_block(100).await\n    });\n    let result = handle.await.unwrap();\n}</code></pre>\n            <strong>Async runtimes:</strong>\n            <ul>\n                <li><strong>Tokio:</strong> Most popular, used by many blockchain clients</li>\n                <li><strong>async-std:</strong> Standard library-like API</li>\n                <li><strong>smol:</strong> Lightweight</li>\n            </ul>\n        ",
        "tags": [
          "rust",
          "async",
          "difficulty-intermediate"
        ],
        "order": 7
      },
      {
        "title": "What are macros in Rust?",
        "answer": "\n            <p><strong>Macros</strong> are code that writes code, enabling metaprogramming.</p>\n            <strong>Declarative macros (macro_rules!):</strong>\n            <pre><code class=\"language-rust\">// Simple macro\nmacro_rules! vec_of_strings {\n    ($($x:expr),*) => {\n        vec![$($x.to_string()),*]\n    };\n}\n\nlet strings = vec_of_strings![\"a\", \"b\", \"c\"];\n\n// Pattern matching in macros\nmacro_rules! hash_map {\n    ($($key:expr => $value:expr),* $(,)?) => {{\n        let mut map = std::collections::HashMap::new();\n        $(map.insert($key, $value);)*\n        map\n    }};\n}\n\nlet balances = hash_map! {\n    \"alice\" => 100,\n    \"bob\" => 200,\n};</code></pre>\n            <strong>Procedural macros:</strong>\n            <pre><code class=\"language-rust\">// Derive macros (like in Substrate)\n#[derive(Debug, Clone, Encode, Decode)]\nstruct Block {\n    number: u64,\n    hash: Hash,\n}\n\n// Attribute macros\n#[pallet::call]\nimpl<T: Config> Pallet<T> {\n    #[pallet::weight(10_000)]\n    pub fn transfer(origin: OriginFor<T>) -> DispatchResult {\n        // ...\n    }\n}</code></pre>\n        ",
        "tags": [
          "rust",
          "difficulty-advanced"
        ],
        "order": 8
      },
      {
        "title": "What is Cargo and how is it used?",
        "answer": "\n            <p><strong>Cargo</strong> is Rust's package manager and build system.</p>\n            <strong>Common commands:</strong>\n            <pre><code class=\"language-bash\"># Create new project\ncargo new my_project\ncargo new --lib my_library\n\n# Build\ncargo build           # Debug build\ncargo build --release # Optimized build\n\n# Run\ncargo run\ncargo run --release\n\n# Test\ncargo test\ncargo test specific_test\n\n# Check without building\ncargo check\n\n# Format and lint\ncargo fmt\ncargo clippy</code></pre>\n            <strong>Cargo.toml:</strong>\n            <pre><code class=\"language-toml\">[package]\nname = \"my_project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ntokio = { version = \"1\", features = [\"full\"] }\nserde = { version = \"1\", features = [\"derive\"] }\nsha2 = \"0.10\"\n\n[dev-dependencies]\ncriterion = \"0.4\"</code></pre>\n        ",
        "tags": [
          "rust",
          "tools",
          "difficulty-basic"
        ],
        "order": 9
      },
      {
        "title": "How do you handle serialization in Rust for blockchain?",
        "answer": "\n            <p>Blockchain data requires efficient serialization. Rust offers several options.</p>\n            <strong>Serde (most common):</strong>\n            <pre><code class=\"language-rust\">use serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\nstruct Transaction {\n    from: String,\n    to: String,\n    amount: u64,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    memo: Option<String>,\n}\n\n// JSON\nlet json = serde_json::to_string(&tx)?;\nlet tx: Transaction = serde_json::from_str(&json)?;\n\n// Binary (more compact)\nlet bytes = bincode::serialize(&tx)?;\nlet tx: Transaction = bincode::deserialize(&bytes)?;</code></pre>\n            <strong>SCALE (Substrate):</strong>\n            <pre><code class=\"language-rust\">use parity_scale_codec::{Encode, Decode};\n\n#[derive(Encode, Decode)]\nstruct Block {\n    number: u32,\n    parent_hash: [u8; 32],\n}\n\nlet encoded: Vec<u8> = block.encode();\nlet decoded = Block::decode(&mut &encoded[..])?;</code></pre>\n            <strong>Why different formats:</strong>\n            <ul>\n                <li>JSON: Human readable, APIs</li>\n                <li>Bincode: Compact, fast</li>\n                <li>SCALE: Substrate-specific, compact</li>\n            </ul>\n        ",
        "tags": [
          "rust",
          "serialization",
          "difficulty-intermediate"
        ],
        "order": 10
      },
      {
        "title": "What is the Rust standard library's relevance to blockchain?",
        "answer": "\n            <p>Rust's <strong>standard library</strong> provides essential types, but blockchain development often uses <code>no_std</code> for constrained environments.</p>\n            <strong>Key std types used:</strong>\n            <pre><code class=\"language-rust\">use std::collections::{HashMap, HashSet, BTreeMap};\nuse std::sync::{Arc, Mutex, RwLock};\nuse std::vec::Vec;\n\n// Collections for state\nlet mut balances: HashMap<Address, u64> = HashMap::new();\n\n// Thread-safe shared state\nlet state = Arc::new(RwLock::new(ChainState::default()));\n\n// Clone for multiple ownership\nlet state_clone = Arc::clone(&state);</code></pre>\n            <strong>no_std for blockchain runtimes:</strong>\n            <pre><code class=\"language-rust\">#![no_std]\n// No heap allocations, no std\n\nextern crate alloc;\nuse alloc::vec::Vec;  // Vec from alloc crate\nuse alloc::string::String;\n\n// Substrate pallets are no_std\n// Allows running in WASM</code></pre>\n            <strong>Why no_std:</strong>\n            <ul>\n                <li>WASM runtime compatibility</li>\n                <li>Deterministic execution</li>\n                <li>Smaller binary size</li>\n            </ul>\n        ",
        "tags": [
          "rust",
          "difficulty-intermediate"
        ],
        "order": 11
      },
      {
        "title": "What is Substrate?",
        "answer": "\n            <p><strong>Substrate</strong> is a modular blockchain framework built in Rust that allows developers to build custom blockchains.</p>\n            <strong>Key features:</strong>\n            <ul>\n                <li><strong>Modular:</strong> Pick and choose components (pallets)</li>\n                <li><strong>Forkless upgrades:</strong> Runtime upgrades without hard forks</li>\n                <li><strong>Interoperable:</strong> Can connect to Polkadot as parachain</li>\n                <li><strong>WASM-based:</strong> Runtime compiled to WebAssembly</li>\n            </ul>\n            <strong>Substrate layers:</strong>\n            <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚          Runtime (WASM)         â”‚ â† Your business logic\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚         Substrate Core          â”‚ â† Networking, consensus, DB\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚              libp2p             â”‚ â† P2P networking\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>\n            <strong>Projects built with Substrate:</strong> Polkadot, Kusama, Acala, Moonbeam, Astar\n        ",
        "tags": [
          "substrate",
          "polkadot",
          "difficulty-intermediate"
        ],
        "order": 12
      },
      {
        "title": "What is a Pallet in Substrate?",
        "answer": "\n            <p>A <strong>Pallet</strong> is a modular component that encapsulates specific blockchain logic.</p>\n            <strong>Pallet structure:</strong>\n            <pre><code class=\"language-rust\">#[frame_support::pallet]\npub mod pallet {\n    use frame_support::pallet_prelude::*;\n    use frame_system::pallet_prelude::*;\n\n    #[pallet::pallet]\n    pub struct Pallet<T>(_);\n\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        type RuntimeEvent: From<Event<Self>>;\n        type MaxLength: Get<u32>;\n    }\n\n    #[pallet::storage]\n    pub type Balances<T: Config> = StorageMap<_, Blake2_128Concat, T::AccountId, u128>;\n\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event<T: Config> {\n        Transferred { from: T::AccountId, to: T::AccountId, amount: u128 },\n    }\n\n    #[pallet::error]\n    pub enum Error<T> {\n        InsufficientBalance,\n    }\n\n    #[pallet::call]\n    impl<T: Config> Pallet<T> {\n        #[pallet::weight(10_000)]\n        pub fn transfer(origin: OriginFor<T>, to: T::AccountId, amount: u128) -> DispatchResult {\n            let sender = ensure_signed(origin)?;\n            // Logic here\n            Ok(())\n        }\n    }\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "difficulty-intermediate"
        ],
        "order": 13
      },
      {
        "title": "How does Substrate storage work?",
        "answer": "\n            <p>Substrate provides several <strong>storage primitives</strong> for persisting blockchain state.</p>\n            <strong>Storage types:</strong>\n            <pre><code class=\"language-rust\">// Single value\n#[pallet::storage]\npub type Counter<T> = StorageValue<_, u32, ValueQuery>;\n\n// Key-value map\n#[pallet::storage]\npub type Balances<T: Config> = StorageMap<\n    _,\n    Blake2_128Concat,    // Hasher\n    T::AccountId,        // Key\n    u128,                // Value\n    ValueQuery           // Default behavior\n>;\n\n// Double map\n#[pallet::storage]\npub type Allowances<T: Config> = StorageDoubleMap<\n    _,\n    Blake2_128Concat, T::AccountId,  // Key 1\n    Blake2_128Concat, T::AccountId,  // Key 2\n    u128,                             // Value\n    ValueQuery\n>;\n\n// N-map for complex keys\n#[pallet::storage]\npub type ComplexStorage<T: Config> = StorageNMap<\n    _,\n    (NMapKey<Blake2_128Concat, u32>, NMapKey<Twox64Concat, u32>),\n    Vec<u8>,\n>;</code></pre>\n            <strong>Query types:</strong>\n            <ul>\n                <li><strong>ValueQuery:</strong> Returns default if not found</li>\n                <li><strong>OptionQuery:</strong> Returns None if not found</li>\n            </ul>\n        ",
        "tags": [
          "substrate",
          "storage",
          "difficulty-intermediate"
        ],
        "order": 14
      },
      {
        "title": "What is FRAME in Substrate?",
        "answer": "\n            <p><strong>FRAME</strong> (Framework for Runtime Aggregation of Modularized Entities) is the framework for building Substrate runtimes.</p>\n            <strong>FRAME components:</strong>\n            <ul>\n                <li><strong>frame_support:</strong> Macros and utilities for pallets</li>\n                <li><strong>frame_system:</strong> Core blockchain functionality</li>\n                <li><strong>frame_executive:</strong> Block execution orchestration</li>\n            </ul>\n            <strong>Essential pallets:</strong>\n            <pre><code class=\"language-rust\">// In runtime/lib.rs\nconstruct_runtime!(\n    pub enum Runtime where\n        Block = Block,\n        NodeBlock = opaque::Block,\n        UncheckedExtrinsic = UncheckedExtrinsic\n    {\n        System: frame_system,           // Core system\n        Timestamp: pallet_timestamp,     // Block timestamps\n        Balances: pallet_balances,       // Native token\n        TransactionPayment: pallet_transaction_payment,\n        Sudo: pallet_sudo,               // Superuser\n        \n        // Custom pallets\n        MyPallet: my_pallet,\n    }\n);</code></pre>\n        ",
        "tags": [
          "substrate",
          "frame",
          "difficulty-intermediate"
        ],
        "order": 15
      },
      {
        "title": "How do extrinsics work in Substrate?",
        "answer": "\n            <p><strong>Extrinsics</strong> are pieces of external information included in blocks - similar to transactions.</p>\n            <strong>Types of extrinsics:</strong>\n            <ul>\n                <li><strong>Signed:</strong> Regular transactions with signature</li>\n                <li><strong>Unsigned:</strong> No signature (requires validation)</li>\n                <li><strong>Inherent:</strong> Data inserted by block author (timestamp)</li>\n            </ul>\n            <pre><code class=\"language-rust\">#[pallet::call]\nimpl<T: Config> Pallet<T> {\n    // Signed extrinsic (most common)\n    #[pallet::weight(10_000)]\n    pub fn signed_action(origin: OriginFor<T>, data: u32) -> DispatchResult {\n        let who = ensure_signed(origin)?;\n        // ...\n        Ok(())\n    }\n    \n    // Unsigned extrinsic (no fee, needs validation)\n    #[pallet::weight(0)]\n    pub fn unsigned_action(origin: OriginFor<T>, data: u32) -> DispatchResult {\n        ensure_none(origin)?;\n        // ...\n        Ok(())\n    }\n}\n\n// Unsigned validation\n#[pallet::validate_unsigned]\nimpl<T: Config> ValidateUnsigned for Pallet<T> {\n    type Call = Call<T>;\n    fn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {\n        // Custom validation logic\n        ValidTransaction::with_tag_prefix(\"my_pallet\").build()\n    }\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "transactions",
          "difficulty-intermediate"
        ],
        "order": 16
      },
      {
        "title": "What is the Substrate runtime and how is it upgraded?",
        "answer": "\n            <p>The <strong>runtime</strong> is the core business logic of a Substrate blockchain, compiled to WASM.</p>\n            <strong>Runtime structure:</strong>\n            <pre><code class=\"language-rust\">#[sp_version::runtime_version]\npub const VERSION: RuntimeVersion = RuntimeVersion {\n    spec_name: create_runtime_str!(\"my-chain\"),\n    impl_name: create_runtime_str!(\"my-chain\"),\n    authoring_version: 1,\n    spec_version: 100,  // Increment for upgrades\n    impl_version: 1,\n    apis: RUNTIME_API_VERSIONS,\n    transaction_version: 1,\n    state_version: 1,\n};</code></pre>\n            <strong>Forkless upgrade process:</strong>\n            <ol>\n                <li>Build new runtime WASM</li>\n                <li>Submit runtime upgrade extrinsic (usually via governance/sudo)</li>\n                <li>New runtime stored in chain state</li>\n                <li>Next block uses new runtime</li>\n            </ol>\n            <pre><code class=\"language-rust\">// Using sudo for upgrade\n#[pallet::call]\nfn set_code(origin: OriginFor<T>, code: Vec<u8>) -> DispatchResult {\n    ensure_root(origin)?;\n    Self::can_set_code(&code)?;\n    T::OnSetCode::on_set_code(code);\n    Ok(())\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "runtime",
          "difficulty-advanced"
        ],
        "order": 17
      },
      {
        "title": "What is the difference between native and WASM runtime?",
        "answer": "\n            <p>Substrate nodes can execute runtime in two ways: <strong>native</strong> (compiled for host) or <strong>WASM</strong> (portable).</p>\n            <table>\n                <tr><th>Aspect</th><th>Native</th><th>WASM</th></tr>\n                <tr><td>Speed</td><td>Faster</td><td>~2x slower</td></tr>\n                <tr><td>Upgrades</td><td>Requires node restart</td><td>Hot-swappable</td></tr>\n                <tr><td>Consensus</td><td>May diverge</td><td>Deterministic</td></tr>\n                <tr><td>Use case</td><td>Development</td><td>Production</td></tr>\n            </table>\n            <strong>Execution strategies:</strong>\n            <pre><code class=\"language-bash\"># In node config\n--execution native     # Use native only\n--execution wasm       # Use WASM only (default)\n--execution both       # Execute both, compare results</code></pre>\n            <strong>Why WASM matters:</strong>\n            <ul>\n                <li>Forkless upgrades possible</li>\n                <li>Guaranteed determinism across nodes</li>\n                <li>Light client execution</li>\n            </ul>\n        ",
        "tags": [
          "substrate",
          "runtime",
          "difficulty-advanced"
        ],
        "order": 18
      },
      {
        "title": "How does Substrate handle weights and fees?",
        "answer": "\n            <p><strong>Weights</strong> represent computational cost in Substrate, translated to fees.</p>\n            <strong>Weight calculation:</strong>\n            <pre><code class=\"language-rust\">// Simple constant weight\n#[pallet::weight(10_000)]\npub fn simple_action(origin: OriginFor<T>) -> DispatchResult {\n    // ...\n}\n\n// Dynamic weight\n#[pallet::weight(T::WeightInfo::complex_action(data.len() as u32))]\npub fn complex_action(origin: OriginFor<T>, data: Vec<u8>) -> DispatchResult {\n    // ...\n}\n\n// Benchmarked weights (recommended)\n#[pallet::weight(T::WeightInfo::transfer())]\npub fn transfer(origin: OriginFor<T>, to: T::AccountId, amount: u128) \n    -> DispatchResultWithPostInfo \n{\n    // ...\n    // Return actual weight consumed\n    Ok(Some(actual_weight).into())\n}</code></pre>\n            <strong>Fee calculation:</strong>\n            <pre><code>fee = base_fee + (weight * weight_to_fee) + length_fee + tip</code></pre>\n            <strong>Benchmarking:</strong>\n            <pre><code class=\"language-rust\">#[benchmarks]\nmod benchmarks {\n    #[benchmark]\n    fn transfer() {\n        let caller: T::AccountId = whitelisted_caller();\n        #[extrinsic_call]\n        transfer(RawOrigin::Signed(caller), recipient, 1000);\n    }\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "fees",
          "difficulty-intermediate"
        ],
        "order": 19
      },
      {
        "title": "What are hooks in Substrate pallets?",
        "answer": "\n            <p><strong>Hooks</strong> allow pallets to execute logic at specific points in the block lifecycle.</p>\n            <pre><code class=\"language-rust\">#[pallet::hooks]\nimpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n    // Start of each block\n    fn on_initialize(n: BlockNumberFor<T>) -> Weight {\n        log::info!(\"Block {} starting\", n);\n        Weight::zero()\n    }\n    \n    // End of each block  \n    fn on_finalize(n: BlockNumberFor<T>) {\n        log::info!(\"Block {} finalizing\", n);\n    }\n    \n    // After all extrinsics, before finalize\n    fn on_idle(n: BlockNumberFor<T>, remaining_weight: Weight) -> Weight {\n        // Use remaining block weight for cleanup\n        Self::do_cleanup(remaining_weight)\n    }\n    \n    // After runtime upgrade\n    fn on_runtime_upgrade() -> Weight {\n        migration::migrate::<T>()\n    }\n    \n    // Check runtime invariants (dev mode)\n    #[cfg(feature = \"try-runtime\")]\n    fn try_state(_n: BlockNumberFor<T>) -> Result<(), &'static str> {\n        Self::check_invariants()\n    }\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "hooks",
          "difficulty-intermediate"
        ],
        "order": 20
      },
      {
        "title": "How does cross-pallet communication work in Substrate?",
        "answer": "\n            <p>Pallets can interact through <strong>tight coupling</strong> or <strong>loose coupling</strong>.</p>\n            <strong>Tight coupling (direct dependency):</strong>\n            <pre><code class=\"language-rust\">// Your pallet depends on Balances\n#[pallet::config]\npub trait Config: frame_system::Config + pallet_balances::Config {\n    // ...\n}\n\n// Direct call to Balances pallet\nimpl<T: Config> Pallet<T> {\n    fn pay(who: &T::AccountId, amount: T::Balance) {\n        pallet_balances::Pallet::<T>::transfer(...);\n    }\n}</code></pre>\n            <strong>Loose coupling (traits):</strong>\n            <pre><code class=\"language-rust\">// Define trait for what you need\npub trait Currency<AccountId> {\n    type Balance;\n    fn transfer(from: &AccountId, to: &AccountId, amount: Self::Balance);\n}\n\n// Your pallet uses the trait\n#[pallet::config]\npub trait Config: frame_system::Config {\n    type Currency: Currency<Self::AccountId>;\n}\n\n// In runtime, wire it up\nimpl my_pallet::Config for Runtime {\n    type Currency = Balances;  // pallet_balances implements Currency\n}</code></pre>\n            <strong>Benefits of loose coupling:</strong> Testability, flexibility, cleaner dependencies\n        ",
        "tags": [
          "substrate",
          "difficulty-intermediate"
        ],
        "order": 21
      },
      {
        "title": "What is an Origin in Substrate?",
        "answer": "\n            <p><strong>Origin</strong> identifies who or what is calling a dispatchable function.</p>\n            <strong>Common origin types:</strong>\n            <pre><code class=\"language-rust\">// Signed - regular user\npub fn user_action(origin: OriginFor<T>) -> DispatchResult {\n    let who = ensure_signed(origin)?;\n    // who is the signing account\n}\n\n// Root - sudo/governance (superuser)\npub fn privileged_action(origin: OriginFor<T>) -> DispatchResult {\n    ensure_root(origin)?;\n    // Only root can call\n}\n\n// None - inherent or unsigned\npub fn inherent_action(origin: OriginFor<T>) -> DispatchResult {\n    ensure_none(origin)?;\n    // No sender\n}\n\n// Custom origins\npub fn council_action(origin: OriginFor<T>) -> DispatchResult {\n    T::CouncilOrigin::ensure_origin(origin)?;\n    // Only council can call\n}</code></pre>\n            <strong>Creating custom origins:</strong>\n            <pre><code class=\"language-rust\">#[pallet::origin]\npub enum Origin {\n    Council,\n    TechnicalCommittee,\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "security",
          "difficulty-intermediate"
        ],
        "order": 22
      },
      {
        "title": "How do you write tests for Substrate pallets?",
        "answer": "\n            <p>Substrate provides a <strong>mock runtime</strong> system for unit testing pallets.</p>\n            <pre><code class=\"language-rust\">// tests.rs or mock.rs\nuse crate as my_pallet;\nuse frame_support::{parameter_types, traits::ConstU32};\nuse sp_runtime::testing::Header;\n\ntype UncheckedExtrinsic = frame_system::mocking::MockUncheckedExtrinsic<Test>;\ntype Block = frame_system::mocking::MockBlock<Test>;\n\n// Construct test runtime\nframe_support::construct_runtime!(\n    pub enum Test where\n        Block = Block,\n        NodeBlock = Block,\n        UncheckedExtrinsic = UncheckedExtrinsic,\n    {\n        System: frame_system,\n        Balances: pallet_balances,\n        MyPallet: my_pallet,\n    }\n);\n\n// Configure mock runtime\nimpl frame_system::Config for Test {\n    type AccountId = u64;\n    // ... other configs\n}\n\nimpl my_pallet::Config for Test {\n    type RuntimeEvent = RuntimeEvent;\n}\n\n// Test helper\nfn new_test_ext() -> sp_io::TestExternalities {\n    let mut t = frame_system::GenesisConfig::default().build_storage::<Test>().unwrap();\n    // Add initial state\n    t.into()\n}\n\n// Actual tests\n#[test]\nfn transfer_works() {\n    new_test_ext().execute_with(|| {\n        assert_ok!(MyPallet::transfer(RuntimeOrigin::signed(1), 2, 100));\n        assert_eq!(MyPallet::balance(2), 100);\n    });\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "testing",
          "difficulty-intermediate"
        ],
        "order": 23
      },
      {
        "title": "What is Polkadot's XCM (Cross-Consensus Messaging)?",
        "answer": "\n            <p><strong>XCM</strong> is a messaging format for communication between different consensus systems (parachains, relay chain).</p>\n            <strong>XCM basics:</strong>\n            <pre><code class=\"language-rust\">// XCM message structure\nlet message = Xcm(vec![\n    WithdrawAsset((Here, 1_000_000).into()),\n    BuyExecution { fees: (Here, 100_000).into(), weight_limit: Limited(1_000) },\n    DepositAsset { \n        assets: All.into(), \n        beneficiary: AccountId32 { network: None, id: recipient.into() }.into() \n    },\n]);\n\n// Send XCM\npallet_xcm::Pallet::<T>::send_xcm(\n    Here,\n    Parachain(1000),  // Destination\n    message,\n)?;</code></pre>\n            <strong>Key XCM instructions:</strong>\n            <ul>\n                <li><strong>WithdrawAsset:</strong> Take assets from origin</li>\n                <li><strong>DepositAsset:</strong> Put assets somewhere</li>\n                <li><strong>BuyExecution:</strong> Pay for execution</li>\n                <li><strong>Transact:</strong> Execute encoded call</li>\n                <li><strong>TransferAsset:</strong> Combined withdraw+deposit</li>\n            </ul>\n            <strong>MultiLocation:</strong> Describes locations across consensus\n            <pre><code class=\"language-rust\">// Relay chain\nParent\n// Parachain 1000\nParachain(1000)\n// Account on parachain\n(Parachain(1000), AccountId32 { id: [1u8; 32], network: None })</code></pre>\n        ",
        "tags": [
          "substrate",
          "polkadot",
          "xcm",
          "difficulty-advanced"
        ],
        "order": 24
      },
      {
        "title": "How do you implement a Substrate RPC extension?",
        "answer": "\n            <p><strong>RPC extensions</strong> expose custom node APIs for external interaction.</p>\n            <strong>Define RPC trait:</strong>\n            <pre><code class=\"language-rust\">// Runtime API (in runtime)\nsp_api::decl_runtime_api! {\n    pub trait MyApi {\n        fn get_value(key: Vec<u8>) -> Option<Vec<u8>>;\n    }\n}\n\n// RPC trait (in rpc crate)\n#[rpc(server)]\npub trait MyRpcApi<BlockHash> {\n    #[method(name = \"my_getValue\")]\n    fn get_value(&self, key: Vec<u8>, at: Option<BlockHash>) -> RpcResult<Option<Vec<u8>>>;\n}\n\n// Implementation\npub struct MyRpc<C, Block> {\n    client: Arc<C>,\n    _marker: PhantomData<Block>,\n}\n\nimpl<C, Block> MyRpcApiServer<<Block as BlockT>::Hash> for MyRpc<C, Block>\nwhere\n    C: ProvideRuntimeApi<Block> + Send + Sync + 'static,\n    C::Api: MyApi<Block>,\n    Block: BlockT,\n{\n    fn get_value(&self, key: Vec<u8>, at: Option<<Block as BlockT>::Hash>) -> RpcResult<Option<Vec<u8>>> {\n        let api = self.client.runtime_api();\n        let at = at.unwrap_or_else(|| self.client.info().best_hash);\n        api.get_value(at, key).map_err(|e| Error::RuntimeError(e.to_string()))\n    }\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "rpc",
          "difficulty-advanced"
        ],
        "order": 25
      },
      {
        "title": "What is off-chain workers in Substrate?",
        "answer": "\n            <p><strong>Off-chain workers</strong> run outside the blockchain runtime but can interact with it.</p>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Fetching external data (oracles)</li>\n                <li>Expensive computations</li>\n                <li>Sleeping/waiting</li>\n                <li>Submitting unsigned transactions</li>\n            </ul>\n            <pre><code class=\"language-rust\">#[pallet::hooks]\nimpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n    fn offchain_worker(block_number: BlockNumberFor<T>) {\n        // Runs after block import\n        log::info!(\"OCW running for block {:?}\", block_number);\n        \n        // HTTP request\n        let response = http::Request::get(\"https://api.example.com/price\")\n            .send()\n            .unwrap();\n        let price: u32 = response.body().collect().unwrap();\n        \n        // Submit unsigned transaction with result\n        let call = Call::submit_price { price };\n        SubmitTransaction::<T, Call<T>>::submit_unsigned_transaction(call.into());\n    }\n}\n\n// Off-chain storage (local to node)\nfn store_locally(key: &[u8], value: &[u8]) {\n    sp_io::offchain::local_storage_set(StorageKind::PERSISTENT, key, value);\n}</code></pre>\n        ",
        "tags": [
          "substrate",
          "offchain",
          "difficulty-advanced"
        ],
        "order": 26
      },
      {
        "title": "What is the difference between ink! and Substrate pallets?",
        "answer": "\n            <p><strong>ink!</strong> is for smart contracts, while <strong>pallets</strong> are for runtime modules.</p>\n            <table>\n                <tr><th>Aspect</th><th>ink! Contracts</th><th>Pallets</th></tr>\n                <tr><td>Deployment</td><td>By users anytime</td><td>At genesis or upgrade</td></tr>\n                <tr><td>Execution</td><td>In sandbox (metered)</td><td>Native runtime</td></tr>\n                <tr><td>Trust level</td><td>Untrusted code</td><td>Trusted, audited</td></tr>\n                <tr><td>Upgrades</td><td>User-controlled</td><td>Governance</td></tr>\n                <tr><td>Gas/Weight</td><td>Gas metering</td><td>Weights (can refund)</td></tr>\n                <tr><td>Storage</td><td>Per-contract</td><td>Chain-wide</td></tr>\n                <tr><td>Use case</td><td>User applications</td><td>Core chain features</td></tr>\n            </table>\n            <strong>When to use each:</strong>\n            <ul>\n                <li><strong>Pallet:</strong> Core functionality, needs high performance</li>\n                <li><strong>ink!:</strong> User-deployed apps, rapid iteration</li>\n            </ul>\n        ",
        "tags": [
          "substrate",
          "ink",
          "difficulty-intermediate"
        ],
        "order": 27
      },
      {
        "title": "What is Solana's programming model?",
        "answer": "\n            <p><strong>Solana</strong> uses a unique account-based programming model with programs written in Rust.</p>\n            <strong>Key concepts:</strong>\n            <ul>\n                <li><strong>Programs:</strong> Stateless executable code (smart contracts)</li>\n                <li><strong>Accounts:</strong> Store state and SOL balances</li>\n                <li><strong>Instructions:</strong> Commands to programs with accounts</li>\n                <li><strong>Transactions:</strong> Bundles of instructions</li>\n            </ul>\n            <strong>Account structure:</strong>\n            <pre><code class=\"language-rust\">pub struct Account {\n    pub lamports: u64,          // Balance (1 SOL = 1B lamports)\n    pub data: Vec<u8>,          // Arbitrary data\n    pub owner: Pubkey,          // Program that owns this account\n    pub executable: bool,        // Is this a program?\n    pub rent_epoch: u64,        // Rent tracking\n}</code></pre>\n            <strong>Key differences from Ethereum:</strong>\n            <ul>\n                <li>State stored in accounts, not in programs</li>\n                <li>Programs are stateless</li>\n                <li>Parallel transaction execution</li>\n            </ul>\n        ",
        "tags": [
          "solana",
          "difficulty-intermediate"
        ],
        "order": 28
      },
      {
        "title": "How do you create a Solana program with Anchor?",
        "answer": "\n            <p><strong>Anchor</strong> is a framework for Solana that simplifies program development.</p>\n            <strong>Basic Anchor program:</strong>\n            <pre><code class=\"language-rust\">use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod my_program {\n    use super::*;\n    \n    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {\n        let my_account = &mut ctx.accounts.my_account;\n        my_account.data = data;\n        my_account.authority = ctx.accounts.authority.key();\n        Ok(())\n    }\n    \n    pub fn update(ctx: Context<Update>, new_data: u64) -> Result<()> {\n        let my_account = &mut ctx.accounts.my_account;\n        my_account.data = new_data;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(init, payer = authority, space = 8 + 8 + 32)]\n    pub my_account: Account<'info, MyAccount>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Update<'info> {\n    #[account(mut, has_one = authority)]\n    pub my_account: Account<'info, MyAccount>,\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct MyAccount {\n    pub data: u64,\n    pub authority: Pubkey,\n}</code></pre>\n        ",
        "tags": [
          "solana",
          "anchor",
          "difficulty-intermediate"
        ],
        "order": 29
      },
      {
        "title": "What are PDAs (Program Derived Addresses) in Solana?",
        "answer": "\n            <p><strong>PDAs</strong> are deterministic addresses that programs can sign for, enabling program-owned accounts.</p>\n            <strong>Creating a PDA:</strong>\n            <pre><code class=\"language-rust\">// Finding a PDA\nlet (pda, bump) = Pubkey::find_program_address(\n    &[\n        b\"my_seed\",\n        user.key().as_ref(),\n    ],\n    program_id\n);\n\n// In Anchor\n#[derive(Accounts)]\npub struct CreateVault<'info> {\n    #[account(\n        init,\n        seeds = [b\"vault\", user.key().as_ref()],\n        bump,\n        payer = user,\n        space = 8 + 32 + 8\n    )]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n// Using PDA to sign\nlet seeds = &[b\"vault\", user.key().as_ref(), &[bump]];\nlet signer_seeds = &[&seeds[..]];\n\ninvoke_signed(\n    &transfer_instruction,\n    &[vault.to_account_info(), destination.to_account_info()],\n    signer_seeds\n)?;</code></pre>\n            <strong>Use cases:</strong> Vaults, escrows, token accounts, program configuration\n        ",
        "tags": [
          "solana",
          "pda",
          "difficulty-intermediate"
        ],
        "order": 30
      },
      {
        "title": "How does Solana's rent system work?",
        "answer": "\n            <p><strong>Rent</strong> is the fee for storing data on Solana. Accounts must maintain minimum balance or be rent-exempt.</p>\n            <strong>Rent calculation:</strong>\n            <pre><code class=\"language-rust\">// Minimum rent-exempt balance\nlet rent = Rent::get()?;\nlet min_balance = rent.minimum_balance(account_data_size);\n\n// In Anchor - automatic calculation\n#[account(init, payer = user, space = 8 + 32 + 8)]\npub my_account: Account<'info, MyAccount>,\n// Space: 8 (discriminator) + 32 (Pubkey) + 8 (u64)</code></pre>\n            <strong>Rent rules:</strong>\n            <ul>\n                <li><strong>Rent-exempt:</strong> Hold 2 years of rent (permanent)</li>\n                <li><strong>Rent collection:</strong> Deducted on transaction touch</li>\n                <li><strong>Account deletion:</strong> Balance hits 0, account removed</li>\n            </ul>\n            <strong>Space calculation:</strong>\n            <pre><code class=\"language-rust\">// Common type sizes\nPubkey: 32 bytes\nu64: 8 bytes\nbool: 1 byte\nString: 4 + length bytes\nVec<T>: 4 + (length * size_of::<T>())\nOption<T>: 1 + size_of::<T>()</code></pre>\n        ",
        "tags": [
          "solana",
          "rent",
          "difficulty-intermediate"
        ],
        "order": 31
      },
      {
        "title": "What is CPIs (Cross-Program Invocations) in Solana?",
        "answer": "\n            <p><strong>CPI</strong> allows a Solana program to call another program's instructions.</p>\n            <strong>Basic CPI:</strong>\n            <pre><code class=\"language-rust\">use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Transfer, Token, TokenAccount};\n\n// CPI to transfer tokens\npub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {\n    let cpi_accounts = Transfer {\n        from: ctx.accounts.from.to_account_info(),\n        to: ctx.accounts.to.to_account_info(),\n        authority: ctx.accounts.authority.to_account_info(),\n    };\n    let cpi_program = ctx.accounts.token_program.to_account_info();\n    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n    \n    token::transfer(cpi_ctx, amount)?;\n    Ok(())\n}\n\n// CPI with PDA signer\npub fn transfer_from_vault(ctx: Context<TransferFromVault>, amount: u64) -> Result<()> {\n    let seeds = &[b\"vault\", ctx.accounts.user.key().as_ref(), &[ctx.bumps.vault]];\n    let signer_seeds = &[&seeds[..]];\n    \n    let cpi_ctx = CpiContext::new_with_signer(\n        ctx.accounts.token_program.to_account_info(),\n        Transfer {\n            from: ctx.accounts.vault_token.to_account_info(),\n            to: ctx.accounts.user_token.to_account_info(),\n            authority: ctx.accounts.vault.to_account_info(),\n        },\n        signer_seeds\n    );\n    \n    token::transfer(cpi_ctx, amount)\n}</code></pre>\n        ",
        "tags": [
          "solana",
          "cpi",
          "difficulty-intermediate"
        ],
        "order": 32
      },
      {
        "title": "How do you handle errors in Solana/Anchor programs?",
        "answer": "\n            <p>Anchor provides structured error handling with custom error codes.</p>\n            <strong>Defining errors:</strong>\n            <pre><code class=\"language-rust\">#[error_code]\npub enum MyError {\n    #[msg(\"You are not authorized to perform this action\")]\n    Unauthorized,\n    #[msg(\"Insufficient funds: required {required}, available {available}\")]\n    InsufficientFunds { required: u64, available: u64 },\n    #[msg(\"Invalid parameter provided\")]\n    InvalidParameter,\n    #[msg(\"Account already initialized\")]\n    AlreadyInitialized,\n}\n\n// Using errors\npub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {\n    require!(\n        ctx.accounts.vault.authority == ctx.accounts.user.key(),\n        MyError::Unauthorized\n    );\n    \n    require_gte!(\n        ctx.accounts.vault.balance,\n        amount,\n        MyError::InsufficientFunds { \n            required: amount, \n            available: ctx.accounts.vault.balance \n        }\n    );\n    \n    // Proceed with withdrawal\n    Ok(())\n}</code></pre>\n            <strong>Anchor constraints as validation:</strong>\n            <pre><code class=\"language-rust\">#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(\n        mut,\n        constraint = vault.authority == user.key() @ MyError::Unauthorized\n    )]\n    pub vault: Account<'info, Vault>,\n    pub user: Signer<'info>,\n}</code></pre>\n        ",
        "tags": [
          "solana",
          "anchor",
          "errors",
          "difficulty-intermediate"
        ],
        "order": 33
      },
      {
        "title": "What are Solana's account constraints in Anchor?",
        "answer": "\n            <p>Anchor <strong>constraints</strong> validate accounts before instruction execution.</p>\n            <strong>Common constraints:</strong>\n            <pre><code class=\"language-rust\">#[derive(Accounts)]\npub struct MyInstruction<'info> {\n    // Initialize new account\n    #[account(init, payer = user, space = 8 + 32)]\n    pub new_account: Account<'info, MyAccount>,\n    \n    // Mutable account\n    #[account(mut)]\n    pub mutable_account: Account<'info, MyAccount>,\n    \n    // PDA with seeds\n    #[account(\n        seeds = [b\"config\", user.key().as_ref()],\n        bump\n    )]\n    pub config: Account<'info, Config>,\n    \n    // Ownership check\n    #[account(has_one = authority)]\n    pub owned_account: Account<'info, MyAccount>,\n    \n    // Custom constraint\n    #[account(constraint = amount > 0 @ MyError::InvalidAmount)]\n    pub data_account: Account<'info, Data>,\n    \n    // Close account (send lamports to user)\n    #[account(mut, close = user)]\n    pub closeable: Account<'info, Temp>,\n    \n    // Realloc (resize account)\n    #[account(mut, realloc = 100, realloc::payer = user, realloc::zero = true)]\n    pub resizable: Account<'info, Resizable>,\n    \n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}</code></pre>\n        ",
        "tags": [
          "solana",
          "anchor",
          "difficulty-intermediate"
        ],
        "order": 34
      },
      {
        "title": "How do you create SPL tokens with Rust?",
        "answer": "\n            <p><strong>SPL Token</strong> is Solana's token standard, similar to ERC-20.</p>\n            <strong>Creating a token mint:</strong>\n            <pre><code class=\"language-rust\">use anchor_spl::token::{Mint, Token, TokenAccount, MintTo};\n\n#[derive(Accounts)]\npub struct CreateToken<'info> {\n    #[account(\n        init,\n        payer = authority,\n        mint::decimals = 9,\n        mint::authority = authority,\n    )]\n    pub mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n    pub system_program: Program<'info, System>,\n    pub rent: Sysvar<'info, Rent>,\n}\n\n// Minting tokens\npub fn mint_tokens(ctx: Context<MintTokens>, amount: u64) -> Result<()> {\n    let cpi_accounts = MintTo {\n        mint: ctx.accounts.mint.to_account_info(),\n        to: ctx.accounts.token_account.to_account_info(),\n        authority: ctx.accounts.authority.to_account_info(),\n    };\n    let cpi_ctx = CpiContext::new(\n        ctx.accounts.token_program.to_account_info(), \n        cpi_accounts\n    );\n    token::mint_to(cpi_ctx, amount)\n}\n\n#[derive(Accounts)]\npub struct MintTokens<'info> {\n    #[account(mut)]\n    pub mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}</code></pre>\n        ",
        "tags": [
          "solana",
          "tokens",
          "difficulty-intermediate"
        ],
        "order": 35
      },
      {
        "title": "What is Solana's transaction structure?",
        "answer": "\n            <p>Solana transactions bundle multiple instructions with signatures and account references.</p>\n            <strong>Transaction anatomy:</strong>\n            <pre><code class=\"language-rust\">// Transaction structure\nstruct Transaction {\n    signatures: Vec<Signature>,     // All required signatures\n    message: Message {\n        header: MessageHeader {\n            num_required_signatures: u8,\n            num_readonly_signed: u8,\n            num_readonly_unsigned: u8,\n        },\n        account_keys: Vec<Pubkey>,  // All accounts used\n        recent_blockhash: Hash,      // For replay protection\n        instructions: Vec<CompiledInstruction>,\n    }\n}\n\n// Building a transaction in Anchor client\nlet tx = Transaction::new_signed_with_payer(\n    &[\n        instruction1,\n        instruction2,  // Multiple instructions\n    ],\n    Some(&payer.pubkey()),\n    &[&payer, &other_signer],\n    recent_blockhash,\n);</code></pre>\n            <strong>Transaction limits:</strong>\n            <ul>\n                <li>Max 1232 bytes per transaction</li>\n                <li>Max 64 accounts per transaction</li>\n                <li>Max 200k compute units (default)</li>\n            </ul>\n        ",
        "tags": [
          "solana",
          "transactions",
          "difficulty-intermediate"
        ],
        "order": 36
      },
      {
        "title": "How does Solana achieve parallel execution?",
        "answer": "\n            <p><strong>Sealevel</strong> is Solana's parallel smart contract runtime.</p>\n            <strong>How it works:</strong>\n            <ul>\n                <li>Transactions declare accounts upfront</li>\n                <li>Non-overlapping transactions run in parallel</li>\n                <li>Overlapping transactions run sequentially</li>\n            </ul>\n            <pre><code class=\"language-rust\">// Tx1: Uses accounts [A, B]\n// Tx2: Uses accounts [C, D]\n// Tx3: Uses accounts [A, C]\n\n// Execution:\n// Parallel:   Tx1 || Tx2  (no overlap)\n// Sequential: Tx3 after Tx1 and Tx2 (overlaps with both)</code></pre>\n            <strong>Optimization tips:</strong>\n            <pre><code class=\"language-rust\">// Bad: Single global account bottleneck\n#[account(mut)]\npub global_state: Account<'info, GlobalState>,\n\n// Good: Per-user accounts (parallelizable)\n#[account(\n    seeds = [b\"user_state\", user.key().as_ref()],\n    bump\n)]\npub user_state: Account<'info, UserState>,</code></pre>\n            <strong>Account locking:</strong> Read-only accounts can be shared, writable accounts are exclusive\n        ",
        "tags": [
          "solana",
          "sealevel",
          "difficulty-advanced"
        ],
        "order": 37
      },
      {
        "title": "What is NEAR Protocol's programming model?",
        "answer": "\n            <p><strong>NEAR Protocol</strong> uses a sharded, proof-of-stake blockchain with smart contracts written in Rust or AssemblyScript.</p>\n            <strong>Key concepts:</strong>\n            <ul>\n                <li><strong>Accounts:</strong> Human-readable names (alice.near)</li>\n                <li><strong>Access Keys:</strong> Full-access and function-call keys</li>\n                <li><strong>Sharding:</strong> Nightshade dynamic sharding</li>\n                <li><strong>Gas:</strong> Prepaid compute in NEAR tokens</li>\n            </ul>\n            <strong>Account structure:</strong>\n            <pre><code class=\"language-rust\">// NEAR accounts can have:\n// - Balance (NEAR tokens)\n// - Contract code (WASM)\n// - Storage (key-value)\n// - Access keys (for signing)\n\n// Account naming:\n// Top-level: alice.near\n// Sub-accounts: app.alice.near</code></pre>\n            <strong>Contract example:</strong>\n            <pre><code class=\"language-rust\">use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::{near_bindgen, env};\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct Contract {\n    greeting: String,\n}\n\n#[near_bindgen]\nimpl Contract {\n    #[init]\n    pub fn new(greeting: String) -> Self {\n        Self { greeting }\n    }\n    \n    pub fn get_greeting(&self) -> String {\n        self.greeting.clone()\n    }\n    \n    pub fn set_greeting(&mut self, greeting: String) {\n        self.greeting = greeting;\n    }\n}</code></pre>\n        ",
        "tags": [
          "near",
          "difficulty-intermediate"
        ],
        "order": 38
      },
      {
        "title": "How do cross-contract calls work in NEAR?",
        "answer": "\n            <p>NEAR supports <strong>asynchronous cross-contract calls</strong> with promises.</p>\n            <strong>Cross-contract call pattern:</strong>\n            <pre><code class=\"language-rust\">use near_sdk::{ext_contract, Promise, Gas, Balance};\n\nconst TGAS: Gas = Gas(10u64.pow(12));\nconst NO_DEPOSIT: Balance = 0;\n\n// Define external contract interface\n#[ext_contract(ext_ft)]\npub trait FungibleToken {\n    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128);\n    fn ft_balance_of(&self, account_id: AccountId) -> U128;\n}\n\n// Define callback interface\n#[ext_contract(ext_self)]\npub trait ExtSelf {\n    fn callback_after_transfer(&self) -> bool;\n}\n\n#[near_bindgen]\nimpl Contract {\n    pub fn transfer_tokens(&self, token: AccountId, to: AccountId, amount: U128) -> Promise {\n        ext_ft::ext(token)\n            .with_attached_deposit(1)\n            .with_static_gas(Gas(5 * TGAS))\n            .ft_transfer(to, amount)\n            .then(\n                ext_self::ext(env::current_account_id())\n                    .with_static_gas(Gas(5 * TGAS))\n                    .callback_after_transfer()\n            )\n    }\n    \n    #[private]  // Only callable by this contract\n    pub fn callback_after_transfer(&self) -> bool {\n        match env::promise_result(0) {\n            PromiseResult::Successful(_) => true,\n            _ => false,\n        }\n    }\n}</code></pre>\n        ",
        "tags": [
          "near",
          "cross-contract",
          "difficulty-intermediate"
        ],
        "order": 39
      },
      {
        "title": "What is NEAR's storage staking model?",
        "answer": "\n            <p>NEAR uses <strong>storage staking</strong> where accounts lock NEAR tokens proportional to storage used.</p>\n            <strong>Storage costs:</strong>\n            <pre><code class=\"language-rust\">// 1 NEAR = 10 KB of storage\n// 0.00001 NEAR per byte\n\n// Managing storage in contracts\nuse near_sdk::collections::{LookupMap, UnorderedMap};\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct Contract {\n    // Efficient storage collections\n    records: LookupMap<AccountId, Record>,\n    items: UnorderedMap<String, Item>,\n}\n\nimpl Contract {\n    // Storage deposit pattern\n    #[payable]\n    pub fn storage_deposit(&mut self) {\n        let account_id = env::predecessor_account_id();\n        let deposit = env::attached_deposit();\n        \n        // Track storage per user\n        let storage_before = env::storage_usage();\n        self.internal_register_account(&account_id);\n        let storage_after = env::storage_usage();\n        \n        let storage_cost = (storage_after - storage_before) as u128 \n            * env::storage_byte_cost();\n        \n        assert!(deposit >= storage_cost, \"Insufficient deposit\");\n        \n        // Refund excess\n        if deposit > storage_cost {\n            Promise::new(account_id).transfer(deposit - storage_cost);\n        }\n    }\n}</code></pre>\n        ",
        "tags": [
          "near",
          "storage",
          "difficulty-intermediate"
        ],
        "order": 40
      },
      {
        "title": "How do you implement NEP-141 (Fungible Token) in NEAR?",
        "answer": "\n            <p><strong>NEP-141</strong> is NEAR's fungible token standard, similar to ERC-20.</p>\n            <pre><code class=\"language-rust\">use near_sdk::json_types::U128;\nuse near_sdk::{near_bindgen, AccountId, Balance, Promise};\n\n// Core trait\npub trait FungibleTokenCore {\n    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);\n    fn ft_transfer_call(&mut self, receiver_id: AccountId, amount: U128, \n                        memo: Option<String>, msg: String) -> Promise;\n    fn ft_total_supply(&self) -> U128;\n    fn ft_balance_of(&self, account_id: AccountId) -> U128;\n}\n\n#[near_bindgen]\nimpl FungibleTokenCore for Contract {\n    #[payable]\n    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {\n        assert_one_yocto();  // Require 1 yoctoNEAR for security\n        let sender_id = env::predecessor_account_id();\n        let amount: Balance = amount.into();\n        \n        self.internal_transfer(&sender_id, &receiver_id, amount, memo);\n    }\n    \n    fn ft_balance_of(&self, account_id: AccountId) -> U128 {\n        self.accounts.get(&account_id).unwrap_or(0).into()\n    }\n    \n    fn ft_total_supply(&self) -> U128 {\n        self.total_supply.into()\n    }\n}</code></pre>\n            <strong>Using the SDK:</strong>\n            <pre><code class=\"language-rust\">use near_contract_standards::fungible_token::FungibleToken;\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract {\n    token: FungibleToken,\n}\n\n#[near_bindgen]\nimpl Contract {\n    #[init]\n    pub fn new(total_supply: U128) -> Self {\n        let mut token = FungibleToken::new(b\"t\".to_vec());\n        token.internal_register_account(&env::predecessor_account_id());\n        token.internal_deposit(&env::predecessor_account_id(), total_supply.into());\n        Self { token }\n    }\n}</code></pre>\n        ",
        "tags": [
          "near",
          "tokens",
          "difficulty-intermediate"
        ],
        "order": 41
      },
      {
        "title": "What are NEAR access keys and how do they work?",
        "answer": "\n            <p>NEAR has a unique <strong>access key</strong> system for flexible account security.</p>\n            <strong>Access key types:</strong>\n            <pre><code class=\"language-rust\">// Full Access Key\n// - Can do anything: transfer, deploy, delete account\n// - Like a master key\n\n// Function Call Key\n// - Limited to specific contract methods\n// - Optional allowance (gas budget)\n// - Great for dApp sessions\n\n// Adding keys programmatically\n#[near_bindgen]\nimpl Contract {\n    pub fn add_access_key(&self, public_key: PublicKey) -> Promise {\n        Promise::new(env::current_account_id()).add_access_key(\n            public_key,\n            250000000000000000000000,  // Allowance: 0.25 NEAR\n            env::current_account_id(),  // Receiver\n            \"increment,decrement\".to_string(),  // Methods\n        )\n    }\n    \n    // Remove access key\n    pub fn remove_access_key(&self, public_key: PublicKey) -> Promise {\n        Promise::new(env::current_account_id()).delete_key(public_key)\n    }\n}</code></pre>\n            <strong>Use cases:</strong>\n            <ul>\n                <li>Session keys for games (no popup per action)</li>\n                <li>Limited access for team members</li>\n                <li>Subscription services with allowance</li>\n            </ul>\n        ",
        "tags": [
          "near",
          "security",
          "difficulty-intermediate"
        ],
        "order": 42
      },
      {
        "title": "How do you test NEAR smart contracts?",
        "answer": "\n            <p>NEAR provides unit testing and simulation testing frameworks.</p>\n            <strong>Unit tests:</strong>\n            <pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use super::*;\n    use near_sdk::test_utils::{accounts, VMContextBuilder};\n    use near_sdk::testing_env;\n\n    fn get_context(predecessor: AccountId) -> VMContextBuilder {\n        let mut builder = VMContextBuilder::new();\n        builder\n            .predecessor_account_id(predecessor)\n            .current_account_id(accounts(0))\n            .signer_account_id(predecessor)\n            .attached_deposit(1);\n        builder\n    }\n\n    #[test]\n    fn test_transfer() {\n        let context = get_context(accounts(1));\n        testing_env!(context.build());\n        \n        let mut contract = Contract::new(U128(1000));\n        \n        contract.ft_transfer(accounts(2), U128(100), None);\n        \n        assert_eq!(contract.ft_balance_of(accounts(1)), U128(900));\n        assert_eq!(contract.ft_balance_of(accounts(2)), U128(100));\n    }\n    \n    #[test]\n    #[should_panic(expected = \"Insufficient balance\")]\n    fn test_transfer_insufficient_balance() {\n        let context = get_context(accounts(1));\n        testing_env!(context.build());\n        \n        let mut contract = Contract::new(U128(100));\n        contract.ft_transfer(accounts(2), U128(200), None);\n    }\n}</code></pre>\n            <strong>Workspaces-rs (simulation testing):</strong>\n            <pre><code class=\"language-rust\">use near_workspaces::{Account, Contract, Worker};\n\n#[tokio::test]\nasync fn test_cross_contract() -> anyhow::Result<()> {\n    let worker = near_workspaces::sandbox().await?;\n    let contract = worker.dev_deploy(include_bytes!(\"../out/contract.wasm\")).await?;\n    \n    let result = contract.call(\"set_greeting\")\n        .args_json(json!({\"greeting\": \"Hello\"}))\n        .transact()\n        .await?;\n    \n    assert!(result.is_success());\n    Ok(())\n}</code></pre>\n        ",
        "tags": [
          "near",
          "testing",
          "difficulty-intermediate"
        ],
        "order": 43
      },
      {
        "title": "What is NEAR's upgrade pattern for contracts?",
        "answer": "\n            <p>NEAR contracts can be upgraded by redeploying code, but state migration needs care.</p>\n            <strong>Upgrade pattern:</strong>\n            <pre><code class=\"language-rust\">// Version 1\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct ContractV1 {\n    data: String,\n}\n\n// Version 2 - Added new field\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct ContractV2 {\n    data: String,\n    new_field: u64,  // New!\n}\n\n// Migration\nimpl Contract {\n    #[private]\n    #[init(ignore_state)]\n    pub fn migrate() -> Self {\n        let old_state: ContractV1 = env::state_read().expect(\"failed to read state\");\n        \n        Self {\n            data: old_state.data,\n            new_field: 0,  // Default for new field\n        }\n    }\n}\n\n// Deployment script\nnear deploy --wasmFile new_contract.wasm --initFunction migrate --initArgs '{}' --accountId contract.near</code></pre>\n            <strong>Upgrade patterns:</strong>\n            <ul>\n                <li><strong>Lazy migration:</strong> Migrate records on access</li>\n                <li><strong>Versioned enums:</strong> Store state version</li>\n                <li><strong>Separate data contract:</strong> Logic upgrades easier</li>\n            </ul>\n        ",
        "tags": [
          "near",
          "upgrades",
          "difficulty-advanced"
        ],
        "order": 44
      },
      {
        "title": "How does NEAR handle errors and panics?",
        "answer": "\n            <p>NEAR contracts can panic (abort transaction) or return Result types.</p>\n            <strong>Error handling:</strong>\n            <pre><code class=\"language-rust\">use near_sdk::FunctionError;\n\n// Custom error enum\n#[derive(FunctionError, BorshSerialize)]\npub enum ContractError {\n    InsufficientBalance { required: u128, available: u128 },\n    Unauthorized,\n    InvalidInput(String),\n}\n\n#[near_bindgen]\nimpl Contract {\n    // Using require! macro (panics with message)\n    pub fn transfer(&mut self, to: AccountId, amount: U128) {\n        let sender = env::predecessor_account_id();\n        let balance = self.get_balance(&sender);\n        \n        require!(amount.0 <= balance, \"Insufficient balance\");\n        require!(amount.0 > 0, \"Amount must be positive\");\n        \n        self.internal_transfer(&sender, &to, amount.0);\n    }\n    \n    // Using Result type\n    pub fn safe_transfer(&mut self, to: AccountId, amount: U128) -> Result<(), ContractError> {\n        let sender = env::predecessor_account_id();\n        let balance = self.get_balance(&sender);\n        \n        if amount.0 > balance {\n            return Err(ContractError::InsufficientBalance {\n                required: amount.0,\n                available: balance,\n            });\n        }\n        \n        self.internal_transfer(&sender, &to, amount.0);\n        Ok(())\n    }\n}\n\n// Assert macros\nassert!(condition, \"message\");\nassert_eq!(a, b, \"a should equal b\");\nrequire!(condition, \"message\");  // NEAR-specific</code></pre>\n        ",
        "tags": [
          "near",
          "errors",
          "difficulty-intermediate"
        ],
        "order": 45
      },
      {
        "title": "What is CosmWasm?",
        "answer": "\n            <p><strong>CosmWasm</strong> is a smart contract platform for the Cosmos ecosystem, using Rust compiled to WebAssembly.</p>\n            <strong>Key features:</strong>\n            <ul>\n                <li><strong>Multi-chain:</strong> Deploy same contract across Cosmos chains</li>\n                <li><strong>Actor model:</strong> Contracts communicate via messages</li>\n                <li><strong>Capabilities:</strong> Fine-grained permissions system</li>\n                <li><strong>IBC-enabled:</strong> Cross-chain contract calls</li>\n            </ul>\n            <strong>Contract lifecycle:</strong>\n            <pre><code class=\"language-rust\">// 1. Store code on chain\nwasmd tx wasm store contract.wasm --from wallet\n\n// 2. Instantiate contract\nwasmd tx wasm instantiate $CODE_ID '{\"count\": 0}' --label \"counter\"\n\n// 3. Execute messages\nwasmd tx wasm execute $CONTRACT '{\"increment\": {}}'\n\n// 4. Query state\nwasmd query wasm contract-state smart $CONTRACT '{\"get_count\": {}}'</code></pre>\n            <strong>Chains using CosmWasm:</strong> Osmosis, Juno, Terra, Neutron, Injective\n        ",
        "tags": [
          "cosmwasm",
          "cosmos",
          "difficulty-intermediate"
        ],
        "order": 46
      },
      {
        "title": "What is the basic structure of a CosmWasm contract?",
        "answer": "\n            <p>CosmWasm contracts have three entry points: <strong>instantiate</strong>, <strong>execute</strong>, and <strong>query</strong>.</p>\n            <pre><code class=\"language-rust\">use cosmwasm_std::{\n    entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult,\n};\n\n// Contract state\n#[cw_serde]\npub struct State {\n    pub count: i32,\n    pub owner: Addr,\n}\n\n// Messages\n#[cw_serde]\npub struct InstantiateMsg {\n    pub count: i32,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    Increment {},\n    Reset { count: i32 },\n}\n\n#[cw_serde]\npub enum QueryMsg {\n    GetCount {},\n}\n\n// Entry points\n#[entry_point]\npub fn instantiate(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -> StdResult<Response> {\n    let state = State {\n        count: msg.count,\n        owner: info.sender.clone(),\n    };\n    STATE.save(deps.storage, &state)?;\n    Ok(Response::new().add_attribute(\"method\", \"instantiate\"))\n}\n\n#[entry_point]\npub fn execute(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::Increment {} => execute_increment(deps),\n        ExecuteMsg::Reset { count } => execute_reset(deps, info, count),\n    }\n}\n\n#[entry_point]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {\n    match msg {\n        QueryMsg::GetCount {} => to_binary(&query_count(deps)?),\n    }\n}</code></pre>\n        ",
        "tags": [
          "cosmwasm",
          "difficulty-intermediate"
        ],
        "order": 47
      },
      {
        "title": "How does CosmWasm storage work?",
        "answer": "\n            <p>CosmWasm provides storage primitives through <strong>cw-storage-plus</strong>.</p>\n            <pre><code class=\"language-rust\">use cw_storage_plus::{Item, Map, IndexedMap, MultiIndex, Index};\n\n// Simple item (single value)\npub const CONFIG: Item<Config> = Item::new(\"config\");\n\n// Map (key-value)\npub const BALANCES: Map<&Addr, Uint128> = Map::new(\"balances\");\n\n// Map with tuple key\npub const ALLOWANCES: Map<(&Addr, &Addr), Uint128> = Map::new(\"allowances\");\n\n// Usage\nfn example(deps: DepsMut) -> StdResult<()> {\n    // Save item\n    CONFIG.save(deps.storage, &config)?;\n    \n    // Load item\n    let config = CONFIG.load(deps.storage)?;\n    let config_maybe = CONFIG.may_load(deps.storage)?; // Returns Option\n    \n    // Map operations\n    BALANCES.save(deps.storage, &addr, &Uint128::new(1000))?;\n    let balance = BALANCES.load(deps.storage, &addr)?;\n    \n    // Update\n    BALANCES.update(deps.storage, &addr, |bal| -> StdResult<_> {\n        Ok(bal.unwrap_or_default() + amount)\n    })?;\n    \n    // Iterate\n    let all: StdResult<Vec<_>> = BALANCES\n        .range(deps.storage, None, None, Order::Ascending)\n        .collect();\n    \n    Ok(())\n}</code></pre>\n            <strong>Indexed maps for complex queries:</strong>\n            <pre><code class=\"language-rust\">pub struct TokenIndexes<'a> {\n    pub owner: MultiIndex<'a, Addr, TokenInfo, String>,\n}\n\nimpl<'a> IndexList<TokenInfo> for TokenIndexes<'a> {\n    fn get_indexes(&'_ self) -> Box<dyn Iterator<Item = &'_ dyn Index<TokenInfo>> + '_> {\n        let v: Vec<&dyn Index<TokenInfo>> = vec![&self.owner];\n        Box::new(v.into_iter())\n    }\n}\n\npub fn tokens<'a>() -> IndexedMap<'a, &'a str, TokenInfo, TokenIndexes<'a>> {\n    let indexes = TokenIndexes {\n        owner: MultiIndex::new(|_, d| d.owner.clone(), \"tokens\", \"tokens__owner\"),\n    };\n    IndexedMap::new(\"tokens\", indexes)\n}</code></pre>\n        ",
        "tags": [
          "cosmwasm",
          "storage",
          "difficulty-intermediate"
        ],
        "order": 48
      },
      {
        "title": "How do you handle funds in CosmWasm?",
        "answer": "\n            <p>CosmWasm contracts can receive and send native tokens through <strong>MessageInfo</strong> and <strong>BankMsg</strong>.</p>\n            <pre><code class=\"language-rust\">use cosmwasm_std::{BankMsg, Coin, coins, Uint128};\n\n#[entry_point]\npub fn execute(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,  // Contains sender and funds\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        ExecuteMsg::Deposit {} => {\n            // Check received funds\n            let payment = info\n                .funds\n                .iter()\n                .find(|c| c.denom == \"uatom\")\n                .ok_or(ContractError::NoFunds {})?;\n            \n            // Must be exactly 1 ATOM\n            if payment.amount != Uint128::new(1_000_000) {\n                return Err(ContractError::InvalidAmount {});\n            }\n            \n            // Store deposit...\n            Ok(Response::new())\n        }\n        \n        ExecuteMsg::Withdraw { amount } => {\n            // Send funds to caller\n            let msg = BankMsg::Send {\n                to_address: info.sender.to_string(),\n                amount: coins(amount.u128(), \"uatom\"),\n            };\n            \n            Ok(Response::new().add_message(msg))\n        }\n        \n        ExecuteMsg::Burn { amount } => {\n            // Burn tokens (send to module)\n            let msg = BankMsg::Burn {\n                amount: coins(amount.u128(), \"uatom\"),\n            };\n            \n            Ok(Response::new().add_message(msg))\n        }\n    }\n}\n\n// Query contract balance\nfn query_balance(deps: Deps, env: Env) -> StdResult<Coin> {\n    deps.querier.query_balance(env.contract.address, \"uatom\")\n}</code></pre>\n        ",
        "tags": [
          "cosmwasm",
          "funds",
          "difficulty-intermediate"
        ],
        "order": 49
      },
      {
        "title": "What is submessage and reply pattern in CosmWasm?",
        "answer": "\n            <p><strong>Submessages</strong> allow contracts to get callbacks after executing messages.</p>\n            <pre><code class=\"language-rust\">use cosmwasm_std::{SubMsg, Reply, ReplyOn};\n\nconst INSTANTIATE_REPLY_ID: u64 = 1;\n\npub fn execute_create_token(deps: DepsMut, env: Env) -> Result<Response, ContractError> {\n    let instantiate_msg = WasmMsg::Instantiate {\n        admin: Some(env.contract.address.to_string()),\n        code_id: CW20_CODE_ID,\n        msg: to_binary(&cw20_msg)?,\n        funds: vec![],\n        label: \"My Token\".to_string(),\n    };\n    \n    // SubMsg with reply\n    let submsg = SubMsg {\n        id: INSTANTIATE_REPLY_ID,\n        msg: instantiate_msg.into(),\n        gas_limit: None,\n        reply_on: ReplyOn::Success,  // Only reply on success\n    };\n    \n    Ok(Response::new().add_submessage(submsg))\n}\n\n#[entry_point]\npub fn reply(deps: DepsMut, _env: Env, msg: Reply) -> Result<Response, ContractError> {\n    match msg.id {\n        INSTANTIATE_REPLY_ID => {\n            // Parse the instantiation response\n            let res = parse_reply_instantiate_data(msg)?;\n            let token_addr = deps.api.addr_validate(&res.contract_address)?;\n            \n            // Store the new token address\n            TOKEN_ADDR.save(deps.storage, &token_addr)?;\n            \n            Ok(Response::new()\n                .add_attribute(\"token_address\", token_addr))\n        }\n        _ => Err(ContractError::UnknownReplyId { id: msg.id }),\n    }\n}</code></pre>\n            <strong>ReplyOn options:</strong>\n            <ul>\n                <li><strong>Always:</strong> Reply on success or error</li>\n                <li><strong>Success:</strong> Only reply on success</li>\n                <li><strong>Error:</strong> Only reply on error</li>\n                <li><strong>Never:</strong> Fire and forget</li>\n            </ul>\n        ",
        "tags": [
          "cosmwasm",
          "submessages",
          "difficulty-advanced"
        ],
        "order": 50
      },
      {
        "title": "How do you implement CW20 (fungible token) in CosmWasm?",
        "answer": "\n            <p><strong>CW20</strong> is the CosmWasm standard for fungible tokens, similar to ERC-20.</p>\n            <pre><code class=\"language-rust\">// Using cw20-base as foundation\nuse cw20_base::contract::{execute as cw20_execute, query as cw20_query};\nuse cw20_base::msg::{ExecuteMsg as Cw20ExecuteMsg, QueryMsg as Cw20QueryMsg};\n\n// Custom wrapper with additional functionality\n#[entry_point]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> Result<Response, ContractError> {\n    match msg {\n        // Handle CW20 standard messages\n        ExecuteMsg::Transfer { recipient, amount } => {\n            cw20_execute(deps, env, info, Cw20ExecuteMsg::Transfer { recipient, amount })\n                .map_err(Into::into)\n        }\n        // Custom message\n        ExecuteMsg::Mint { recipient, amount } => execute_mint(deps, env, info, recipient, amount),\n    }\n}\n\n// Or implement from scratch\n#[cw_serde]\npub struct TokenInfo {\n    pub name: String,\n    pub symbol: String,\n    pub decimals: u8,\n    pub total_supply: Uint128,\n}\n\npub fn execute_transfer(\n    deps: DepsMut,\n    _env: Env,\n    info: MessageInfo,\n    recipient: String,\n    amount: Uint128,\n) -> Result<Response, ContractError> {\n    let recipient = deps.api.addr_validate(&recipient)?;\n    \n    BALANCES.update(deps.storage, &info.sender, |bal| -> StdResult<_> {\n        Ok(bal.unwrap_or_default().checked_sub(amount)?)\n    })?;\n    \n    BALANCES.update(deps.storage, &recipient, |bal| -> StdResult<_> {\n        Ok(bal.unwrap_or_default() + amount)\n    })?;\n    \n    Ok(Response::new()\n        .add_attribute(\"action\", \"transfer\")\n        .add_attribute(\"from\", info.sender)\n        .add_attribute(\"to\", recipient)\n        .add_attribute(\"amount\", amount))\n}</code></pre>\n        ",
        "tags": [
          "cosmwasm",
          "cw20",
          "tokens",
          "difficulty-intermediate"
        ],
        "order": 51
      },
      {
        "title": "What is IBC in CosmWasm and how do you use it?",
        "answer": "\n            <p><strong>IBC (Inter-Blockchain Communication)</strong> enables cross-chain communication in Cosmos.</p>\n            <pre><code class=\"language-rust\">use cosmwasm_std::{IbcMsg, IbcTimeout, IbcChannel};\n\n// Send IBC packet\npub fn execute_send_ibc(\n    deps: DepsMut,\n    env: Env,\n    channel_id: String,\n    data: Binary,\n) -> Result<Response, ContractError> {\n    let timeout = IbcTimeout::with_timestamp(env.block.time.plus_seconds(300));\n    \n    let msg = IbcMsg::SendPacket {\n        channel_id,\n        data,\n        timeout,\n    };\n    \n    Ok(Response::new().add_message(msg))\n}\n\n// IBC entry points\n#[entry_point]\npub fn ibc_channel_open(\n    _deps: DepsMut,\n    _env: Env,\n    msg: IbcChannelOpenMsg,\n) -> Result<IbcChannelOpenResponse, ContractError> {\n    // Validate channel parameters\n    let channel = msg.channel();\n    if channel.order != IbcOrder::Unordered {\n        return Err(ContractError::OnlyUnorderedChannel {});\n    }\n    Ok(None)  // Accept channel\n}\n\n#[entry_point]\npub fn ibc_packet_receive(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketReceiveMsg,\n) -> Result<IbcReceiveResponse, ContractError> {\n    let packet = msg.packet;\n    let data: PacketData = from_binary(&packet.data)?;\n    \n    // Process received data\n    let response = process_packet(deps, data)?;\n    \n    Ok(IbcReceiveResponse::new()\n        .add_attribute(\"action\", \"receive\")\n        .set_ack(to_binary(&Ack::Success)?))\n}\n\n#[entry_point]\npub fn ibc_packet_ack(\n    deps: DepsMut,\n    _env: Env,\n    msg: IbcPacketAckMsg,\n) -> Result<Response, ContractError> {\n    // Handle acknowledgement\n    let ack: Ack = from_binary(&msg.acknowledgement.data)?;\n    match ack {\n        Ack::Success => { /* Success handling */ }\n        Ack::Error(err) => { /* Rollback on error */ }\n    }\n    Ok(Response::new())\n}</code></pre>\n        ",
        "tags": [
          "cosmwasm",
          "ibc",
          "difficulty-advanced"
        ],
        "order": 52
      },
      {
        "title": "How do you test CosmWasm contracts?",
        "answer": "\n            <p>CosmWasm provides <strong>cw-multi-test</strong> for integration testing.</p>\n            <pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};\n    use cosmwasm_std::{coins, from_binary};\n    use cw_multi_test::{App, ContractWrapper, Executor};\n\n    // Unit test with mocks\n    #[test]\n    fn proper_initialization() {\n        let mut deps = mock_dependencies();\n        let msg = InstantiateMsg { count: 17 };\n        let info = mock_info(\"creator\", &coins(1000, \"earth\"));\n        \n        let res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();\n        assert_eq!(0, res.messages.len());\n        \n        // Query state\n        let res = query(deps.as_ref(), mock_env(), QueryMsg::GetCount {}).unwrap();\n        let value: CountResponse = from_binary(&res).unwrap();\n        assert_eq!(17, value.count);\n    }\n\n    // Integration test with multi-test\n    #[test]\n    fn multi_contract_interaction() {\n        let mut app = App::default();\n        \n        // Upload contracts\n        let counter_code = ContractWrapper::new(execute, instantiate, query);\n        let counter_id = app.store_code(Box::new(counter_code));\n        \n        // Instantiate\n        let counter_addr = app\n            .instantiate_contract(\n                counter_id,\n                Addr::unchecked(\"owner\"),\n                &InstantiateMsg { count: 0 },\n                &[],\n                \"Counter\",\n                None,\n            )\n            .unwrap();\n        \n        // Execute\n        app.execute_contract(\n            Addr::unchecked(\"anyone\"),\n            counter_addr.clone(),\n            &ExecuteMsg::Increment {},\n            &[],\n        ).unwrap();\n        \n        // Query\n        let resp: CountResponse = app\n            .wrap()\n            .query_wasm_smart(counter_addr, &QueryMsg::GetCount {})\n            .unwrap();\n        assert_eq!(resp.count, 1);\n    }\n}</code></pre>\n        ",
        "tags": [
          "cosmwasm",
          "testing",
          "difficulty-intermediate"
        ],
        "order": 53
      },
      {
        "title": "What are admin and migration patterns in CosmWasm?",
        "answer": "\n            <p>CosmWasm contracts can have an <strong>admin</strong> for upgrades and a <strong>migrate</strong> entry point.</p>\n            <pre><code class=\"language-rust\">// Set admin during instantiation\nwasmd tx wasm instantiate $CODE_ID '{}' --admin $ADMIN_ADDR\n\n// Migration entry point\n#[entry_point]\npub fn migrate(deps: DepsMut, _env: Env, msg: MigrateMsg) -> Result<Response, ContractError> {\n    // Check contract version\n    let version: ContractVersion = get_contract_version(deps.storage)?;\n    if version.contract != CONTRACT_NAME {\n        return Err(ContractError::CannotMigrate {\n            previous_contract: version.contract,\n        });\n    }\n    \n    // Version check\n    let old_version: Version = version.version.parse()?;\n    let new_version: Version = CONTRACT_VERSION.parse()?;\n    \n    if old_version >= new_version {\n        return Err(ContractError::CannotMigrate {\n            previous_contract: version.version,\n        });\n    }\n    \n    // Perform migration\n    migrate_state_v1_to_v2(deps.storage)?;\n    \n    // Update version\n    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;\n    \n    Ok(Response::new()\n        .add_attribute(\"action\", \"migrate\")\n        .add_attribute(\"from_version\", version.version)\n        .add_attribute(\"to_version\", CONTRACT_VERSION))\n}\n\n// State migration helper\nfn migrate_state_v1_to_v2(storage: &mut dyn Storage) -> StdResult<()> {\n    #[cw_serde]\n    struct OldState { value: u32 }\n    \n    let old_state: OldState = Item::new(\"state\").load(storage)?;\n    \n    let new_state = State { \n        value: old_state.value,\n        new_field: Default::default(),\n    };\n    \n    STATE.save(storage, &new_state)\n}</code></pre>\n            <strong>Migrate command:</strong>\n            <pre><code class=\"language-bash\">wasmd tx wasm migrate $CONTRACT $NEW_CODE_ID '{\"new_param\": \"value\"}'</code></pre>\n        ",
        "tags": [
          "cosmwasm",
          "upgrades",
          "difficulty-advanced"
        ],
        "order": 54
      }
    ]
  }
}